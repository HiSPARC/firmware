--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 7.3 Revision 8 from HDL Works B.V.
--
-- Ease library  : design
-- HDL library   : work
-- Host name     : herik
-- User name     : admhisparc
-- Time stamp    : Mon Feb 27 11:45:01 2012
--
-- Designed by   : 
-- Company       : Translogic
-- Project info  : 
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity design.FAKE_DATA_GEN
-- Last modified : Fri Jun 04 13:11:55 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity FAKE_DATA_GEN is
  port(
    CLK200MHz     : in     std_logic;
    FAKE_DATA_NEG : out    std_logic_vector(11 downto 0);
    FAKE_DATA_POS : out    std_logic_vector(11 downto 0);
    SYSRST        : in     std_logic);
end entity FAKE_DATA_GEN;

--------------------------------------------------------------------------------
-- Object        : Architecture design.FAKE_DATA_GEN.rtl
-- Last modified : Fri Jun 04 13:11:55 2010.
--------------------------------------------------------------------------------


architecture rtl of FAKE_DATA_GEN is

signal DATA_PLUS_TWO: std_logic_vector(11 downto 0);
signal FAKE_DATA_POS_TMP: std_logic_vector(11 downto 0);

begin

-- Fake data generator
-- Increment positive fake data by two
  DATA_PLUS_TWO(0) <= '0';
  FAKE_DATA_POS <= FAKE_DATA_POS_TMP;
  
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_PLUS_TWO(11 downto 1) <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      DATA_PLUS_TWO(11 downto 1) <= DATA_PLUS_TWO(11 downto 1) + "00000000001";
    end if;
  end process;

-- Take over DATA_PLUS_TWO on positive edge to get FAKE_DATA_POS
  process(CLK200MHz)
  begin
    if (CLK200MHz'event and CLK200MHz = '1') then
      FAKE_DATA_POS_TMP <= DATA_PLUS_TWO;
    end if;
  end process;

-- Increment FAKE_DATA_POS by one
  process(CLK200MHz)
  begin
    if (CLK200MHz'event and CLK200MHz = '0') then -- negative edge
      FAKE_DATA_NEG <= FAKE_DATA_POS_TMP + "000000000001";
    end if;
  end process;

end architecture rtl ; -- of FAKE_DATA_GEN

--------------------------------------------------------------------------------
-- Object        : Entity design.PLL_DIV
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity PLL_DIV is
  port(
    CLK10MHz : out    std_logic;
    CLK20MHz : out    std_logic;
    CLK40MHz : out    std_logic;
    inclk0   : in     std_logic;
    locked   : out    std_logic);
end entity PLL_DIV;

--------------------------------------------------------------------------------
-- Object        : Architecture design.PLL_DIV.rtl
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------


-- megafunction wizard: %ALTPLL%
-- GENERATION: STANDARD
-- VERSION: WM1.0
-- MODULE: altpll 

-- ============================================================
-- File Name: PLL_DIV.vhd
-- Megafunction Name(s):
-- 			altpll
--
-- Simulation Library Files(s):
-- 			altera_mf
-- ============================================================
-- ************************************************************
-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
--
-- 9.0 Build 235 06/17/2009 SP 2 SJ Full Version
-- ************************************************************


--Copyright (C) 1991-2009 Altera Corporation
--Your use of Altera Corporation's design tools, logic functions 
--and other software and tools, and its AMPP partner logic 
--functions, and any output files from any of the foregoing 
--(including device programming or simulation files), and any 
--associated documentation or information are expressly subject 
--to the terms and conditions of the Altera Program License 
--Subscription Agreement, Altera MegaCore Function License 
--Agreement, or other applicable license agreement, including, 
--without limitation, that your use is for the sole purpose of 
--programming logic devices manufactured by Altera and sold by 
--Altera or its authorized distributors.  Please refer to the 
--applicable agreement for further details.


LIBRARY ieee;
USE ieee.std_logic_1164.all;

LIBRARY altera_mf;
USE altera_mf.all;

--ENTITY PLL_DIV IS
--	PORT
--	(
--		inclk0		: IN STD_LOGIC  := '0';
--		c0		: OUT STD_LOGIC ;
--		c1		: OUT STD_LOGIC ;
--		c2		: OUT STD_LOGIC ;
--		locked		: OUT STD_LOGIC 
--	);
--END PLL_DIV;


architecture rtl of PLL_DIV is

	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (4 DOWNTO 0);
	SIGNAL sub_wire1	: STD_LOGIC ;
	SIGNAL sub_wire2	: STD_LOGIC ;
	SIGNAL sub_wire3	: STD_LOGIC ;
	SIGNAL sub_wire4	: STD_LOGIC ;
	SIGNAL sub_wire5	: STD_LOGIC ;
	SIGNAL sub_wire6	: STD_LOGIC_VECTOR (1 DOWNTO 0);
	SIGNAL sub_wire7_bv	: BIT_VECTOR (0 DOWNTO 0);
	SIGNAL sub_wire7	: STD_LOGIC_VECTOR (0 DOWNTO 0);



	COMPONENT altpll
	GENERIC (
		bandwidth_type		: STRING;
		clk0_divide_by		: NATURAL;
		clk0_duty_cycle		: NATURAL;
		clk0_multiply_by		: NATURAL;
		clk0_phase_shift		: STRING;
		clk1_divide_by		: NATURAL;
		clk1_duty_cycle		: NATURAL;
		clk1_multiply_by		: NATURAL;
		clk1_phase_shift		: STRING;
		clk2_divide_by		: NATURAL;
		clk2_duty_cycle		: NATURAL;
		clk2_multiply_by		: NATURAL;
		clk2_phase_shift		: STRING;
		compensate_clock		: STRING;
		inclk0_input_frequency		: NATURAL;
		intended_device_family		: STRING;
		lpm_hint		: STRING;
		lpm_type		: STRING;
		operation_mode		: STRING;
		pll_type		: STRING;
		port_activeclock		: STRING;
		port_areset		: STRING;
		port_clkbad0		: STRING;
		port_clkbad1		: STRING;
		port_clkloss		: STRING;
		port_clkswitch		: STRING;
		port_configupdate		: STRING;
		port_fbin		: STRING;
		port_inclk0		: STRING;
		port_inclk1		: STRING;
		port_locked		: STRING;
		port_pfdena		: STRING;
		port_phasecounterselect		: STRING;
		port_phasedone		: STRING;
		port_phasestep		: STRING;
		port_phaseupdown		: STRING;
		port_pllena		: STRING;
		port_scanaclr		: STRING;
		port_scanclk		: STRING;
		port_scanclkena		: STRING;
		port_scandata		: STRING;
		port_scandataout		: STRING;
		port_scandone		: STRING;
		port_scanread		: STRING;
		port_scanwrite		: STRING;
		port_clk0		: STRING;
		port_clk1		: STRING;
		port_clk2		: STRING;
		port_clk3		: STRING;
		port_clk4		: STRING;
		port_clk5		: STRING;
		port_clkena0		: STRING;
		port_clkena1		: STRING;
		port_clkena2		: STRING;
		port_clkena3		: STRING;
		port_clkena4		: STRING;
		port_clkena5		: STRING;
		port_extclk0		: STRING;
		port_extclk1		: STRING;
		port_extclk2		: STRING;
		port_extclk3		: STRING;
		self_reset_on_loss_lock		: STRING;
		width_clock		: NATURAL
	);
	PORT (
			inclk	: IN STD_LOGIC_VECTOR (1 DOWNTO 0);
			locked	: OUT STD_LOGIC ;
			clk	: OUT STD_LOGIC_VECTOR (4 DOWNTO 0)
	);
	END COMPONENT;

BEGIN
	sub_wire7_bv(0 DOWNTO 0) <= "0";
	sub_wire7    <= To_stdlogicvector(sub_wire7_bv);
	sub_wire3    <= sub_wire0(2);
	sub_wire2    <= sub_wire0(1);
	sub_wire1    <= sub_wire0(0);
--	c0    <= sub_wire1;
--	c1    <= sub_wire2;
--	c2    <= sub_wire3;
	CLK40MHz    <= sub_wire1;
	CLK20MHz    <= sub_wire2;
	CLK10MHz    <= sub_wire3;
	locked    <= sub_wire4;
	sub_wire5    <= inclk0;
	sub_wire6    <= sub_wire7(0 DOWNTO 0) & sub_wire5;

	altpll_component : altpll
	GENERIC MAP (
		bandwidth_type => "AUTO",
		clk0_divide_by => 1,
		clk0_duty_cycle => 50,
		clk0_multiply_by => 1,
		clk0_phase_shift => "0",
		clk1_divide_by => 2,
		clk1_duty_cycle => 50,
		clk1_multiply_by => 1,
		clk1_phase_shift => "0",
		clk2_divide_by => 4,
		clk2_duty_cycle => 50,
		clk2_multiply_by => 1,
		clk2_phase_shift => "0",
		compensate_clock => "CLK0",
		inclk0_input_frequency => 25000,
		intended_device_family => "Cyclone III",
		lpm_hint => "CBX_MODULE_PREFIX=PLL_DIV",
		lpm_type => "altpll",
		operation_mode => "NORMAL",
		pll_type => "AUTO",
		port_activeclock => "PORT_UNUSED",
		port_areset => "PORT_UNUSED",
		port_clkbad0 => "PORT_UNUSED",
		port_clkbad1 => "PORT_UNUSED",
		port_clkloss => "PORT_UNUSED",
		port_clkswitch => "PORT_UNUSED",
		port_configupdate => "PORT_UNUSED",
		port_fbin => "PORT_UNUSED",
		port_inclk0 => "PORT_USED",
		port_inclk1 => "PORT_UNUSED",
		port_locked => "PORT_USED",
		port_pfdena => "PORT_UNUSED",
		port_phasecounterselect => "PORT_UNUSED",
		port_phasedone => "PORT_UNUSED",
		port_phasestep => "PORT_UNUSED",
		port_phaseupdown => "PORT_UNUSED",
		port_pllena => "PORT_UNUSED",
		port_scanaclr => "PORT_UNUSED",
		port_scanclk => "PORT_UNUSED",
		port_scanclkena => "PORT_UNUSED",
		port_scandata => "PORT_UNUSED",
		port_scandataout => "PORT_UNUSED",
		port_scandone => "PORT_UNUSED",
		port_scanread => "PORT_UNUSED",
		port_scanwrite => "PORT_UNUSED",
		port_clk0 => "PORT_USED",
		port_clk1 => "PORT_USED",
		port_clk2 => "PORT_USED",
		port_clk3 => "PORT_UNUSED",
		port_clk4 => "PORT_UNUSED",
		port_clk5 => "PORT_UNUSED",
		port_clkena0 => "PORT_UNUSED",
		port_clkena1 => "PORT_UNUSED",
		port_clkena2 => "PORT_UNUSED",
		port_clkena3 => "PORT_UNUSED",
		port_clkena4 => "PORT_UNUSED",
		port_clkena5 => "PORT_UNUSED",
		port_extclk0 => "PORT_UNUSED",
		port_extclk1 => "PORT_UNUSED",
		port_extclk2 => "PORT_UNUSED",
		port_extclk3 => "PORT_UNUSED",
		self_reset_on_loss_lock => "OFF",
		width_clock => 5
	)
	PORT MAP (
		inclk => sub_wire6,
		clk => sub_wire0,
		locked => sub_wire4
	);



end architecture rtl ; -- of PLL_DIV

-- ============================================================
-- CNX file retrieval info
-- ============================================================
-- Retrieval info: PRIVATE: ACTIVECLK_CHECK STRING "0"
-- Retrieval info: PRIVATE: BANDWIDTH STRING "1.000"
-- Retrieval info: PRIVATE: BANDWIDTH_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: BANDWIDTH_FREQ_UNIT STRING "MHz"
-- Retrieval info: PRIVATE: BANDWIDTH_PRESET STRING "Low"
-- Retrieval info: PRIVATE: BANDWIDTH_USE_AUTO STRING "1"
-- Retrieval info: PRIVATE: BANDWIDTH_USE_PRESET STRING "0"
-- Retrieval info: PRIVATE: CLKBAD_SWITCHOVER_CHECK STRING "0"
-- Retrieval info: PRIVATE: CLKLOSS_CHECK STRING "0"
-- Retrieval info: PRIVATE: CLKSWITCH_CHECK STRING "0"
-- Retrieval info: PRIVATE: CNX_NO_COMPENSATE_RADIO STRING "0"
-- Retrieval info: PRIVATE: CREATE_CLKBAD_CHECK STRING "0"
-- Retrieval info: PRIVATE: CREATE_INCLK1_CHECK STRING "0"
-- Retrieval info: PRIVATE: CUR_DEDICATED_CLK STRING "c0"
-- Retrieval info: PRIVATE: CUR_FBIN_CLK STRING "e0"
-- Retrieval info: PRIVATE: DEVICE_SPEED_GRADE STRING "Any"
-- Retrieval info: PRIVATE: DIV_FACTOR0 NUMERIC "1"
-- Retrieval info: PRIVATE: DIV_FACTOR1 NUMERIC "2"
-- Retrieval info: PRIVATE: DIV_FACTOR2 NUMERIC "4"
-- Retrieval info: PRIVATE: DUTY_CYCLE0 STRING "50.00000000"
-- Retrieval info: PRIVATE: DUTY_CYCLE1 STRING "50.00000000"
-- Retrieval info: PRIVATE: DUTY_CYCLE2 STRING "50.00000000"
-- Retrieval info: PRIVATE: EFF_OUTPUT_FREQ_VALUE0 STRING "40.000000"
-- Retrieval info: PRIVATE: EFF_OUTPUT_FREQ_VALUE1 STRING "20.000000"
-- Retrieval info: PRIVATE: EFF_OUTPUT_FREQ_VALUE2 STRING "10.000000"
-- Retrieval info: PRIVATE: EXPLICIT_SWITCHOVER_COUNTER STRING "0"
-- Retrieval info: PRIVATE: EXT_FEEDBACK_RADIO STRING "0"
-- Retrieval info: PRIVATE: GLOCKED_COUNTER_EDIT_CHANGED STRING "1"
-- Retrieval info: PRIVATE: GLOCKED_FEATURE_ENABLED STRING "0"
-- Retrieval info: PRIVATE: GLOCKED_MODE_CHECK STRING "0"
-- Retrieval info: PRIVATE: GLOCK_COUNTER_EDIT NUMERIC "1048575"
-- Retrieval info: PRIVATE: HAS_MANUAL_SWITCHOVER STRING "1"
-- Retrieval info: PRIVATE: INCLK0_FREQ_EDIT STRING "40.000"
-- Retrieval info: PRIVATE: INCLK0_FREQ_UNIT_COMBO STRING "MHz"
-- Retrieval info: PRIVATE: INCLK1_FREQ_EDIT STRING "100.000"
-- Retrieval info: PRIVATE: INCLK1_FREQ_EDIT_CHANGED STRING "1"
-- Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_CHANGED STRING "1"
-- Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_COMBO STRING "MHz"
-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone III"
-- Retrieval info: PRIVATE: INT_FEEDBACK__MODE_RADIO STRING "1"
-- Retrieval info: PRIVATE: LOCKED_OUTPUT_CHECK STRING "1"
-- Retrieval info: PRIVATE: LONG_SCAN_RADIO STRING "1"
-- Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE STRING "320.000"
-- Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE_DIRTY NUMERIC "0"
-- Retrieval info: PRIVATE: LVDS_PHASE_SHIFT_UNIT0 STRING "deg"
-- Retrieval info: PRIVATE: LVDS_PHASE_SHIFT_UNIT1 STRING "deg"
-- Retrieval info: PRIVATE: LVDS_PHASE_SHIFT_UNIT2 STRING "deg"
-- Retrieval info: PRIVATE: MIG_DEVICE_SPEED_GRADE STRING "Any"
-- Retrieval info: PRIVATE: MIRROR_CLK0 STRING "0"
-- Retrieval info: PRIVATE: MIRROR_CLK1 STRING "0"
-- Retrieval info: PRIVATE: MIRROR_CLK2 STRING "0"
-- Retrieval info: PRIVATE: MULT_FACTOR0 NUMERIC "1"
-- Retrieval info: PRIVATE: MULT_FACTOR1 NUMERIC "1"
-- Retrieval info: PRIVATE: MULT_FACTOR2 NUMERIC "1"
-- Retrieval info: PRIVATE: NORMAL_MODE_RADIO STRING "1"
-- Retrieval info: PRIVATE: OUTPUT_FREQ0 STRING "100.00000000"
-- Retrieval info: PRIVATE: OUTPUT_FREQ1 STRING "100.00000000"
-- Retrieval info: PRIVATE: OUTPUT_FREQ2 STRING "100.00000000"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_MODE0 STRING "0"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_MODE1 STRING "0"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_MODE2 STRING "0"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_UNIT0 STRING "MHz"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_UNIT1 STRING "MHz"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_UNIT2 STRING "MHz"
-- Retrieval info: PRIVATE: PHASE_RECONFIG_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: PHASE_RECONFIG_INPUTS_CHECK STRING "0"
-- Retrieval info: PRIVATE: PHASE_SHIFT0 STRING "0.00000000"
-- Retrieval info: PRIVATE: PHASE_SHIFT1 STRING "0.00000000"
-- Retrieval info: PRIVATE: PHASE_SHIFT2 STRING "0.00000000"
-- Retrieval info: PRIVATE: PHASE_SHIFT_STEP_ENABLED_CHECK STRING "0"
-- Retrieval info: PRIVATE: PHASE_SHIFT_UNIT0 STRING "deg"
-- Retrieval info: PRIVATE: PHASE_SHIFT_UNIT1 STRING "deg"
-- Retrieval info: PRIVATE: PHASE_SHIFT_UNIT2 STRING "deg"
-- Retrieval info: PRIVATE: PLL_ADVANCED_PARAM_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_ARESET_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_AUTOPLL_CHECK NUMERIC "1"
-- Retrieval info: PRIVATE: PLL_ENHPLL_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PLL_FASTPLL_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PLL_FBMIMIC_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_LVDS_PLL_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PLL_PFDENA_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_TARGET_HARCOPY_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PRIMARY_CLK_COMBO STRING "inclk0"
-- Retrieval info: PRIVATE: RECONFIG_FILE STRING "PLL_DIV.mif"
-- Retrieval info: PRIVATE: SACN_INPUTS_CHECK STRING "0"
-- Retrieval info: PRIVATE: SCAN_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: SELF_RESET_LOCK_LOSS STRING "0"
-- Retrieval info: PRIVATE: SHORT_SCAN_RADIO STRING "0"
-- Retrieval info: PRIVATE: SPREAD_FEATURE_ENABLED STRING "0"
-- Retrieval info: PRIVATE: SPREAD_FREQ STRING "50.000"
-- Retrieval info: PRIVATE: SPREAD_FREQ_UNIT STRING "KHz"
-- Retrieval info: PRIVATE: SPREAD_PERCENT STRING "0.500"
-- Retrieval info: PRIVATE: SPREAD_USE STRING "0"
-- Retrieval info: PRIVATE: SRC_SYNCH_COMP_RADIO STRING "0"
-- Retrieval info: PRIVATE: STICKY_CLK0 STRING "1"
-- Retrieval info: PRIVATE: STICKY_CLK1 STRING "1"
-- Retrieval info: PRIVATE: STICKY_CLK2 STRING "1"
-- Retrieval info: PRIVATE: SWITCHOVER_COUNT_EDIT NUMERIC "1"
-- Retrieval info: PRIVATE: SWITCHOVER_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
-- Retrieval info: PRIVATE: USE_CLK0 STRING "1"
-- Retrieval info: PRIVATE: USE_CLK1 STRING "1"
-- Retrieval info: PRIVATE: USE_CLK2 STRING "1"
-- Retrieval info: PRIVATE: USE_CLKENA0 STRING "0"
-- Retrieval info: PRIVATE: USE_CLKENA1 STRING "0"
-- Retrieval info: PRIVATE: USE_CLKENA2 STRING "0"
-- Retrieval info: PRIVATE: USE_MIL_SPEED_GRADE NUMERIC "0"
-- Retrieval info: PRIVATE: ZERO_DELAY_RADIO STRING "0"
-- Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
-- Retrieval info: CONSTANT: BANDWIDTH_TYPE STRING "AUTO"
-- Retrieval info: CONSTANT: CLK0_DIVIDE_BY NUMERIC "1"
-- Retrieval info: CONSTANT: CLK0_DUTY_CYCLE NUMERIC "50"
-- Retrieval info: CONSTANT: CLK0_MULTIPLY_BY NUMERIC "1"
-- Retrieval info: CONSTANT: CLK0_PHASE_SHIFT STRING "0"
-- Retrieval info: CONSTANT: CLK1_DIVIDE_BY NUMERIC "2"
-- Retrieval info: CONSTANT: CLK1_DUTY_CYCLE NUMERIC "50"
-- Retrieval info: CONSTANT: CLK1_MULTIPLY_BY NUMERIC "1"
-- Retrieval info: CONSTANT: CLK1_PHASE_SHIFT STRING "0"
-- Retrieval info: CONSTANT: CLK2_DIVIDE_BY NUMERIC "4"
-- Retrieval info: CONSTANT: CLK2_DUTY_CYCLE NUMERIC "50"
-- Retrieval info: CONSTANT: CLK2_MULTIPLY_BY NUMERIC "1"
-- Retrieval info: CONSTANT: CLK2_PHASE_SHIFT STRING "0"
-- Retrieval info: CONSTANT: COMPENSATE_CLOCK STRING "CLK0"
-- Retrieval info: CONSTANT: INCLK0_INPUT_FREQUENCY NUMERIC "25000"
-- Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Cyclone III"
-- Retrieval info: CONSTANT: LPM_TYPE STRING "altpll"
-- Retrieval info: CONSTANT: OPERATION_MODE STRING "NORMAL"
-- Retrieval info: CONSTANT: PLL_TYPE STRING "AUTO"
-- Retrieval info: CONSTANT: PORT_ACTIVECLOCK STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_ARESET STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKBAD0 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKBAD1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKLOSS STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKSWITCH STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CONFIGUPDATE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_FBIN STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_INCLK0 STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_INCLK1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_LOCKED STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_PFDENA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASECOUNTERSELECT STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASEDONE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASESTEP STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASEUPDOWN STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PLLENA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANACLR STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANCLK STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANCLKENA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANDATA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANDATAOUT STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANDONE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANREAD STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANWRITE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk0 STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_clk1 STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_clk2 STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_clk3 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk4 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk5 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena0 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena2 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena3 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena4 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena5 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk0 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk2 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk3 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: SELF_RESET_ON_LOSS_LOCK STRING "OFF"
-- Retrieval info: CONSTANT: WIDTH_CLOCK NUMERIC "5"
-- Retrieval info: USED_PORT: @clk 0 0 5 0 OUTPUT_CLK_EXT VCC "@clk[4..0]"
-- Retrieval info: USED_PORT: @inclk 0 0 2 0 INPUT_CLK_EXT VCC "@inclk[1..0]"
-- Retrieval info: USED_PORT: c0 0 0 0 0 OUTPUT_CLK_EXT VCC "c0"
-- Retrieval info: USED_PORT: c1 0 0 0 0 OUTPUT_CLK_EXT VCC "c1"
-- Retrieval info: USED_PORT: c2 0 0 0 0 OUTPUT_CLK_EXT VCC "c2"
-- Retrieval info: USED_PORT: inclk0 0 0 0 0 INPUT_CLK_EXT GND "inclk0"
-- Retrieval info: USED_PORT: locked 0 0 0 0 OUTPUT GND "locked"
-- Retrieval info: CONNECT: locked 0 0 0 0 @locked 0 0 0 0
-- Retrieval info: CONNECT: @inclk 0 0 1 0 inclk0 0 0 0 0
-- Retrieval info: CONNECT: c0 0 0 0 0 @clk 0 0 1 0
-- Retrieval info: CONNECT: c1 0 0 0 0 @clk 0 0 1 1
-- Retrieval info: CONNECT: c2 0 0 0 0 @clk 0 0 1 2
-- Retrieval info: CONNECT: @inclk 0 0 1 1 GND 0 0 0 0
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV.vhd TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV.ppf TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV.inc FALSE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV.cmp TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV.bsf FALSE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV_inst.vhd FALSE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV_waveforms.html TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_DIV_wave*.jpg FALSE
-- Retrieval info: LIB_FILE: altera_mf
-- Retrieval info: CBX_MODULE_PREFIX: ON

--------------------------------------------------------------------------------
-- Object        : Entity design.FIFO_SELECT
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity FIFO_SELECT is
  port(
    BLOCK_COINC             : out    std_logic;
    CLK200MHz               : in     std_logic;
    CLKRD                   : in     std_logic;
    COINC_TO_END_TIME       : in     std_logic;
    COINC_TO_END_TIME_FIFO1 : out    std_logic;
    COINC_TO_END_TIME_FIFO2 : out    std_logic;
    CTD_IN                  : in     std_logic_vector(31 downto 0);
    CTD_OUT                 : out    std_logic_vector(31 downto 0);
    DATA_OUT1_CH1           : in     std_logic_vector(11 downto 0);
    DATA_OUT1_CH2           : in     std_logic_vector(11 downto 0);
    DATA_OUT2_CH1           : in     std_logic_vector(11 downto 0);
    DATA_OUT2_CH2           : in     std_logic_vector(11 downto 0);
    DATA_OUT_CH1            : out    std_logic_vector(11 downto 0);
    DATA_OUT_CH2            : out    std_logic_vector(11 downto 0);
    DATA_READY1_CH1         : in     std_logic;
    DATA_READY1_CH2         : in     std_logic;
    DATA_READY2_CH1         : in     std_logic;
    DATA_READY2_CH2         : in     std_logic;
    DATA_READY_CH1          : out    std_logic;
    DATA_READY_CH2          : out    std_logic;
    DATA_VALID_CH1          : out    std_logic;
    DATA_VALID_CH2          : out    std_logic;
    GPS_TS_IN               : in     std_logic_vector(55 downto 0);
    GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
    RDEN1_CH1               : out    std_logic;
    RDEN1_CH2               : out    std_logic;
    RDEN2_CH1               : out    std_logic;
    RDEN2_CH2               : out    std_logic;
    RDEN_CH1                : in     std_logic;
    RDEN_CH2                : in     std_logic;
    READOUT_BUSY1_CH1       : in     std_logic;
    READOUT_BUSY1_CH2       : in     std_logic;
    READOUT_BUSY2_CH1       : in     std_logic;
    READOUT_BUSY2_CH2       : in     std_logic;
    SYSRST                  : in     std_logic;
    TRIGGER_PATTERN         : out    std_logic_vector(15 downto 0);
    TRIGGER_PATTERN_IN      : in     std_logic_vector(15 downto 0));
end entity FIFO_SELECT;

--------------------------------------------------------------------------------
-- Object        : Architecture design.FIFO_SELECT.a0
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------


architecture a0 of FIFO_SELECT is

signal COINC_TO_END_TIME_DEL1: std_logic;
signal COINC_SWITCH: std_logic_vector(1 downto 0); -- bit0 is gates coinc to channel 1 and bit1 to channel 2
signal BLOCK_SWITCH: std_logic_vector(1 downto 0); -- bit0 is set at a coinc to channel 1 and bit1 is set at a coinc to channel 2; end of readout of the channel, clears the bit
signal DATA_READY1: std_logic; -- active when there is latched data in one of the first fifo's
signal DATA_READY2: std_logic; -- active when there is latched data in one of the second fifo's
signal DATA_READY1_DEL1: std_logic; -- delay's to synchronize it with the 200MHz
signal DATA_READY2_DEL1: std_logic; -- delay's to synchronize it with the 200MHz
signal DATA_READY1_DEL2: std_logic;
signal DATA_READY2_DEL2: std_logic;
signal DATA_READY_FIFO1: std_logic;
signal DATA_READY_FIFO2: std_logic;
signal READY: std_logic_vector(1 downto 0); -- bit0 selects FIFO1 and bit1 selects FIFO2
signal COINC_TO_FIFO1: std_logic;
signal COINC_TO_FIFO1_DEL1: std_logic;
signal COINC_TO_FIFO2: std_logic;
signal COINC_TO_FIFO2_DEL1: std_logic;
signal RDEN_CH2_DEL1: std_logic;
signal TRIGGER_PATTERN_TIME1: std_logic_vector(15 downto 0);
signal TRIGGER_PATTERN_TIME2: std_logic_vector(15 downto 0);
signal CTD_TIME1: std_logic_vector(31 downto 0);
signal CTD_TIME2: std_logic_vector(31 downto 0);
signal GPS_TS_TIME1: std_logic_vector(55 downto 0);
signal GPS_TS_TIME2: std_logic_vector(55 downto 0);

begin

  COINC_TO_END_TIME_FIFO1 <= COINC_TO_FIFO1;
  COINC_TO_END_TIME_FIFO2 <= COINC_TO_FIFO2;

  -- DATA_READY_FIFO is true when there is data in both fifo's of the channels made on the same COINC
  DATA_READY_FIFO1 <= DATA_READY1_CH1 and DATA_READY1_CH2;
  DATA_READY_FIFO2 <= DATA_READY2_CH1 and DATA_READY2_CH2;

  -- BLOCK_COINC if FIFO's1 and FIFO's2 are full
  BLOCK_COINC <= '1' when BLOCK_SWITCH = "11" else '0';

  DATA_READY1 <= DATA_READY1_CH1 or DATA_READY1_CH2;
  DATA_READY2 <= DATA_READY2_CH1 or DATA_READY2_CH2;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_SWITCH <= "00";
      BLOCK_SWITCH <= "00";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if DATA_READY1_DEL1 = '0' and  DATA_READY1_DEL2 = '1' then -- on a falling edge of DATA_READY1, the first fifo's have been read out
        COINC_SWITCH(0) <= '0'; -- Clear coinc_switch0
        BLOCK_SWITCH(0) <= '0'; -- Clear block_switch0
      elsif DATA_READY2_DEL1 = '0' and  DATA_READY2_DEL2 = '1' then -- on a falling edge of DATA_READY2, the second fifo's have been read out
        COINC_SWITCH(1) <= '0'; -- Clear coinc_switch1
        BLOCK_SWITCH(1) <= '0'; -- Clear block_switch1
      elsif BLOCK_SWITCH /= "11" and (COINC_SWITCH = "00" or COINC_SWITCH = "10") and COINC_TO_END_TIME = '1' and  COINC_TO_END_TIME_DEL1 = '0' then -- on a rising edge of COINC_TO_END_TIME and COINC_SWITCH(0) = '0'
        COINC_SWITCH <= "01"; -- Set coinc_switch0
        BLOCK_SWITCH(0) <= '1'; -- Set block_switch0
      elsif BLOCK_SWITCH /= "11" and COINC_SWITCH = "01" and COINC_TO_END_TIME = '1' and  COINC_TO_END_TIME_DEL1 = '0' then -- on a rising edge of COINC_TO_END_TIME and COINC_SWITCH(0) = '1' and COINC_SWITCH(1) = '0'
        COINC_SWITCH <= "10"; -- Set coinc_switch1
        BLOCK_SWITCH(1) <= '1'; -- Set block_switch1
      end if;
    end if;
  end process;

  -- COINC Multiplexer
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_FIFO1 <= '0';
      COINC_TO_FIFO2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_SWITCH = "01" then
        COINC_TO_FIFO1 <= COINC_TO_END_TIME_DEL1;
      elsif COINC_SWITCH = "10" then
        COINC_TO_FIFO2 <= COINC_TO_END_TIME_DEL1;
      else
        COINC_TO_FIFO1 <= '0';
        COINC_TO_FIFO2 <= '0';
      end if;
    end if;
  end process;

  -- delay's  on CLK200MHz
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_DEL1 <= '0';
      DATA_READY1_DEL1 <= '0';
      DATA_READY1_DEL2 <= '0';
      DATA_READY2_DEL1 <= '0';
      DATA_READY2_DEL2 <= '0';
      COINC_TO_FIFO1_DEL1 <= '0';
      COINC_TO_FIFO2_DEL1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COINC_TO_END_TIME_DEL1 <= COINC_TO_END_TIME;
      DATA_READY1_DEL1 <= DATA_READY1;
      DATA_READY1_DEL2 <= DATA_READY1_DEL1;
      DATA_READY2_DEL1 <= DATA_READY2;
      DATA_READY2_DEL2 <= DATA_READY2_DEL1;
      COINC_TO_FIFO1_DEL1 <= COINC_TO_FIFO1;
      COINC_TO_FIFO2_DEL1 <= COINC_TO_FIFO2;
    end if;
  end process;

  -- delay's  on CLKRD
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      RDEN_CH2_DEL1 <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      RDEN_CH2_DEL1 <= RDEN_CH2;
    end if;
  end process;

  -- Determine which channel has to be readout
  -- A event in both FIFO's of the channels have been written to the next FIFO at the end of RDEN_CH2
  -- Thus at the end of RDEN_CH2 a new situation must be checked
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      READY <= "00"; -- default state
    elsif (CLKRD'event and CLKRD = '1') then
      if (READY = "11") or (RDEN_CH2 = '0' and RDEN_CH2_DEL1 = '1') then -- clear READY
        READY <= "00"; -- default state
      elsif READY(0) = '1' or READY(1) = '1' then -- Latch READY if there is data in one of the FIFO's
        READY <= READY;
      else -- if there is no data the FIFO's
        READY(0) <= DATA_READY_FIFO1;
        READY(1) <= DATA_READY_FIFO2;
      end if;
    end if;
  end process;

  -- Multiplexer
  process(READY,DATA_OUT1_CH1,DATA_OUT2_CH1,DATA_OUT1_CH2,DATA_OUT2_CH2,
          DATA_READY1_CH1,DATA_READY2_CH1,DATA_READY1_CH2,DATA_READY2_CH2,
          RDEN_CH1,RDEN_CH2,
          READOUT_BUSY1_CH1,READOUT_BUSY2_CH1,READOUT_BUSY1_CH2,READOUT_BUSY2_CH2,
          TRIGGER_PATTERN_TIME1,GPS_TS_TIME1,CTD_TIME1,TRIGGER_PATTERN_TIME2,GPS_TS_TIME2,CTD_TIME2)
  begin
    case(READY) is
      when "00" => DATA_OUT_CH1 <= DATA_OUT1_CH1;
                   DATA_READY_CH1 <= '0';
                   RDEN1_CH1 <= '0';
                   RDEN2_CH1 <= '0';
                   DATA_OUT_CH2 <= DATA_OUT1_CH2;
                   DATA_READY_CH2 <= '0';
                   DATA_VALID_CH1 <= '0';
                   DATA_VALID_CH2 <= '0';
                   RDEN1_CH2 <= '0';
                   RDEN2_CH2 <= '0';
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME1;
                   GPS_TS_OUT <= GPS_TS_TIME1;
                   CTD_OUT <= CTD_TIME1;
      when "01" => DATA_OUT_CH1 <= DATA_OUT1_CH1;
                   DATA_READY_CH1 <= DATA_READY1_CH1;
                   RDEN1_CH1 <= RDEN_CH1;
                   RDEN2_CH1 <= '0';
                   DATA_OUT_CH2 <= DATA_OUT1_CH2;
                   DATA_READY_CH2 <= DATA_READY1_CH2;
                   DATA_VALID_CH1 <= READOUT_BUSY1_CH1;
                   DATA_VALID_CH2 <= READOUT_BUSY1_CH2;
                   RDEN1_CH2 <= RDEN_CH2;
                   RDEN2_CH2 <= '0';
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME1;
                   GPS_TS_OUT <= GPS_TS_TIME1;
                   CTD_OUT <= CTD_TIME1;
      when "10" => DATA_OUT_CH1 <= DATA_OUT2_CH1;
                   DATA_READY_CH1 <= DATA_READY2_CH1;
                   RDEN1_CH1 <= '0';
                   RDEN2_CH1 <= RDEN_CH1;
                   DATA_OUT_CH2 <= DATA_OUT2_CH2;
                   DATA_READY_CH2 <= DATA_READY2_CH2;
                   DATA_VALID_CH1 <= READOUT_BUSY2_CH1;
                   DATA_VALID_CH2 <= READOUT_BUSY2_CH2;
                   RDEN1_CH2 <= '0';
                   RDEN2_CH2 <= RDEN_CH2;
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME2;
                   GPS_TS_OUT <= GPS_TS_TIME2;
                   CTD_OUT <= CTD_TIME2;
      when "11" => DATA_OUT_CH1 <= DATA_OUT1_CH1; -- never assigned
                   DATA_READY_CH1 <= '0';
                   RDEN1_CH1 <= '0';
                   RDEN2_CH1 <= '0';
                   DATA_OUT_CH2 <= DATA_OUT1_CH2;
                   DATA_READY_CH2 <= '0';
                   DATA_VALID_CH1 <= '0';
                   DATA_VALID_CH2 <= '0';
                   RDEN1_CH2 <= '0';
                   RDEN2_CH2 <= '0';
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME1;
                   GPS_TS_OUT <= GPS_TS_TIME1;
                   CTD_OUT <= CTD_TIME1;
      when others =>
    end case;
  end process;

  -- For a master COINC_TO_END_TIME is 20ns delayed
  -- This is to compensate for the slave to master time (cable, drivers)
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      GPS_TS_TIME1 <= "00000000000000000000000000000000000000000000000000000000";
      CTD_TIME1 <= "00000000000000000000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_FIFO1 = '1' and COINC_TO_FIFO1_DEL1 = '0' then
        GPS_TS_TIME1 <= GPS_TS_IN;
        CTD_TIME1 <= CTD_IN;
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      GPS_TS_TIME2 <= "00000000000000000000000000000000000000000000000000000000";
      CTD_TIME2 <= "00000000000000000000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_FIFO2 = '1' and COINC_TO_FIFO2_DEL1 = '0' then
        GPS_TS_TIME2 <= GPS_TS_IN;
        CTD_TIME2 <= CTD_IN;
      end if;
    end if;
  end process;

  -- Latch TRIGGER_PATTERN on negative edge of COINC_TO_FIFO1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN_TIME1 <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_FIFO1 = '0' and COINC_TO_FIFO1_DEL1 = '1' then
        TRIGGER_PATTERN_TIME1 <= TRIGGER_PATTERN_IN;
      end if;
    end if;
  end process;

  -- Latch TRIGGER_PATTERN on negative edge of COINC_TO_FIFO2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN_TIME2 <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_FIFO2 = '0' and COINC_TO_FIFO2_DEL1 = '1' then
        TRIGGER_PATTERN_TIME2 <= TRIGGER_PATTERN_IN;
      end if;
    end if;
  end process;

end architecture a0 ; -- of FIFO_SELECT

--------------------------------------------------------------------------------
-- Object        : Entity design.EVENT_FIFO_CONTROL
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity EVENT_FIFO_CONTROL is
  port(
    CLKRD            : in     std_logic;
    DATA_READY_CONV  : in     std_logic;
    DOUT_VALID       : out    std_logic;
    EVENT_DATA_READY : out    std_logic;
    FIFO_EMPTY       : out    std_logic;
    RDCLOCK          : out    std_logic;
    RDEN             : in     std_logic;
    RD_ADDRESS       : out    integer range 12020 downto 0;
    SYSRST           : in     std_logic;
    TOTAL_TIME_6X    : in     integer range 12000 downto 0);
end entity EVENT_FIFO_CONTROL;

--------------------------------------------------------------------------------
-- Object        : Architecture design.EVENT_FIFO_CONTROL.a0
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------


architecture a0 of EVENT_FIFO_CONTROL is

signal DATA_READY_CONV_DEL: std_logic;
signal DATA_VALID_TMP: std_logic;
signal DATA_VALID_TMP2: std_logic;
signal EVENT_DATA_READY_TMP: std_logic;
signal EVENT_DATA_READY_TMP2: std_logic;
signal RDEN_TMP: std_logic; -- needed to synchronize read enable
signal RD_ADDRESS_TMP: integer range 12020 downto 0;

begin

  RD_ADDRESS <= RD_ADDRESS_TMP;
  RDCLOCK <= CLKRD;
  DOUT_VALID <= DATA_VALID_TMP2 and EVENT_DATA_READY_TMP2;
  EVENT_DATA_READY <= EVENT_DATA_READY_TMP;
  FIFO_EMPTY <= not EVENT_DATA_READY_TMP;

  -- Delay's
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_READY_CONV_DEL <= '0';
      DATA_VALID_TMP2 <= '0';
      EVENT_DATA_READY_TMP2 <= '0';
      RDEN_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      DATA_READY_CONV_DEL <= DATA_READY_CONV;
      DATA_VALID_TMP2 <= DATA_VALID_TMP;
      EVENT_DATA_READY_TMP2 <= EVENT_DATA_READY_TMP;
      RDEN_TMP <= RDEN;
    end if;
  end process;

  -- EVENT_DATA_READY must be valid if DATA_READY_CONV goes true.
  -- in other words: the USB device gets the signal that there is data in the FIFO to readout.
  -- EVENT_DATA_READY must go low at the end of readout.
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      EVENT_DATA_READY_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      -- on a positive edge of DATA_READY_CONV
      if DATA_READY_CONV = '1' and DATA_READY_CONV_DEL = '0' then
        EVENT_DATA_READY_TMP <= '1';
      elsif RD_ADDRESS_TMP > TOTAL_TIME_6X - 1 then
        EVENT_DATA_READY_TMP <= '0';
      else
        EVENT_DATA_READY_TMP <= EVENT_DATA_READY_TMP;
      end if;
    end if;
  end process;

  -- This signal is true when the data from the FIFO is valid.
  -- DATA_VALID must be valid if DATA_READY_CONV goes true and USB asks for readout.
  -- DATA_VALID must go low at the end of readout.
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_VALID_TMP <= '0';
      RD_ADDRESS_TMP <= 0;
    elsif (CLKRD'event and CLKRD = '1') then
      if EVENT_DATA_READY_TMP = '1' then
        if RDEN_TMP = '1' then
          DATA_VALID_TMP <= '1';
          RD_ADDRESS_TMP <= RD_ADDRESS_TMP + 1;
        else
          DATA_VALID_TMP <= '0';
          RD_ADDRESS_TMP <= RD_ADDRESS_TMP;
        end if;
      else
        RD_ADDRESS_TMP <= 0;
        DATA_VALID_TMP <= '0';
      end if;
    end if;
  end process;

end architecture a0 ; -- of EVENT_FIFO_CONTROL

--------------------------------------------------------------------------------
-- Object        : Entity design.EVENT_FIFO
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity EVENT_FIFO is
  port(
    DATA_IN    : in     std_logic_vector(7 downto 0);
    DATA_OUT   : out    std_logic_vector(7 downto 0);
    RDCLOCK    : in     std_logic;
    RD_ADDRESS : in     integer range 12020 downto 0;
    WE         : in     std_logic;
    WRCLOCK    : in     std_logic;
    WR_ADDRESS : in     integer range 12020 downto 0);
end entity EVENT_FIFO;

--------------------------------------------------------------------------------
-- Object        : Architecture design.EVENT_FIFO.a0
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------


architecture a0 of EVENT_FIFO is

  type MEM is array(0 to 12020) of std_logic_vector(7 downto 0);
  signal RAM_BLOCK : MEM;
  signal RD_ADDRESS_REG : integer range 0 to 12020;

begin

  process (WRCLOCK)
  begin
    if (WRCLOCK'event and WRCLOCK = '1') then
      if (WE = '1') then
        RAM_BLOCK(WR_ADDRESS) <= DATA_IN;
      end if;
    end if;
  end process;

  process (RDCLOCK)
  BEGIN
    if (RDCLOCK'event and RDCLOCK = '1') then
      DATA_OUT <= RAM_BLOCK(RD_ADDRESS_REG);
      RD_ADDRESS_REG <= RD_ADDRESS;
    end if;
  end process;

end architecture a0 ; -- of EVENT_FIFO

--------------------------------------------------------------------------------
-- Object        : Entity design.CONVERSION_12_TO_8_BIT
-- Last modified : Mon Feb 27 11:06:12 2012.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity CONVERSION_12_TO_8_BIT is
  port(
    CLKRD              : in     std_logic;
    CONVERSION_CLK     : in     std_logic;
    CONV_DATA_READY    : out    std_logic;
    CTD_IN             : in     std_logic_vector(31 downto 0);
    CTD_OUT            : out    std_logic_vector(31 downto 0);
    DATA_OUT           : out    std_logic_vector(7 downto 0);
    DATA_OUT_CH1       : in     std_logic_vector(11 downto 0);
    DATA_OUT_CH2       : in     std_logic_vector(11 downto 0);
    DATA_READY_CH1     : in     std_logic;
    DATA_READY_CH2     : in     std_logic;
    DATA_VALID_CH1     : in     std_logic;
    DATA_VALID_CH2     : in     std_logic;
    FIFO_EMPTY         : in     std_logic;
    GPS_TS_IN          : in     std_logic_vector(55 downto 0);
    GPS_TS_OUT         : out    std_logic_vector(55 downto 0);
    RDEN_CH1           : out    std_logic;
    RDEN_CH2           : out    std_logic;
    SYSRST             : in     std_logic;
    TOTAL_TIME_3X      : in     integer range 6000 downto 0;
    TOTAL_TIME_6X      : out    integer range 12000 downto 0;
    TRIGGER_PATTERN    : out    std_logic_vector(15 downto 0);
    TRIGGER_PATTERN_IN : in     std_logic_vector(15 downto 0);
    WE                 : out    std_logic;
    WR_ADDRESS         : out    integer range 12020 downto 0);
end entity CONVERSION_12_TO_8_BIT;

--------------------------------------------------------------------------------
-- Object        : Architecture design.CONVERSION_12_TO_8_BIT.a0
-- Last modified : Mon Feb 27 11:06:12 2012.
--------------------------------------------------------------------------------


architecture a0 of CONVERSION_12_TO_8_BIT is

signal PHASE1: std_logic;
signal PHASE2: std_logic;
signal PHASE: std_logic_vector(1 downto 0);
signal WR_ADDRESS_CNT: integer range 12020 downto 0;
signal DATA_OUT_TMP: std_logic_vector(3 downto 0);
signal WE_TMP: std_logic;
signal WE_DEL: std_logic;
signal FIFO_EMPTY_DEL: std_logic;
signal CHANNEL_SELECT: std_logic;
signal CHANNEL_SELECT_PRE1: std_logic;
signal CHANNEL_SELECT_PRE2: std_logic;
signal RDEN_SELECT: std_logic;
signal DATA_SELECT: std_logic_vector(11 downto 0);
signal WR_ADDRESS_SELECT_BEGIN: integer range 12020 downto 0;
signal WR_ADDRESS_SELECT_END: integer range 12020 downto 0;
signal TOTAL_TIME_6X_TMP: integer range 12000 downto 0;
signal DATA_VALID_SELECT: std_logic;

begin
-- PHASE1 and PHASE2 are made to divide two periods of CLKRD in four parts
-- each part has the lenght of CONVERSION_CLK
  PHASE(0) <= PHASE1;
  PHASE(1) <= PHASE2;

  WR_ADDRESS <= WR_ADDRESS_CNT;
  WE <= WE_TMP;
  TOTAL_TIME_6X <= TOTAL_TIME_6X_TMP;

  process(CLKRD,DATA_VALID_SELECT)
  begin
    if DATA_VALID_SELECT = '0' then
      PHASE1 <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      PHASE1 <= not PHASE1;
    end if;
  end process;

  process(CLKRD,DATA_VALID_SELECT)
  begin
    if DATA_VALID_SELECT = '0' then
      PHASE2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then
      PHASE2 <= PHASE1;
    end if;
  end process;

  process(CONVERSION_CLK,DATA_SELECT,WR_ADDRESS_CNT)
  begin
    if (CONVERSION_CLK'event and CONVERSION_CLK = '1') then
      if DATA_VALID_SELECT = '1' then
        if WR_ADDRESS_CNT < WR_ADDRESS_SELECT_END - 1 then
          case PHASE is
            -- In the first part the most significant 8 data bits from the ADCs
            -- go to the output (input for FIFO) and the other 4 bits to a temporary register
            when "10" => DATA_OUT <= DATA_SELECT(11 downto 4);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT +1;

            -- The write address counter for the FIFO will not change
            -- The counter only increments in the other 3 parts
            when "00" => DATA_OUT <= DATA_SELECT(11 downto 4);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT;

            -- In this part the data from the temporary register (this are the least
            -- significant bits of the former data) go to the most significant bits
            -- of the FIFO data and the least significant bits of the FIFO will be
            -- the most significant bits of the new input data.
            when "01" => DATA_OUT(7 downto 4) <= DATA_OUT_TMP;
                         DATA_OUT(3 downto 0) <= DATA_SELECT(11 downto 8);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT + 1;

            -- In the last part the least significant bits of the new input data
            -- go to the FIFO
            when "11" => DATA_OUT <= DATA_SELECT(7 downto 0);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT + 1;
            when others => DATA_OUT <= DATA_SELECT(11 downto 4);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT;
          end case;
          WE_TMP <= '1';
        else
          WR_ADDRESS_CNT <= WR_ADDRESS_CNT;
          DATA_OUT <= "00000000";
          DATA_OUT_TMP <= "0000";
          WE_TMP <= '0';
        end if;
      else
        WR_ADDRESS_CNT <= WR_ADDRESS_SELECT_BEGIN;
      end if;
    end if;
  end process;

  -- Delays
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WE_DEL <= '0';
      FIFO_EMPTY_DEL <= '1';
    elsif (CLKRD'event and CLKRD = '1') then
      WE_DEL <= WE_TMP;
      FIFO_EMPTY_DEL <= FIFO_EMPTY;
    end if;
  end process;

  -- Read enable must go false at the end of writing the FIFO and true when readout has finished
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      RDEN_SELECT <= '1';
    elsif (CLKRD'event and CLKRD = '1') then
      if WE_TMP = '0' and WE_DEL = '1' and CHANNEL_SELECT = '1' then
        RDEN_SELECT <= '0';
      elsif FIFO_EMPTY = '1' and FIFO_EMPTY_DEL = '0' then
        RDEN_SELECT <= '1';
      end if;
    end if;
  end process;

  -- Data conversion (CONV_DATA_READY) must go true at the end of writing the FIFO and false when readout starts
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      CONV_DATA_READY <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WE_TMP = '0' and WE_DEL = '1' and CHANNEL_SELECT = '1' then
        CONV_DATA_READY <= '1';
      elsif FIFO_EMPTY = '0' and FIFO_EMPTY_DEL = '1' then
        CONV_DATA_READY <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      CHANNEL_SELECT <= '0';
      CHANNEL_SELECT_PRE1 <= '0';
      CHANNEL_SELECT_PRE2 <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      CHANNEL_SELECT_PRE2 <= CHANNEL_SELECT_PRE1;
      CHANNEL_SELECT <= CHANNEL_SELECT_PRE2;
      if WR_ADDRESS_CNT >= TOTAL_TIME_3X - 1 and WR_ADDRESS_CNT < TOTAL_TIME_6X_TMP - 1 then
        CHANNEL_SELECT_PRE1 <= '1';
      else
        CHANNEL_SELECT_PRE1 <= '0';
      end if;
    end if;
  end process;

  -- Read enable select. If CHANNEL_SELECT = channel 1 then RDEN_CH1 has to be selected and RDEN_CH2 has to be zero
  -- If CHANNEL_SELECT = channel 2 then RDEN_CH2 has to be selected and RDEN_CH1 has to be zero
  RDEN_CH1 <= RDEN_SELECT when CHANNEL_SELECT = '0' else '0';
  RDEN_CH2 <= RDEN_SELECT when CHANNEL_SELECT = '1' else '0';

  -- The input data is from channel 1 when CHANNEL_SELECT = 0 or from channel 2 when CHANNEL_SELECT = 1
  DATA_SELECT <= DATA_OUT_CH1 when CHANNEL_SELECT = '0' else DATA_OUT_CH2;

  -- Data valid is from channel 1 when CHANNEL_SELECT = 0 or from channel 2 when CHANNEL_SELECT = 1
  DATA_VALID_SELECT <= DATA_VALID_CH1 when CHANNEL_SELECT = '0' else DATA_VALID_CH2;

  -- FIFO write address has to begin at zero and has to stop at 3 times the total time when doing channel 1
  -- FIFO write address has to begin at 3 times the total time and has to stop at 6 times the total time when doing channel 2
  TOTAL_TIME_6X_TMP <= TOTAL_TIME_3X + TOTAL_TIME_3X;
  WR_ADDRESS_SELECT_BEGIN <= 0 when CHANNEL_SELECT = '0' else TOTAL_TIME_3X;
  WR_ADDRESS_SELECT_END <= TOTAL_TIME_3X when CHANNEL_SELECT = '0' else TOTAL_TIME_6X_TMP;

  -- Take over TRIGGER_PATTERN, GPS_TS and CTD
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN <= "0000000000000000";
      GPS_TS_OUT <= "00000000000000000000000000000000000000000000000000000000";
      CTD_OUT <= "00000000000000000000000000000000";
    elsif (CLKRD'event and CLKRD = '1') then
      if WE_TMP = '0' and WE_DEL = '1' and CHANNEL_SELECT = '1' then
        TRIGGER_PATTERN <= TRIGGER_PATTERN_IN;
        GPS_TS_OUT <= GPS_TS_IN;
        CTD_OUT <= CTD_IN;
      end if;
    end if;
  end process;

end architecture a0 ; -- of CONVERSION_12_TO_8_BIT

--------------------------------------------------------------------------------
-- Object        : Entity design.DataMux
-- Last modified : Fri May 28 14:28:31 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity DataMux is
  port(
    BLOCK_COINC             : out    std_logic;
    CLK10MHz                : in     std_logic;
    CLK200MHz               : in     std_logic;
    CLKRD                   : in     std_logic;
    COINC_TO_END_TIME       : in     std_logic;
    COINC_TO_END_TIME_FIFO1 : out    std_logic;
    COINC_TO_END_TIME_FIFO2 : out    std_logic;
    CTD_IN                  : in     std_logic_vector(31 downto 0);
    CTD_OUT                 : out    std_logic_vector(31 downto 0);
    DATA_OUT                : out    std_logic_vector(7 downto 0);
    DATA_OUT1_CH1           : in     std_logic_vector(11 downto 0);
    DATA_OUT1_CH2           : in     std_logic_vector(11 downto 0);
    DATA_OUT2_CH1           : in     std_logic_vector(11 downto 0);
    DATA_OUT2_CH2           : in     std_logic_vector(11 downto 0);
    DATA_READY1_CH1         : in     std_logic;
    DATA_READY1_CH2         : in     std_logic;
    DATA_READY2_CH1         : in     std_logic;
    DATA_READY2_CH2         : in     std_logic;
    DOUT_VALID              : out    std_logic;
    EVENT_DATA_READY        : out    std_logic;
    GPS_TS_IN               : in     std_logic_vector(55 downto 0);
    GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
    RDEN                    : in     std_logic;
    RDEN1_CH1               : out    std_logic;
    RDEN1_CH2               : out    std_logic;
    RDEN2_CH1               : out    std_logic;
    RDEN2_CH2               : out    std_logic;
    READOUT_BUSY1_CH1       : in     std_logic;
    READOUT_BUSY1_CH2       : in     std_logic;
    READOUT_BUSY2_CH1       : in     std_logic;
    READOUT_BUSY2_CH2       : in     std_logic;
    SYSRST                  : in     std_logic;
    TOTAL_TIME_3X           : in     integer range 6000 downto 0;
    TRIGGER_PATTERN         : out    std_logic_vector(15 downto 0);
    TRIGGER_PATTERN_IN      : in     std_logic_vector(15 downto 0));
end entity DataMux;

--------------------------------------------------------------------------------
-- Object        : Architecture design.DataMux.a0
-- Last modified : Fri May 28 14:28:31 2010.
--------------------------------------------------------------------------------

architecture a0 of DataMux is

  signal Net_0      :  integer range 12020 downto 0;
  signal Net_1      :  std_logic;
  signal Net_2      :  std_logic_vector(7 downto 0);
  signal Net_3      :  std_logic;
  signal Net_4      :  integer range 12000 downto 0;
  signal Net_5      :  std_logic;
  signal Net_6      :  std_logic_vector(11 downto 0);
  signal Net_7      :  std_logic;
  signal Net_8      :  std_logic_vector(11 downto 0);
  signal Net_9      :  std_logic;
  signal Net_10     :  std_logic_vector(15 downto 0);
  signal Net_11     :  std_logic_vector(55 downto 0);
  signal Net_12     :  std_logic_vector(31 downto 0);
  signal Net_13     :  std_logic;
  signal Net_14     :  std_logic;
  signal Net_15     :  std_logic;
  signal Net_16     :  std_logic;
  signal RD_ADDRESS :  integer range 12020 downto 0;
  signal RDCLOCK    :  std_logic;

  component CONVERSION_12_TO_8_BIT
    port(
      CLKRD              : in     std_logic;
      CONVERSION_CLK     : in     std_logic;
      CONV_DATA_READY    : out    std_logic;
      CTD_IN             : in     std_logic_vector(31 downto 0);
      CTD_OUT            : out    std_logic_vector(31 downto 0);
      DATA_OUT           : out    std_logic_vector(7 downto 0);
      DATA_OUT_CH1       : in     std_logic_vector(11 downto 0);
      DATA_OUT_CH2       : in     std_logic_vector(11 downto 0);
      DATA_READY_CH1     : in     std_logic;
      DATA_READY_CH2     : in     std_logic;
      DATA_VALID_CH1     : in     std_logic;
      DATA_VALID_CH2     : in     std_logic;
      FIFO_EMPTY         : in     std_logic;
      GPS_TS_IN          : in     std_logic_vector(55 downto 0);
      GPS_TS_OUT         : out    std_logic_vector(55 downto 0);
      RDEN_CH1           : out    std_logic;
      RDEN_CH2           : out    std_logic;
      SYSRST             : in     std_logic;
      TOTAL_TIME_3X      : in     integer range 6000 downto 0;
      TOTAL_TIME_6X      : out    integer range 12000 downto 0;
      TRIGGER_PATTERN    : out    std_logic_vector(15 downto 0);
      TRIGGER_PATTERN_IN : in     std_logic_vector(15 downto 0);
      WE                 : out    std_logic;
      WR_ADDRESS         : out    integer range 12020 downto 0);
  end component CONVERSION_12_TO_8_BIT;

  component EVENT_FIFO
    port(
      DATA_IN    : in     std_logic_vector(7 downto 0);
      DATA_OUT   : out    std_logic_vector(7 downto 0);
      RDCLOCK    : in     std_logic;
      RD_ADDRESS : in     integer range 12020 downto 0;
      WE         : in     std_logic;
      WRCLOCK    : in     std_logic;
      WR_ADDRESS : in     integer range 12020 downto 0);
  end component EVENT_FIFO;

  component EVENT_FIFO_CONTROL
    port(
      CLKRD            : in     std_logic;
      DATA_READY_CONV  : in     std_logic;
      DOUT_VALID       : out    std_logic;
      EVENT_DATA_READY : out    std_logic;
      FIFO_EMPTY       : out    std_logic;
      RDCLOCK          : out    std_logic;
      RDEN             : in     std_logic;
      RD_ADDRESS       : out    integer range 12020 downto 0;
      SYSRST           : in     std_logic;
      TOTAL_TIME_6X    : in     integer range 12000 downto 0);
  end component EVENT_FIFO_CONTROL;

  component FIFO_SELECT
    port(
      BLOCK_COINC             : out    std_logic;
      CLK200MHz               : in     std_logic;
      CLKRD                   : in     std_logic;
      COINC_TO_END_TIME       : in     std_logic;
      COINC_TO_END_TIME_FIFO1 : out    std_logic;
      COINC_TO_END_TIME_FIFO2 : out    std_logic;
      CTD_IN                  : in     std_logic_vector(31 downto 0);
      CTD_OUT                 : out    std_logic_vector(31 downto 0);
      DATA_OUT1_CH1           : in     std_logic_vector(11 downto 0);
      DATA_OUT1_CH2           : in     std_logic_vector(11 downto 0);
      DATA_OUT2_CH1           : in     std_logic_vector(11 downto 0);
      DATA_OUT2_CH2           : in     std_logic_vector(11 downto 0);
      DATA_OUT_CH1            : out    std_logic_vector(11 downto 0);
      DATA_OUT_CH2            : out    std_logic_vector(11 downto 0);
      DATA_READY1_CH1         : in     std_logic;
      DATA_READY1_CH2         : in     std_logic;
      DATA_READY2_CH1         : in     std_logic;
      DATA_READY2_CH2         : in     std_logic;
      DATA_READY_CH1          : out    std_logic;
      DATA_READY_CH2          : out    std_logic;
      DATA_VALID_CH1          : out    std_logic;
      DATA_VALID_CH2          : out    std_logic;
      GPS_TS_IN               : in     std_logic_vector(55 downto 0);
      GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
      RDEN1_CH1               : out    std_logic;
      RDEN1_CH2               : out    std_logic;
      RDEN2_CH1               : out    std_logic;
      RDEN2_CH2               : out    std_logic;
      RDEN_CH1                : in     std_logic;
      RDEN_CH2                : in     std_logic;
      READOUT_BUSY1_CH1       : in     std_logic;
      READOUT_BUSY1_CH2       : in     std_logic;
      READOUT_BUSY2_CH1       : in     std_logic;
      READOUT_BUSY2_CH2       : in     std_logic;
      SYSRST                  : in     std_logic;
      TRIGGER_PATTERN         : out    std_logic_vector(15 downto 0);
      TRIGGER_PATTERN_IN      : in     std_logic_vector(15 downto 0));
  end component FIFO_SELECT;

begin
  u6: CONVERSION_12_TO_8_BIT
    port map(
      CLKRD              => CLKRD,
      CONVERSION_CLK     => CLK10MHz,
      CONV_DATA_READY    => Net_3,
      CTD_IN             => Net_12,
      CTD_OUT            => CTD_OUT,
      DATA_OUT           => Net_2,
      DATA_OUT_CH1       => Net_6,
      DATA_OUT_CH2       => Net_8,
      DATA_READY_CH1     => Net_13,
      DATA_READY_CH2     => Net_14,
      DATA_VALID_CH1     => Net_16,
      DATA_VALID_CH2     => Net_15,
      FIFO_EMPTY         => Net_5,
      GPS_TS_IN          => Net_11,
      GPS_TS_OUT         => GPS_TS_OUT,
      RDEN_CH1           => Net_7,
      RDEN_CH2           => Net_9,
      SYSRST             => SYSRST,
      TOTAL_TIME_3X      => TOTAL_TIME_3X,
      TOTAL_TIME_6X      => Net_4,
      TRIGGER_PATTERN    => TRIGGER_PATTERN,
      TRIGGER_PATTERN_IN => Net_10,
      WE                 => Net_1,
      WR_ADDRESS         => Net_0);

  u7: EVENT_FIFO
    port map(
      DATA_IN    => Net_2,
      DATA_OUT   => DATA_OUT,
      RDCLOCK    => RDCLOCK,
      RD_ADDRESS => RD_ADDRESS,
      WE         => Net_1,
      WRCLOCK    => CLK10MHz,
      WR_ADDRESS => Net_0);

  u8: EVENT_FIFO_CONTROL
    port map(
      CLKRD            => CLKRD,
      DATA_READY_CONV  => Net_3,
      DOUT_VALID       => DOUT_VALID,
      EVENT_DATA_READY => EVENT_DATA_READY,
      FIFO_EMPTY       => Net_5,
      RDCLOCK          => RDCLOCK,
      RDEN             => RDEN,
      RD_ADDRESS       => RD_ADDRESS,
      SYSRST           => SYSRST,
      TOTAL_TIME_6X    => Net_4);

  u5: FIFO_SELECT
    port map(
      BLOCK_COINC             => BLOCK_COINC,
      CLK200MHz               => CLK200MHz,
      CLKRD                   => CLKRD,
      COINC_TO_END_TIME       => COINC_TO_END_TIME,
      COINC_TO_END_TIME_FIFO1 => COINC_TO_END_TIME_FIFO1,
      COINC_TO_END_TIME_FIFO2 => COINC_TO_END_TIME_FIFO2,
      CTD_IN                  => CTD_IN,
      CTD_OUT                 => Net_12,
      DATA_OUT1_CH1           => DATA_OUT1_CH1,
      DATA_OUT1_CH2           => DATA_OUT1_CH2,
      DATA_OUT2_CH1           => DATA_OUT2_CH1,
      DATA_OUT2_CH2           => DATA_OUT2_CH2,
      DATA_OUT_CH1            => Net_6,
      DATA_OUT_CH2            => Net_8,
      DATA_READY1_CH1         => DATA_READY1_CH1,
      DATA_READY1_CH2         => DATA_READY1_CH2,
      DATA_READY2_CH1         => DATA_READY2_CH1,
      DATA_READY2_CH2         => DATA_READY2_CH2,
      DATA_READY_CH1          => Net_13,
      DATA_READY_CH2          => Net_14,
      DATA_VALID_CH1          => Net_16,
      DATA_VALID_CH2          => Net_15,
      GPS_TS_IN               => GPS_TS_IN,
      GPS_TS_OUT              => Net_11,
      RDEN1_CH1               => RDEN1_CH1,
      RDEN1_CH2               => RDEN1_CH2,
      RDEN2_CH1               => RDEN2_CH1,
      RDEN2_CH2               => RDEN2_CH2,
      RDEN_CH1                => Net_7,
      RDEN_CH2                => Net_9,
      READOUT_BUSY1_CH1       => READOUT_BUSY1_CH1,
      READOUT_BUSY1_CH2       => READOUT_BUSY1_CH2,
      READOUT_BUSY2_CH1       => READOUT_BUSY2_CH1,
      READOUT_BUSY2_CH2       => READOUT_BUSY2_CH2,
      SYSRST                  => SYSRST,
      TRIGGER_PATTERN         => Net_10,
      TRIGGER_PATTERN_IN      => TRIGGER_PATTERN_IN);

end architecture a0 ; -- of DataMux

--------------------------------------------------------------------------------
-- Object        : Entity design.LED_ONE_SHOT
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity LED_ONE_SHOT is
  port(
    CLK10MHz : in     std_logic;
    INP      : in     std_logic;
    OUTP     : out    std_logic;
    STARTUP  : in     std_logic;
    SYSRST   : in     std_logic);
end entity LED_ONE_SHOT;

--------------------------------------------------------------------------------
-- Object        : Architecture design.LED_ONE_SHOT.a0
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------


architecture a0 of LED_ONE_SHOT is

signal LEDSHINE_COUNTER: std_logic_vector(20 downto 0); -- Full is about 0.2 seconds
signal LED_ON: std_logic;

begin

  process(CLK10MHz, SYSRST, INP)
  begin
    if (SYSRST = '1' or INP = '1') then
      LEDSHINE_COUNTER <= "000000000000000000000";
      LED_ON <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (LEDSHINE_COUNTER /= "111111111111111111111") then
        LEDSHINE_COUNTER <= LEDSHINE_COUNTER + "000000000000000000001";
        LED_ON <= '1';
      else
        LEDSHINE_COUNTER <= LEDSHINE_COUNTER; -- locks at full
        LED_ON <= '0';
      end if;
    end if;
  end process;

  OUTP <= LED_ON and not STARTUP;

end architecture a0 ; -- of LED_ONE_SHOT

--------------------------------------------------------------------------------
-- Object        : Entity design.INVERTER
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity INVERTER is
  port(
    INP  : in     std_logic;
    OUTP : out    std_logic);
end entity INVERTER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.INVERTER.a0
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------


architecture a0 of INVERTER is

begin

  OUTP <= not INP;

end architecture a0 ; -- of INVERTER

--------------------------------------------------------------------------------
-- Object        : Entity design.LED_DRIVER
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity LED_DRIVER is
  port(
    CLK10MHz : in     std_logic;
    INP      : in     std_logic;
    OUTP     : out    std_logic;
    SYSRST   : in     std_logic);
end entity LED_DRIVER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.LED_DRIVER.a0
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------


architecture a0 of LED_DRIVER is

signal LEDSHINE_COUNTER: std_logic_vector(20 downto 0); -- Full is about 0.2 seconds

begin

  process(CLK10MHz, SYSRST, INP)
  begin
    if (SYSRST = '1' or INP = '1') then
      LEDSHINE_COUNTER <= "000000000000000000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (LEDSHINE_COUNTER /= "111111111111111111111") then
        LEDSHINE_COUNTER <= LEDSHINE_COUNTER + "000000000000000000001";
      else
        LEDSHINE_COUNTER <= LEDSHINE_COUNTER; -- locks at full
      end if;
    end if;
  end process;

  OUTP <= '1' when (LEDSHINE_COUNTER /= "111111111111111111111") else '0';

end architecture a0 ; -- of LED_DRIVER

--------------------------------------------------------------------------------
-- Object        : Entity design.LEDS
-- Last modified : Wed Jun 02 21:29:24 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity LEDS is
  port(
    BLOCK_COINC   : in     std_logic;
    CLK10MHz      : in     std_logic;
    COINC         : in     std_logic;
    COINC_LED     : out    std_logic;
    HIT1          : in     std_logic;
    HIT2          : in     std_logic;
    LED0          : out    std_logic;
    LED1          : out    std_logic;
    LED2          : out    std_logic;
    LED3          : out    std_logic;
    LED4          : out    std_logic;
    LEDH1         : out    std_logic;
    LEDH2         : out    std_logic;
    MASTER        : in     std_logic;
    ONE_PPS       : in     std_logic;
    SLAVE_PRESENT : in     std_logic;
    STARTUP       : in     std_logic;
    SYSRST        : in     std_logic;
    USB_RD        : in     std_logic);
end entity LEDS;

--------------------------------------------------------------------------------
-- Object        : Architecture design.LEDS.a0
-- Last modified : Wed Jun 02 21:29:24 2010.
--------------------------------------------------------------------------------

architecture a0 of LEDS is

  signal Net_3 :  std_logic;

  component LED_DRIVER
    port(
      CLK10MHz : in     std_logic;
      INP      : in     std_logic;
      OUTP     : out    std_logic;
      SYSRST   : in     std_logic);
  end component LED_DRIVER;

  component INVERTER
    port(
      INP  : in     std_logic;
      OUTP : out    std_logic);
  end component INVERTER;

  component LED_ONE_SHOT
    port(
      CLK10MHz : in     std_logic;
      INP      : in     std_logic;
      OUTP     : out    std_logic;
      STARTUP  : in     std_logic;
      SYSRST   : in     std_logic);
  end component LED_ONE_SHOT;

begin
  u29: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP      => Net_3,
      OUTP     => LED4,
      SYSRST   => SYSRST);

  u32: INVERTER
    port map(
      INP  => USB_RD,
      OUTP => Net_3);

  u4: LED_ONE_SHOT
    port map(
      CLK10MHz => CLK10MHz,
      INP      => COINC,
      OUTP     => COINC_LED,
      STARTUP  => STARTUP,
      SYSRST   => SYSRST);

  u23: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP      => ONE_PPS,
      OUTP     => LED2,
      SYSRST   => SYSRST);

  u3: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP      => BLOCK_COINC,
      OUTP     => LED3,
      SYSRST   => SYSRST);

  u2: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP      => HIT1,
      OUTP     => LEDH1,
      SYSRST   => SYSRST);

  u1: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP      => HIT2,
      OUTP     => LEDH2,
      SYSRST   => SYSRST);

  u5: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP      => MASTER,
      OUTP     => LED0,
      SYSRST   => SYSRST);

  u6: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP      => SLAVE_PRESENT,
      OUTP     => LED1,
      SYSRST   => SYSRST);

end architecture a0 ; -- of LEDS

--------------------------------------------------------------------------------
-- Object        : Entity design.RD_ADDRES_COUNTER
-- Last modified : Thu Nov 18 14:03:36 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity RD_ADDRES_COUNTER is
  port(
    BEGIN_PRE_TIME    : in     integer range 2040 downto 0;
    CLK200MHz         : in     std_logic;
    CLKRD             : in     std_logic;
    COINC_TO_END_TIME : in     std_logic;
    DATA_OUT          : out    std_logic_vector(11 downto 0);
    DATA_OUT_NEG      : in     std_logic_vector(11 downto 0);
    DATA_OUT_POS      : in     std_logic_vector(11 downto 0);
    DATA_READY        : out    std_logic;
    RDEN              : in     std_logic;
    RD_ADDRESS        : out    integer range 2040 downto 0;
    READOUT_BUSY      : out    std_logic;
    SYSRST            : in     std_logic);
end entity RD_ADDRES_COUNTER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.RD_ADDRES_COUNTER.a0
-- Last modified : Thu Nov 18 14:03:36 2010.
--------------------------------------------------------------------------------


architecture a0 of RD_ADDRES_COUNTER is

signal TAKE_DATA: std_logic ; -- RAMs are in write mode when true
signal RD_ADDRESS_TMP: integer range 2040 downto 0 ;
signal POS_NEG_PHASE: std_logic ; -- help signal to determine the positive or negative RAM; high means positive
signal READOUT_BUSY_TMP: std_logic ;
signal DATA_READY_PRE: std_logic ;
signal DATA_OUT_TMP: std_logic_vector(11 downto 0);
signal COINC_TO_END_TIME_DEL: std_logic ;
signal RDEN_DEL1: std_logic ;
signal RDEN_DEL2: std_logic ;

begin

  RD_ADDRESS <= RD_ADDRESS_TMP;

  -- delays
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_DEL <= '0';
      RDEN_DEL1 <= '0';
      RDEN_DEL2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COINC_TO_END_TIME_DEL <= COINC_TO_END_TIME;
      RDEN_DEL1 <= RDEN;
      RDEN_DEL2 <= RDEN_DEL1;
    end if;
  end process;

  -- Data taking TAKE_DATA stops at end of COINC_TO_END_TIME and starts again after the FIFO has been readout
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TAKE_DATA <= '1';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME = '0' and COINC_TO_END_TIME_DEL = '1' then -- on a negative edge of COINC_TO_END_TIME
        TAKE_DATA <= '0';
      elsif RDEN_DEL1 = '0' and RDEN_DEL2 = '1' then -- on a negative edge of RDEN
        TAKE_DATA <= '1';
      end if;
    end if;
  end process;

  -- DATA_READY is valid when the FIFOs are not taking data
  -- not TAKE_DATA is synchronized with the readoutclock
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_READY_PRE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      DATA_READY_PRE <= not TAKE_DATA;
      DATA_READY <= DATA_READY_PRE;
      READOUT_BUSY <= READOUT_BUSY_TMP;
    end if;
  end process;

  -- RD_ADDRESS and toggle outputbus
  process(CLKRD)
  begin
    if (CLKRD'event and CLKRD = '1') then
      if RDEN = '1' then
        if POS_NEG_PHASE = '1' then
          RD_ADDRESS_TMP <= RD_ADDRESS_TMP;
        else
          if RD_ADDRESS_TMP = 2040 then
            RD_ADDRESS_TMP <= 0;
          else
            RD_ADDRESS_TMP <= RD_ADDRESS_TMP + 1;
          end if;
        end if;
        POS_NEG_PHASE <= not POS_NEG_PHASE;
        READOUT_BUSY_TMP <= '1';
      else
        RD_ADDRESS_TMP <= BEGIN_PRE_TIME;
        POS_NEG_PHASE <= '1';
        READOUT_BUSY_TMP <= '0';
      end if;
    end if;
  end process;

  DATA_OUT_TMP <= DATA_OUT_POS  when POS_NEG_PHASE = '1' else DATA_OUT_NEG;
  DATA_OUT <= DATA_OUT_TMP when READOUT_BUSY_TMP = '1' else "000000000000";

end architecture a0 ; -- of RD_ADDRES_COUNTER

--------------------------------------------------------------------------------
-- Object        : Entity design.WR_ADDRES_COUNTER
-- Last modified : Thu Nov 18 14:03:36 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity WR_ADDRES_COUNTER is
  port(
    BEGIN_PRE_TIME_OUT : out    integer range 2040 downto 0;
    CLK200MHz          : in     std_logic;
    COINC_TO_END_TIME  : in     std_logic;
    MASTER             : in     std_logic;
    RDEN_CH1           : in     std_logic;
    RDEN_CH2           : in     std_logic;
    SYSRST             : in     std_logic;
    TOTAL_TIME         : in     integer range 2000 downto 0;
    WE                 : out    std_logic;
    WR_ADDRESS         : out    integer range 2040 downto 0);
end entity WR_ADDRES_COUNTER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.WR_ADDRES_COUNTER.a0
-- Last modified : Thu Nov 18 14:03:36 2010.
--------------------------------------------------------------------------------


architecture a0 of WR_ADDRES_COUNTER is

signal TAKE_DATA: std_logic ; -- RAMs are in write mode when true
signal BEGIN_PRE_TIME: integer range 2040 downto 0 ; -- write address at begin of PRE_TIME
signal BEGIN_PRE_TIME_MASTER: integer range 2040 downto 0 ;
signal BEGIN_PRE_TIME_SLAVE : integer range 2040 downto 0 ;
signal END_POST_TIME : integer range 2040 downto 0; -- write address at end of POST_TIME
signal WR_ADDRESS_TMP: integer range 2040 downto 0;
signal COINC_TO_END_TIME_DEL: std_logic ;
signal RDEN_DEL1: std_logic ;
signal RDEN_DEL2: std_logic ;

begin

  --Distract BEGIN_PRE_TIME with 10 (50ns) to adjust COINC with the stored event in the FIFO
  --BEGIN_PRE_TIME_MASTER <= END_POST_TIME - TOTAL_TIME - 10 when (END_POST_TIME >= TOTAL_TIME + 10) else (2011 - TOTAL_TIME + END_POST_TIME);
  --BEGIN_PRE_TIME_SLAVE  <= END_POST_TIME - TOTAL_TIME - 12 when (END_POST_TIME >= TOTAL_TIME + 12) else (2009 - TOTAL_TIME + END_POST_TIME);
  --BEGIN_PRE_TIME_MASTER <= END_POST_TIME - TOTAL_TIME - 16 when (END_POST_TIME >= TOTAL_TIME + 16) else (2005 - TOTAL_TIME + END_POST_TIME);
  --BEGIN_PRE_TIME_SLAVE  <= END_POST_TIME - TOTAL_TIME - 18 when (END_POST_TIME >= TOTAL_TIME + 18) else (2003 - TOTAL_TIME + END_POST_TIME);
  --BEGIN_PRE_TIME <= END_POST_TIME - TOTAL_TIME when (END_POST_TIME >= TOTAL_TIME) else (2021 - TOTAL_TIME + END_POST_TIME);

  -- BEGIN_PRE_TIME_MASTER has to start 22 x 5ns sooner, to compensate delay hit master to coincidence matrix.
  BEGIN_PRE_TIME_MASTER <= END_POST_TIME - TOTAL_TIME - 22 when (END_POST_TIME >= TOTAL_TIME + 22) else (2019 - TOTAL_TIME + END_POST_TIME);

  -- BEGIN_PRE_TIME_SLAVE has to start 24 x 5ns sooner, to compensate delay hit slave to coincidence matrix.
  BEGIN_PRE_TIME_SLAVE  <= END_POST_TIME - TOTAL_TIME - 24 when (END_POST_TIME >= TOTAL_TIME + 24) else (2017 - TOTAL_TIME + END_POST_TIME);

  BEGIN_PRE_TIME <= BEGIN_PRE_TIME_MASTER when MASTER = '1' else BEGIN_PRE_TIME_SLAVE;

  WR_ADDRESS <= WR_ADDRESS_TMP;
  BEGIN_PRE_TIME_OUT <= BEGIN_PRE_TIME;

  -- delays
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_DEL <= '0';
      RDEN_DEL1 <= '0';
      RDEN_DEL2 <= '0';
      WE <= '1';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COINC_TO_END_TIME_DEL <= COINC_TO_END_TIME;
      RDEN_DEL1 <= RDEN_CH1;
      RDEN_DEL2 <= RDEN_DEL1;
      WE <= TAKE_DATA and not RDEN_CH1 and not RDEN_CH2;
    end if;
  end process;

  -- Data taking TAKE_DATA stops at end of COINC_TO_END_TIME and starts again after the FIFO has been readout
  -- and determine END_POST_TIME
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TAKE_DATA <= '1';
      END_POST_TIME <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME = '0' and COINC_TO_END_TIME_DEL = '1' then -- on a negative edge of COINC_TO_END_TIME
        TAKE_DATA <= '0';
        END_POST_TIME <= WR_ADDRESS_TMP;
      elsif RDEN_DEL1 = '0' and RDEN_DEL2 = '1' then -- on a negative edge of RDEN_CH1
        TAKE_DATA <= '1';
      end if;
    end if;
  end process;

  -- WR_ADDRESS_TMP
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_ADDRESS_TMP <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if TAKE_DATA = '1' then
        if WR_ADDRESS_TMP = 2040 then
          WR_ADDRESS_TMP <= 0;
        else
          WR_ADDRESS_TMP <= WR_ADDRESS_TMP + 1;
        end if;
      else
        WR_ADDRESS_TMP <= WR_ADDRESS_TMP;
      end if;
    end if;
  end process;

end architecture a0 ; -- of WR_ADDRES_COUNTER

--------------------------------------------------------------------------------
-- Object        : Entity design.DUAL_PORT_RAM
-- Last modified : Thu Nov 18 14:03:36 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity DUAL_PORT_RAM is
  port(
    DATA_IN    : in     std_logic_vector(11 downto 0);
    DATA_OUT   : out    std_logic_vector(11 downto 0);
    RDCLOCK    : in     std_logic;
    RD_ADDRESS : in     integer range 2040 downto 0;
    WE         : in     std_logic;
    WRCLOCK    : in     std_logic;
    WR_ADDRESS : in     integer range 2040 downto 0);
end entity DUAL_PORT_RAM;

--------------------------------------------------------------------------------
-- Object        : Architecture design.DUAL_PORT_RAM.a0
-- Last modified : Thu Nov 18 14:03:36 2010.
--------------------------------------------------------------------------------


architecture a0 of DUAL_PORT_RAM is

  type MEM is array(0 to 2040) of std_logic_vector(11 downto 0);
  signal RAM_BLOCK : MEM;
  signal RD_ADDRESS_REG : integer range 0 to 2040;

begin

  process (WRCLOCK)
  begin
    if (WRCLOCK'event and WRCLOCK = '1') then
      if (WE = '1') then
        RAM_BLOCK(WR_ADDRESS) <= DATA_IN;
      end if;
    end if;
  end process;

  process (RDCLOCK)
  BEGIN
    if (RDCLOCK'event and RDCLOCK = '1') then
      DATA_OUT <= RAM_BLOCK(RD_ADDRESS_REG);
      RD_ADDRESS_REG <= RD_ADDRESS;
    end if;
  end process;

end architecture a0 ; -- of DUAL_PORT_RAM

--------------------------------------------------------------------------------
-- Object        : Entity design.STORAGE_CHANNELS
-- Last modified : Thu Nov 18 13:50:07 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity STORAGE_CHANNELS is
  port(
    CLK200MHz               : in     std_logic;
    CLKRD                   : in     std_logic;
    COINC_TO_END_TIME_FIFO1 : in     std_logic;
    COINC_TO_END_TIME_FIFO2 : in     std_logic;
    DATA_ADC_NEG_CH1        : in     std_logic_vector(11 downto 0);
    DATA_ADC_NEG_CH2        : in     std_logic_vector(11 downto 0);
    DATA_ADC_POS_CH1        : in     std_logic_vector(11 downto 0);
    DATA_ADC_POS_CH2        : in     std_logic_vector(11 downto 0);
    DATA_OUT1_CH1           : out    std_logic_vector(11 downto 0);
    DATA_OUT1_CH2           : out    std_logic_vector(11 downto 0);
    DATA_OUT2_CH1           : out    std_logic_vector(11 downto 0);
    DATA_OUT2_CH2           : out    std_logic_vector(11 downto 0);
    DATA_READY1_CH1         : out    std_logic;
    DATA_READY1_CH2         : out    std_logic;
    DATA_READY2_CH1         : out    std_logic;
    DATA_READY2_CH2         : out    std_logic;
    MASTER                  : in     std_logic;
    RDEN1_CH1               : in     std_logic;
    RDEN1_CH2               : in     std_logic;
    RDEN2_CH1               : in     std_logic;
    RDEN2_CH2               : in     std_logic;
    READOUT_BUSY1_CH1       : out    std_logic;
    READOUT_BUSY1_CH2       : out    std_logic;
    READOUT_BUSY2_CH1       : out    std_logic;
    READOUT_BUSY2_CH2       : out    std_logic;
    SYSRST                  : in     std_logic;
    TOTAL_TIME              : in     integer range 2000 downto 0;
    WE                      : out    std_logic);
end entity STORAGE_CHANNELS;

--------------------------------------------------------------------------------
-- Object        : Architecture design.STORAGE_CHANNELS.a0
-- Last modified : Thu Nov 18 13:50:07 2010.
--------------------------------------------------------------------------------

architecture a0 of STORAGE_CHANNELS is

  signal WR_ADDRESS          :  integer range 2040 downto 0;
  signal WE_net              :  std_logic;
  signal RD_ADDRESS          :  integer range 2040 downto 0;
  signal DATA_OUT3           :  std_logic_vector(11 downto 0);
  signal DATA_OUT            :  std_logic_vector(11 downto 0);
  signal RD_ADDRESS1         :  integer range 2040 downto 0;
  signal DATA_OUT1           :  std_logic_vector(11 downto 0);
  signal DATA_OUT2           :  std_logic_vector(11 downto 0);
  signal WR_ADDRESS0         :  integer range 2040 downto 0;
  signal WE0                 :  std_logic;
  signal RD_ADDRESS0         :  integer range 2040 downto 0;
  signal DATA_OUT0           :  std_logic_vector(11 downto 0);
  signal Net_6               :  integer range 2040 downto 0;
  signal Net_7               :  std_logic_vector(11 downto 0);
  signal Net_8               :  std_logic_vector(11 downto 0);
  signal BEGIN_PRE_TIME_OUT  :  integer range 2040 downto 0;
  signal BEGIN_PRE_TIME_OUT0 :  integer range 2040 downto 0;
  signal DATA_OUT4           :  std_logic_vector(11 downto 0);

  component DUAL_PORT_RAM
    port(
      DATA_IN    : in     std_logic_vector(11 downto 0);
      DATA_OUT   : out    std_logic_vector(11 downto 0);
      RDCLOCK    : in     std_logic;
      RD_ADDRESS : in     integer range 2040 downto 0;
      WE         : in     std_logic;
      WRCLOCK    : in     std_logic;
      WR_ADDRESS : in     integer range 2040 downto 0);
  end component DUAL_PORT_RAM;

  component WR_ADDRES_COUNTER
    port(
      BEGIN_PRE_TIME_OUT : out    integer range 2040 downto 0;
      CLK200MHz          : in     std_logic;
      COINC_TO_END_TIME  : in     std_logic;
      MASTER             : in     std_logic;
      RDEN_CH1           : in     std_logic;
      RDEN_CH2           : in     std_logic;
      SYSRST             : in     std_logic;
      TOTAL_TIME         : in     integer range 2000 downto 0;
      WE                 : out    std_logic;
      WR_ADDRESS         : out    integer range 2040 downto 0);
  end component WR_ADDRES_COUNTER;

  component RD_ADDRES_COUNTER
    port(
      BEGIN_PRE_TIME    : in     integer range 2040 downto 0;
      CLK200MHz         : in     std_logic;
      CLKRD             : in     std_logic;
      COINC_TO_END_TIME : in     std_logic;
      DATA_OUT          : out    std_logic_vector(11 downto 0);
      DATA_OUT_NEG      : in     std_logic_vector(11 downto 0);
      DATA_OUT_POS      : in     std_logic_vector(11 downto 0);
      DATA_READY        : out    std_logic;
      RDEN              : in     std_logic;
      RD_ADDRESS        : out    integer range 2040 downto 0;
      READOUT_BUSY      : out    std_logic;
      SYSRST            : in     std_logic);
  end component RD_ADDRES_COUNTER;

begin
  WE <= WE_net;
  u1: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_POS_CH1,
      DATA_OUT   => DATA_OUT3,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => RD_ADDRESS,
      WE         => WE_net,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS);

  u2: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_NEG_CH1,
      DATA_OUT   => DATA_OUT,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => RD_ADDRESS,
      WE         => WE_net,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS);

  u4: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_POS_CH2,
      DATA_OUT   => DATA_OUT1,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => RD_ADDRESS1,
      WE         => WE_net,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS);

  u5: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_NEG_CH2,
      DATA_OUT   => DATA_OUT2,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => RD_ADDRESS1,
      WE         => WE_net,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS);

  u12: WR_ADDRES_COUNTER
    port map(
      BEGIN_PRE_TIME_OUT => BEGIN_PRE_TIME_OUT,
      CLK200MHz          => CLK200MHz,
      COINC_TO_END_TIME  => COINC_TO_END_TIME_FIFO1,
      MASTER             => MASTER,
      RDEN_CH1           => RDEN1_CH1,
      RDEN_CH2           => RDEN1_CH2,
      SYSRST             => SYSRST,
      TOTAL_TIME         => TOTAL_TIME,
      WE                 => WE_net,
      WR_ADDRESS         => WR_ADDRESS);

  u13: RD_ADDRES_COUNTER
    port map(
      BEGIN_PRE_TIME    => BEGIN_PRE_TIME_OUT,
      CLK200MHz         => CLK200MHz,
      CLKRD             => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME_FIFO1,
      DATA_OUT          => DATA_OUT1_CH2,
      DATA_OUT_NEG      => DATA_OUT2,
      DATA_OUT_POS      => DATA_OUT1,
      DATA_READY        => DATA_READY1_CH2,
      RDEN              => RDEN1_CH2,
      RD_ADDRESS        => RD_ADDRESS1,
      READOUT_BUSY      => READOUT_BUSY1_CH2,
      SYSRST            => SYSRST);

  u3: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_POS_CH1,
      DATA_OUT   => DATA_OUT4,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => RD_ADDRESS0,
      WE         => WE0,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS0);

  u6: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_NEG_CH1,
      DATA_OUT   => DATA_OUT0,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => RD_ADDRESS0,
      WE         => WE0,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS0);

  u7: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_POS_CH2,
      DATA_OUT   => Net_7,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => Net_6,
      WE         => WE0,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS0);

  u8: DUAL_PORT_RAM
    port map(
      DATA_IN    => DATA_ADC_NEG_CH2,
      DATA_OUT   => Net_8,
      RDCLOCK    => CLKRD,
      RD_ADDRESS => Net_6,
      WE         => WE0,
      WRCLOCK    => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS0);

  u15: RD_ADDRES_COUNTER
    port map(
      BEGIN_PRE_TIME    => BEGIN_PRE_TIME_OUT0,
      CLK200MHz         => CLK200MHz,
      CLKRD             => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME_FIFO2,
      DATA_OUT          => DATA_OUT2_CH2,
      DATA_OUT_NEG      => Net_8,
      DATA_OUT_POS      => Net_7,
      DATA_READY        => DATA_READY2_CH2,
      RDEN              => RDEN2_CH2,
      RD_ADDRESS        => Net_6,
      READOUT_BUSY      => READOUT_BUSY2_CH2,
      SYSRST            => SYSRST);

  u16: RD_ADDRES_COUNTER
    port map(
      BEGIN_PRE_TIME    => BEGIN_PRE_TIME_OUT,
      CLK200MHz         => CLK200MHz,
      CLKRD             => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME_FIFO1,
      DATA_OUT          => DATA_OUT1_CH1,
      DATA_OUT_NEG      => DATA_OUT,
      DATA_OUT_POS      => DATA_OUT3,
      DATA_READY        => DATA_READY1_CH1,
      RDEN              => RDEN1_CH1,
      RD_ADDRESS        => RD_ADDRESS,
      READOUT_BUSY      => READOUT_BUSY1_CH1,
      SYSRST            => SYSRST);

  u17: WR_ADDRES_COUNTER
    port map(
      BEGIN_PRE_TIME_OUT => BEGIN_PRE_TIME_OUT0,
      CLK200MHz          => CLK200MHz,
      COINC_TO_END_TIME  => COINC_TO_END_TIME_FIFO2,
      MASTER             => MASTER,
      RDEN_CH1           => RDEN2_CH1,
      RDEN_CH2           => RDEN2_CH2,
      SYSRST             => SYSRST,
      TOTAL_TIME         => TOTAL_TIME,
      WE                 => WE0,
      WR_ADDRESS         => WR_ADDRESS0);

  u18: RD_ADDRES_COUNTER
    port map(
      BEGIN_PRE_TIME    => BEGIN_PRE_TIME_OUT0,
      CLK200MHz         => CLK200MHz,
      CLKRD             => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME_FIFO2,
      DATA_OUT          => DATA_OUT2_CH1,
      DATA_OUT_NEG      => DATA_OUT0,
      DATA_OUT_POS      => DATA_OUT4,
      DATA_READY        => DATA_READY2_CH1,
      RDEN              => RDEN2_CH1,
      RD_ADDRESS        => RD_ADDRESS0,
      READOUT_BUSY      => READOUT_BUSY2_CH1,
      SYSRST            => SYSRST);

end architecture a0 ; -- of STORAGE_CHANNELS

--------------------------------------------------------------------------------
-- Object        : Entity design.SOFT_RESET
-- Last modified : Thu Jan 13 14:40:30 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity SOFT_RESET is
  port(
    CLKRD   : in     std_logic;
    RESOUT  : out    std_logic;
    SRESET  : in     std_logic;
    TORESET : in     std_logic;
    nHRESET : in     std_logic);
end entity SOFT_RESET;

--------------------------------------------------------------------------------
-- Object        : Architecture design.SOFT_RESET.a0
-- Last modified : Thu Jan 13 14:40:30 2011.
--------------------------------------------------------------------------------


architecture a0 of SOFT_RESET is

signal SRESET_COUNT: std_logic_vector(3 downto 0);

begin

  RESOUT <= not SRESET_COUNT(3) or not nHRESET;

  process (CLKRD, nHRESET)
  begin
    if nHRESET = '0' then
      SRESET_COUNT <= (others => '1');
    elsif CLKRD'event and CLKRD = '1' then
      if SRESET = '1' or TORESET = '1' then
        SRESET_COUNT <= (others => '0');
      elsif SRESET_COUNT /= "1111" then
        SRESET_COUNT <= SRESET_COUNT + "0001";
      else
        SRESET_COUNT <= SRESET_COUNT;
      end if;
    end if;
  end process;

end architecture a0 ; -- of SOFT_RESET

--------------------------------------------------------------------------------
-- Object        : Entity design.DUMMIES
-- Last modified : Fri Jan 21 11:37:12 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity DUMMIES is
  port(
    INTF1_IO   : out    std_logic_vector(2 downto 0);
    INTF2_IO   : in     std_logic_vector(7 downto 0);
    LED4       : out    std_logic;
    LED5       : out    std_logic;
    LED6       : out    std_logic;
    LED7       : out    std_logic;
    USB_nPWREN : in     std_logic);
end entity DUMMIES;

--------------------------------------------------------------------------------
-- Object        : Architecture design.DUMMIES.a0
-- Last modified : Fri Jan 21 11:37:12 2011.
--------------------------------------------------------------------------------



architecture a0 of DUMMIES is

begin

  INTF1_IO(0) <= '0';
  INTF1_IO(1) <= '0';
  INTF1_IO(2) <= '0';

-- LED1 is used for SLAVE_PRESENT
-- LED2 is used for MASTER (GPS PRESENT)
-- LED3 is used for COINC
  LED4 <= '0';
  LED5 <= '0';
  LED6 <= '0';
  LED7 <= '0';

end architecture a0 ; -- of DUMMIES

--------------------------------------------------------------------------------
-- Object        : Entity design.GPS_STUFF
-- Last modified : Mon Feb 27 11:41:03 2012.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity GPS_STUFF is
  port(
    ALTITUDE_OUT            : out    std_logic_vector(63 downto 0);
    CLK10MHz                : in     std_logic;
    CLK200MHz               : in     std_logic;
    COINC                   : in     std_logic;
    COMPDATA_OUT            : out    std_logic_vector(127 downto 0);
    COMPDATA_READOUT_DONE   : in     std_logic;
    COMPDATA_VALID_OUT      : out    std_logic;
    COMPH1_IN               : in     std_logic;
    COMPH2_IN               : in     std_logic;
    COMPL1_IN               : in     std_logic;
    COMPL2_IN               : in     std_logic;
    CTD_OUT                 : out    std_logic_vector(31 downto 0);
    CTD_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
    CTP_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
    GPS_FLAGS               : out    std_logic_vector(7 downto 0);
    GPS_PROG_ENABLE         : in     std_logic;
    GPS_SDI                 : out    std_logic;
    GPS_SDO                 : in     std_logic;
    GPS_TS_ONE_PPS_OUT      : out    std_logic_vector(55 downto 0);
    GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
    LATITUDE_OUT            : out    std_logic_vector(63 downto 0);
    LONGITUDE_OUT           : out    std_logic_vector(63 downto 0);
    MASTER                  : out    std_logic;
    ONE_PPS                 : in     std_logic;
    RXD                     : in     std_logic;
    SAT_INFO_OUT            : out    std_logic_vector(487 downto 0);
    SPY_CON                 : in     std_logic;
    SPY_SDI                 : out    std_logic;
    SPY_SDO                 : in     std_logic;
    STARTUP_BLOCK           : in     std_logic;
    SYSRST                  : in     std_logic;
    TEMP_OUT                : out    std_logic_vector(31 downto 0);
    TS_ONE_PPS_READOUT_DONE : in     std_logic;
    TS_ONE_PPS_VALID_OUT    : out    std_logic);
end entity GPS_STUFF;

--------------------------------------------------------------------------------
-- Object        : Architecture design.GPS_STUFF.a0
-- Last modified : Mon Feb 27 11:41:03 2012.
--------------------------------------------------------------------------------


architecture a0 of GPS_STUFF is

signal COUNTER_153600 : std_logic_vector (6 downto 0); -- Counter at 153600Hz; Sample counter
signal CLK_153600 : std_logic;

signal COUNTER_ONE_SEC_SEVEN : std_logic_vector (18 downto 0); -- Counter at 1.7 seconds; Time out counter for RXD; used for GPS master detection
signal COUNTER_ONE_SEC_SEVEN_DEL : std_logic; -- Delayed COUNTER_ONE_SEC_SEVEN(18) bit
signal RXD_TIME_OUT : std_logic_vector (1 downto 0); -- Time out counter for RXD; Counts 3 counts of COUNTER_ONE_SEC_SEVEN
signal GPS_SDO_DEL : std_logic;

signal SAMPLE_COUNT : integer range 168 downto 0; -- Counter which samples the incomming serial data
signal TIME_OUT_COUNT : integer range 1760 downto 0; --10 bytes (16 times oversampling; 11 bits per byte (8xdata + parity, start and stop))
signal TIME_OUT : std_logic; -- Reset when there is 10 bytes long no data
signal RST_MESSAGE : std_logic; -- This is a OR of TIME_OUT and when there is an END byte detected in one of the three messages (END_BYTE_DETECTED)
signal DECODER_BYTE_COUNT : integer range 99 downto 0; -- Counts valid (not stuffed) number of bytes in the serial data stream
signal GET_BYTE : std_logic_vector (7 downto 0); -- This byte stores the serial bits
signal MESSAGE_BYTE1 : std_logic_vector (7 downto 0); -- This byte stores the first GET_BYTE
signal MESSAGE_BYTE2 : std_logic_vector (7 downto 0); -- This byte stores the second GET_BYTE
signal MESSAGE_BYTE3 : std_logic_vector (7 downto 0); -- This byte stores the third GET_BYTE
signal DECODE_BYTE1 : std_logic_vector (7 downto 0); -- This byte stores a GET_BYTE in the message
signal MESSAGE_SELECT : std_logic_vector (1 downto 0); -- "00" means nothing selected; "01" means 8F-AB selected; "10" means 8F-AC selected; "11" means 47 selected;
signal STUFFED_BYTE : std_logic; -- This bit is thrue when there is a stuffed byte; in other words: an even number of 0x10 bytes
signal END_BYTE_DETECTED : std_logic; -- This bit is thrue when a odd number of 0x10 bytes and a 0x03 byte is detected
signal GPS_SEC  : std_logic_vector (7 downto 0); -- Seconds (0 to 59)
signal GPS_MIN   : std_logic_vector (7 downto 0); -- Minutes (0 to 59)
signal GPS_HOUR   : std_logic_vector (7 downto 0); -- Hours (0 to 23)
signal GPS_DAY   : std_logic_vector (7 downto 0); -- Day (1 to 31)
signal GPS_MONTH   : std_logic_vector (7 downto 0); -- Month (1 to 12)
signal GPS_YEAR1   : std_logic_vector (7 downto 0); -- Year Higher byte
signal GPS_YEAR0   : std_logic_vector (7 downto 0); -- Year Lower byte
signal GPS_SEC_BUF  : std_logic_vector (7 downto 0); -- Buffering needed to stabilize the data during a COINC
signal GPS_MIN_BUF   : std_logic_vector (7 downto 0);
signal GPS_HOUR_BUF   : std_logic_vector (7 downto 0);
signal GPS_DAY_BUF   : std_logic_vector (7 downto 0);
signal GPS_MONTH_BUF   : std_logic_vector (7 downto 0);
signal GPS_YEAR1_BUF   : std_logic_vector (7 downto 0);
signal GPS_YEAR0_BUF   : std_logic_vector (7 downto 0);
signal GPS_TEMP3   : std_logic_vector (7 downto 0); -- Temperture Higher byte
signal GPS_TEMP2   : std_logic_vector (7 downto 0); -- Temperture
signal GPS_TEMP1   : std_logic_vector (7 downto 0); -- Temperture
signal GPS_TEMP0   : std_logic_vector (7 downto 0); -- Temperture Lower byte
signal GPS_LAT7  : std_logic_vector (7 downto 0); -- Latitude Higher byte
signal GPS_LAT6  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT5  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT4  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT3  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT2  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT1  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT0  : std_logic_vector (7 downto 0); -- Latitude Lower byte
signal GPS_LONG7  : std_logic_vector (7 downto 0); -- Longitude Higher byte
signal GPS_LONG6  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG5  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG4  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG3  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG2  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG1  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG0  : std_logic_vector (7 downto 0); -- Longitude Lower byte
signal GPS_ALT7  : std_logic_vector (7 downto 0); -- Altitude Higher byte
signal GPS_ALT6  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT5  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT4  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT3  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT2  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT1  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT0  : std_logic_vector (7 downto 0); -- Altitude Lower byte
signal GPS_QUANT3  : std_logic_vector (7 downto 0); -- PPS Quantization error Higher byte
signal GPS_QUANT2  : std_logic_vector (7 downto 0); -- PPS Quantization error
signal GPS_QUANT1  : std_logic_vector (7 downto 0); -- PPS Quantization error
signal GPS_QUANT0  : std_logic_vector (7 downto 0); -- PPS Quantization error Lower byte
signal GPS_SATCOUNT  : std_logic_vector (7 downto 0); -- Number of tracked satellites
signal GPS_SATNUM1  : std_logic_vector (7 downto 0); -- Number of satellite 1
signal GPS_SAT1LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SAT1LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SAT1LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SAT1LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SATNUM2  : std_logic_vector (7 downto 0); -- Number of satellite 2
signal GPS_SAT2LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SAT2LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SAT2LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SAT2LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SATNUM3  : std_logic_vector (7 downto 0); -- Number of satellite 3
signal GPS_SAT3LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SAT3LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SAT3LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SAT3LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SATNUM4  : std_logic_vector (7 downto 0); -- Number of satellite 4
signal GPS_SAT4LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SAT4LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SAT4LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SAT4LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SATNUM5  : std_logic_vector (7 downto 0); -- Number of satellite 5
signal GPS_SAT5LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SAT5LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SAT5LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SAT5LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SATNUM6  : std_logic_vector (7 downto 0); -- Number of satellite 6
signal GPS_SAT6LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SAT6LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SAT6LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SAT6LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SATNUM7  : std_logic_vector (7 downto 0); -- Number of satellite 7
signal GPS_SAT7LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SAT7LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SAT7LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SAT7LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SATNUM8  : std_logic_vector (7 downto 0); -- Number of satellite 8
signal GPS_SAT8LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SAT8LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SAT8LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SAT8LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SATNUM9  : std_logic_vector (7 downto 0); -- Number of satellite 9
signal GPS_SAT9LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SAT9LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SAT9LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SAT9LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SATNUM10  : std_logic_vector (7 downto 0); -- Number of satellite 10
signal GPS_SAT10LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SAT10LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SAT10LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SAT10LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SATNUM11  : std_logic_vector (7 downto 0); -- Number of satellite 11
signal GPS_SAT11LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SAT11LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SAT11LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SAT11LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SATNUM12  : std_logic_vector (7 downto 0); -- Number of satellite 12
signal GPS_SAT12LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 12
signal GPS_SAT12LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 12
signal GPS_SAT12LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 12
signal GPS_SAT12LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 12

signal CTP_COUNT: std_logic_vector(31 downto 0);
signal NEG_FASE_BIT: std_logic ; -- This signal clocks the one PPS signal on the negative fase of the CLK200MHz clock to determine the offset 2.5ns better
signal NEG_FASE_BIT_DEL: std_logic ; -- NEG_FASE_BIT after a negative edge of the CLK200MHz clock
signal ONE_PPS_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious ONE_PPS with the 200MHz
signal ONE_PPS_DEL2: std_logic ;
signal ONE_PPS_SLOW_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious ONE_PPS with the 10MHz
signal ONE_PPS_SLOW_DEL2: std_logic ;
signal ONE_PPS_SLOW_DEL3: std_logic ;
signal TS_ONE_PPS_READOUT_DONE_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious TS_ONE_PPS_READOUT_DONE with the 200MHz
signal TS_ONE_PPS_READOUT_DONE_DEL2: std_logic ;

signal COMPL1_IN_DEL1: std_logic ;
signal COMPL1_IN_DEL2: std_logic ;
signal COMPH1_IN_DEL1: std_logic ;
signal COMPH1_IN_DEL2: std_logic ;
signal COMPL2_IN_DEL1: std_logic ;
signal COMPL2_IN_DEL2: std_logic ;
signal COMPH2_IN_DEL1: std_logic ;
signal COMPH2_IN_DEL2: std_logic ;
signal COMPL1_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPL1 is high
signal COMPH1_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPH1 is high
signal COMPL2_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPL2 is high
signal COMPH2_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPH2 is high
signal COMPL1_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPL1
signal COMPH1_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPH1
signal COMPL2_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPL2
signal COMPH2_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPH2
signal COMPDATA_L1: std_logic_vector(127 downto 0);
signal COMPDATA_H1: std_logic_vector(127 downto 0);
signal COMPDATA_L2: std_logic_vector(127 downto 0);
signal COMPDATA_H2: std_logic_vector(127 downto 0);
signal RST_COMPL1: std_logic ; -- Reset signal synchronized at 200MHz
signal RST_COMPH1: std_logic ; -- Reset signal synchronized at 200MHz
signal RST_COMPL2: std_logic ; -- Reset signal synchronized at 200MHz
signal RST_COMPH2: std_logic ; -- Reset signal synchronized at 200MHz
signal RST_COMPL1_10MHZ: std_logic ;
signal RST_COMPH1_10MHZ: std_logic ;
signal RST_COMPL2_10MHZ: std_logic ;
signal RST_COMPH2_10MHZ: std_logic ;
signal VALID_COMPL1: std_logic ;
signal VALID_COMPH1: std_logic ;
signal VALID_COMPL2: std_logic ;
signal VALID_COMPH2: std_logic ;
signal VALID_COMPL1_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz
signal VALID_COMPH1_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz
signal VALID_COMPL2_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz
signal VALID_COMPH2_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz
signal VALID_COMPL1_10MHZ_DEL: std_logic ;
signal VALID_COMPH1_10MHZ_DEL: std_logic ;
signal VALID_COMPL2_10MHZ_DEL: std_logic ;
signal VALID_COMPH2_10MHZ_DEL: std_logic ;
signal VALID_COMPL1_10MHZ_OUT: std_logic ;
signal VALID_COMPH1_10MHZ_OUT: std_logic ;
signal VALID_COMPL2_10MHZ_OUT: std_logic ;
signal VALID_COMPH2_10MHZ_OUT: std_logic ;
signal COMPDATA_READOUT_DONE_DEL1: std_logic ;
signal COMPDATA_READOUT_DONE_DEL2: std_logic ;    

begin

  GPS_SDI <= SPY_SDO and GPS_PROG_ENABLE;
  SPY_SDI <= GPS_SDO when SPY_CON = '1' else 'Z';

-- 153600HZ counter/clock
-- Used for sampling the serial RS232 data at 16 times the bautrate of 9600Hz
-- This is actual 153850Hz (10Mhz divide by 65); Mismatch is 0.16%
  process (CLK10MHz, SYSRST)
  begin
    if SYSRST = '1' then
      COUNTER_153600 <= (others => '0');
    elsif CLK10MHz'event and CLK10MHz = '1' then
      if COUNTER_153600 >= "1000000" then -- 10Mhz divide by 65 (from 0 to 64)
        COUNTER_153600 <= (others => '0');
        CLK_153600 <= '1';
      else
        COUNTER_153600<= COUNTER_153600 + "0000001";
        CLK_153600 <= '0';
      end if;
    end if;
  end process;

  -- Counter at 1.7 seconds; Time out counter for RXD; used for GPS master detection
  process(CLK_153600, SYSRST)
  begin
    if SYSRST = '1' then
      COUNTER_ONE_SEC_SEVEN <= (others => '0');
      COUNTER_ONE_SEC_SEVEN_DEL <= '0';
      GPS_SDO_DEL <= '0';
    elsif CLK_153600'event and CLK_153600 = '1' then
      COUNTER_ONE_SEC_SEVEN <= COUNTER_ONE_SEC_SEVEN + "0000000000000000001";
      COUNTER_ONE_SEC_SEVEN_DEL <= COUNTER_ONE_SEC_SEVEN(18);
      GPS_SDO_DEL <= GPS_SDO;
    end if;
  end process;

 -- Master detection
  process(CLK_153600, SYSRST)
  begin
    if SYSRST = '1' then
      RXD_TIME_OUT <= "11"; -- Default in Slave mode
    elsif CLK_153600'event and CLK_153600 = '1' then
      if GPS_SDO = '0' and GPS_SDO_DEL = '1' then -- Negative edge of TXD GPS reciever output
        RXD_TIME_OUT <= "00"; -- Sets RXD_TIME_OUT in Master mode
      elsif RXD_TIME_OUT = "11" then
        RXD_TIME_OUT <= RXD_TIME_OUT;
      elsif COUNTER_ONE_SEC_SEVEN(18) = '1' and COUNTER_ONE_SEC_SEVEN_DEL = '0' then -- Rising edge of 1.7s clock
        RXD_TIME_OUT <= RXD_TIME_OUT + "01";
      end if;
    end if;
  end process;

  MASTER <= '0' when RXD_TIME_OUT = "11" else '1';

------------------ Start Recieving GPS data -----------------------------------------

 -- Sample counter
  process(CLK_153600, SYSRST)
  begin
    if SYSRST = '1' then
      SAMPLE_COUNT <= 0;
    elsif CLK_153600'event and CLK_153600 = '1' then
      if SAMPLE_COUNT = 0 and RXD = '1' then
        SAMPLE_COUNT <= 0 ; -- wait for start
      elsif SAMPLE_COUNT = 8 and RXD = '1' then
        SAMPLE_COUNT <= 0 ; -- false start
      elsif SAMPLE_COUNT = 168 then
        SAMPLE_COUNT <= 0; -- end
      else
        SAMPLE_COUNT <= SAMPLE_COUNT + 1;
      end if;
    end if;
  end process;

 -- TIME_OUT counter
 -- This counter counts if there is 1 bytes (176 counts) long no input data (RXD = '1')
 -- After this, the counter latches itself till a startbit  (RXD = '0')
 process(CLK_153600, SYSRST)
 begin
   if SYSRST = '1' then
     TIME_OUT_COUNT <= 0;
   elsif CLK_153600'event and CLK_153600 = '1' then
     if RXD = '0' then
       TIME_OUT_COUNT <= 0;
     elsif TIME_OUT_COUNT = 1760 then
       TIME_OUT_COUNT <= TIME_OUT_COUNT;
     else
       TIME_OUT_COUNT <= TIME_OUT_COUNT + 1;
     end if;
   end if;
 end process;

 TIME_OUT <= '1' when TIME_OUT_COUNT = 1760 else '0';

 RST_MESSAGE <= TIME_OUT or END_BYTE_DETECTED;

 -- Filling of GET_BYTE
 process(CLK_153600, SYSRST)
 begin
   if SYSRST = '1' then
     GET_BYTE <= (others => '0');
   elsif CLK_153600'event and CLK_153600 = '1' then
     if SAMPLE_COUNT = 24 then
       GET_BYTE(0) <= RXD;
     end if;
     if SAMPLE_COUNT = 40 then
       GET_BYTE(1) <= RXD;
     end if;
     if SAMPLE_COUNT = 56 then
       GET_BYTE(2) <= RXD;
     end if;
     if SAMPLE_COUNT = 72 then
       GET_BYTE(3) <= RXD;
     end if;
     if SAMPLE_COUNT = 88 then
       GET_BYTE(4) <= RXD;
     end if;
     if SAMPLE_COUNT = 104 then
       GET_BYTE(5) <= RXD;
     end if;
     if SAMPLE_COUNT = 120 then
       GET_BYTE(6) <= RXD;
     end if;
     if SAMPLE_COUNT = 136 then
       GET_BYTE(7) <= RXD;
     end if;
   end if;
 end process;

 -- Filling of MESSAGE_BYTE's
 process(CLK_153600, SYSRST)
 begin
   if SYSRST = '1' then
     MESSAGE_BYTE1 <= (others => '0');
     MESSAGE_BYTE2 <= (others => '0');
     MESSAGE_BYTE3 <= (others => '0');
   elsif CLK_153600'event and CLK_153600 = '1' then
     if RST_MESSAGE = '1' then
       MESSAGE_BYTE1 <= (others => '0');
       MESSAGE_BYTE2 <= (others => '0');
       MESSAGE_BYTE3 <= (others => '0');
     elsif SAMPLE_COUNT = 144 then
       if STUFFED_BYTE = '0' then
         MESSAGE_BYTE1 <= GET_BYTE;
       end if;
       MESSAGE_BYTE2 <= MESSAGE_BYTE1;
       MESSAGE_BYTE3 <= MESSAGE_BYTE2;
     end if;
   end if;
 end process;

 -- MESSAGE_SELECT
 process(CLK_153600, SYSRST)
 begin
   if SYSRST = '1' then
     MESSAGE_SELECT <= "00";
   elsif CLK_153600'event and CLK_153600 = '1' then
     if RST_MESSAGE = '1' then
       MESSAGE_SELECT <= "00";
     elsif MESSAGE_BYTE3 = "00010000" and MESSAGE_BYTE2 = "10001111" and MESSAGE_BYTE1 = "10101011" then
       MESSAGE_SELECT <= "01";
     elsif MESSAGE_BYTE3 = "00010000" and MESSAGE_BYTE2 = "10001111" and MESSAGE_BYTE1 = "10101100" then
       MESSAGE_SELECT <= "10";
     elsif MESSAGE_BYTE2 = "00010000" and MESSAGE_BYTE1 = "01000111" then
       MESSAGE_SELECT <= "11";
     end if;
   end if;
 end process;

 -- MESSAGE decoding
 process(CLK_153600,SYSRST,DECODER_BYTE_COUNT,DECODE_BYTE1)
 begin
   if SYSRST = '1' then
     STUFFED_BYTE <= '0';
     END_BYTE_DETECTED <= '0';
     DECODE_BYTE1 <= (others => '0');
     DECODER_BYTE_COUNT <= 0;
     GPS_SEC <= (others => '0');
     GPS_MIN <= (others => '0');
     GPS_HOUR <= (others => '0');
     GPS_DAY <= (others => '0');
     GPS_MONTH <= (others => '0');
     GPS_YEAR1 <= (others => '0');
     GPS_YEAR0 <= (others => '0');
     GPS_TEMP3 <= (others => '0');
     GPS_TEMP2 <= (others => '0');
     GPS_TEMP1 <= (others => '0');
     GPS_TEMP0 <= (others => '0');
     GPS_LAT7 <= (others => '0');
     GPS_LAT6 <= (others => '0');
     GPS_LAT5 <= (others => '0');
     GPS_LAT4 <= (others => '0');
     GPS_LAT3 <= (others => '0');
     GPS_LAT2 <= (others => '0');
     GPS_LAT1 <= (others => '0');
     GPS_LAT0 <= (others => '0');
     GPS_LONG7 <= (others => '0');
     GPS_LONG6 <= (others => '0');
     GPS_LONG5 <= (others => '0');
     GPS_LONG4 <= (others => '0');
     GPS_LONG3 <= (others => '0');
     GPS_LONG2 <= (others => '0');
     GPS_LONG1 <= (others => '0');
     GPS_LONG0 <= (others => '0');
     GPS_ALT7 <= (others => '0');
     GPS_ALT6 <= (others => '0');
     GPS_ALT5 <= (others => '0');
     GPS_ALT4 <= (others => '0');
     GPS_ALT3 <= (others => '0');
     GPS_ALT2 <= (others => '0');
     GPS_ALT1 <= (others => '0');
     GPS_ALT0 <= (others => '0');
     GPS_QUANT3 <= (others => '0');
     GPS_QUANT2 <= (others => '0');
     GPS_QUANT1 <= (others => '0');
     GPS_QUANT0 <= (others => '0');
     GPS_SATCOUNT <= (others => '0');
     GPS_SATNUM1 <= (others => '0');
     GPS_SAT1LEV3 <= (others => '0');
     GPS_SAT1LEV2 <= (others => '0');
     GPS_SAT1LEV1 <= (others => '0');
     GPS_SAT1LEV0 <= (others => '0');
     GPS_SATNUM2 <= (others => '0');
     GPS_SAT2LEV3 <= (others => '0');
     GPS_SAT2LEV2 <= (others => '0');
     GPS_SAT2LEV1 <= (others => '0');
     GPS_SAT2LEV0 <= (others => '0');
     GPS_SATNUM3 <= (others => '0');
     GPS_SAT3LEV3 <= (others => '0');
     GPS_SAT3LEV2 <= (others => '0');
     GPS_SAT3LEV1 <= (others => '0');
     GPS_SAT3LEV0 <= (others => '0');
     GPS_SATNUM4 <= (others => '0');
     GPS_SAT4LEV3 <= (others => '0');
     GPS_SAT4LEV2 <= (others => '0');
     GPS_SAT4LEV1 <= (others => '0');
     GPS_SAT4LEV0 <= (others => '0');
     GPS_SATNUM5 <= (others => '0');
     GPS_SAT5LEV3 <= (others => '0');
     GPS_SAT5LEV2 <= (others => '0');
     GPS_SAT5LEV1 <= (others => '0');
     GPS_SAT5LEV0 <= (others => '0');
     GPS_SATNUM6 <= (others => '0');
     GPS_SAT6LEV3 <= (others => '0');
     GPS_SAT6LEV2 <= (others => '0');
     GPS_SAT6LEV1 <= (others => '0');
     GPS_SAT6LEV0 <= (others => '0');
     GPS_SATNUM7 <= (others => '0');
     GPS_SAT7LEV3 <= (others => '0');
     GPS_SAT7LEV2 <= (others => '0');
     GPS_SAT7LEV1 <= (others => '0');
     GPS_SAT7LEV0 <= (others => '0');
     GPS_SATNUM8 <= (others => '0');
     GPS_SAT8LEV3 <= (others => '0');
     GPS_SAT8LEV2 <= (others => '0');
     GPS_SAT8LEV1 <= (others => '0');
     GPS_SAT8LEV0 <= (others => '0');
     GPS_SATNUM9 <= (others => '0');
     GPS_SAT9LEV3 <= (others => '0');
     GPS_SAT9LEV2 <= (others => '0');
     GPS_SAT9LEV1 <= (others => '0');
     GPS_SAT9LEV0 <= (others => '0');
     GPS_SATNUM10 <= (others => '0');
     GPS_SAT10LEV3 <= (others => '0');
     GPS_SAT10LEV2 <= (others => '0');
     GPS_SAT10LEV1 <= (others => '0');
     GPS_SAT10LEV0 <= (others => '0');
     GPS_SATNUM11 <= (others => '0');
     GPS_SAT11LEV3 <= (others => '0');
     GPS_SAT11LEV2 <= (others => '0');
     GPS_SAT11LEV1 <= (others => '0');
     GPS_SAT11LEV0 <= (others => '0');
     GPS_SATNUM12 <= (others => '0');
     GPS_SAT12LEV3 <= (others => '0');
     GPS_SAT12LEV2 <= (others => '0');
     GPS_SAT12LEV1 <= (others => '0');
     GPS_SAT12LEV0 <= (others => '0');

   elsif CLK_153600'event and CLK_153600 = '1' then
     if RST_MESSAGE = '1' then
       STUFFED_BYTE <= '0';
       DECODE_BYTE1 <= (others => '0');
       END_BYTE_DETECTED <= '0';
       DECODER_BYTE_COUNT <= 0;
     elsif SAMPLE_COUNT = 144 and MESSAGE_SELECT /= "00" then
       DECODE_BYTE1 <= GET_BYTE;
       if GET_BYTE = "00010000" and DECODE_BYTE1 = "00010000" then
         STUFFED_BYTE <= not STUFFED_BYTE;
       else
         STUFFED_BYTE <= '0';
       end if;
       if STUFFED_BYTE = '0' and GET_BYTE = "00000011" and DECODE_BYTE1 = "00010000" then
         END_BYTE_DETECTED <= '1';
       else
         END_BYTE_DETECTED <= '0';
       end if;
       if STUFFED_BYTE = '0' then
         DECODER_BYTE_COUNT <= DECODER_BYTE_COUNT + 1;
       end if;
     end if;
     if MESSAGE_SELECT = "01" and SAMPLE_COUNT = 144 and STUFFED_BYTE = '0' then
       case DECODER_BYTE_COUNT is
       when 9 => GPS_FLAGS <= DECODE_BYTE1;
       when 10 => GPS_SEC <= DECODE_BYTE1;
       when 11 => GPS_MIN <= DECODE_BYTE1;
       when 12 => GPS_HOUR <= DECODE_BYTE1;
       when 13 => GPS_DAY <= DECODE_BYTE1;
       when 14 => GPS_MONTH <= DECODE_BYTE1;
       when 15 => GPS_YEAR1 <= DECODE_BYTE1;
       when 16 => GPS_YEAR0 <= DECODE_BYTE1;
       when others =>
       end case;
     end if;
     if MESSAGE_SELECT = "10" and SAMPLE_COUNT = 144 and STUFFED_BYTE = '0' then
       case DECODER_BYTE_COUNT is
       when 32 => GPS_TEMP3 <= DECODE_BYTE1;
       when 33 => GPS_TEMP2 <= DECODE_BYTE1;
       when 34 => GPS_TEMP1 <= DECODE_BYTE1;
       when 35 => GPS_TEMP0 <= DECODE_BYTE1;
       when 36 => GPS_LAT7 <= DECODE_BYTE1;
       when 37 => GPS_LAT6 <= DECODE_BYTE1;
       when 38 => GPS_LAT5 <= DECODE_BYTE1;
       when 39 => GPS_LAT4 <= DECODE_BYTE1;
       when 40 => GPS_LAT3 <= DECODE_BYTE1;
       when 41 => GPS_LAT2 <= DECODE_BYTE1;
       when 42 => GPS_LAT1 <= DECODE_BYTE1;
       when 43 => GPS_LAT0 <= DECODE_BYTE1;
       when 44 => GPS_LONG7 <= DECODE_BYTE1;
       when 45 => GPS_LONG6 <= DECODE_BYTE1;
       when 46 => GPS_LONG5 <= DECODE_BYTE1;
       when 47 => GPS_LONG4 <= DECODE_BYTE1;
       when 48 => GPS_LONG3 <= DECODE_BYTE1;
       when 49 => GPS_LONG2 <= DECODE_BYTE1;
       when 50 => GPS_LONG1 <= DECODE_BYTE1;
       when 51 => GPS_LONG0 <= DECODE_BYTE1;
       when 52 => GPS_ALT7 <= DECODE_BYTE1;
       when 53 => GPS_ALT6 <= DECODE_BYTE1;
       when 54 => GPS_ALT5 <= DECODE_BYTE1;
       when 55 => GPS_ALT4 <= DECODE_BYTE1;
       when 56 => GPS_ALT3 <= DECODE_BYTE1;
       when 57 => GPS_ALT2 <= DECODE_BYTE1;
       when 58 => GPS_ALT1 <= DECODE_BYTE1;
       when 59 => GPS_ALT0 <= DECODE_BYTE1;
       when 60 => GPS_QUANT3 <= DECODE_BYTE1;
       when 61 => GPS_QUANT2 <= DECODE_BYTE1;
       when 62 => GPS_QUANT1 <= DECODE_BYTE1;
       when 63 => GPS_QUANT0 <= DECODE_BYTE1;
       when others =>
       end case;
     end if;
     if MESSAGE_SELECT = "11" and SAMPLE_COUNT = 144 and STUFFED_BYTE = '0' and not (GET_BYTE = "00000011" and DECODE_BYTE1 = "00010000") then
       case DECODER_BYTE_COUNT is
       when 1 => GPS_SATCOUNT <= DECODE_BYTE1;
         GPS_SATNUM1 <= (others => '0');
         GPS_SAT1LEV3 <= (others => '0');
         GPS_SAT1LEV2 <= (others => '0');
         GPS_SAT1LEV1 <= (others => '0');
         GPS_SAT1LEV0 <= (others => '0');
         GPS_SATNUM2 <= (others => '0');
         GPS_SAT2LEV3 <= (others => '0');
         GPS_SAT2LEV2 <= (others => '0');
         GPS_SAT2LEV1 <= (others => '0');
         GPS_SAT2LEV0 <= (others => '0');
         GPS_SATNUM3 <= (others => '0');
         GPS_SAT3LEV3 <= (others => '0');
         GPS_SAT3LEV2 <= (others => '0');
         GPS_SAT3LEV1 <= (others => '0');
         GPS_SAT3LEV0 <= (others => '0');
         GPS_SATNUM4 <= (others => '0');
         GPS_SAT4LEV3 <= (others => '0');
         GPS_SAT4LEV2 <= (others => '0');
         GPS_SAT4LEV1 <= (others => '0');
         GPS_SAT4LEV0 <= (others => '0');
         GPS_SATNUM5 <= (others => '0');
         GPS_SAT5LEV3 <= (others => '0');
         GPS_SAT5LEV2 <= (others => '0');
         GPS_SAT5LEV1 <= (others => '0');
         GPS_SAT5LEV0 <= (others => '0');
         GPS_SATNUM6 <= (others => '0');
         GPS_SAT6LEV3 <= (others => '0');
         GPS_SAT6LEV2 <= (others => '0');
         GPS_SAT6LEV1 <= (others => '0');
         GPS_SAT6LEV0 <= (others => '0');
         GPS_SATNUM7 <= (others => '0');
         GPS_SAT7LEV3 <= (others => '0');
         GPS_SAT7LEV2 <= (others => '0');
         GPS_SAT7LEV1 <= (others => '0');
         GPS_SAT7LEV0 <= (others => '0');
         GPS_SATNUM8 <= (others => '0');
         GPS_SAT8LEV3 <= (others => '0');
         GPS_SAT8LEV2 <= (others => '0');
         GPS_SAT8LEV1 <= (others => '0');
         GPS_SAT8LEV0 <= (others => '0');
         GPS_SATNUM9 <= (others => '0');
         GPS_SAT9LEV3 <= (others => '0');
         GPS_SAT9LEV2 <= (others => '0');
         GPS_SAT9LEV1 <= (others => '0');
         GPS_SAT9LEV0 <= (others => '0');
         GPS_SATNUM10 <= (others => '0');
         GPS_SAT10LEV3 <= (others => '0');
         GPS_SAT10LEV2 <= (others => '0');
         GPS_SAT10LEV1 <= (others => '0');
         GPS_SAT10LEV0 <= (others => '0');
         GPS_SATNUM11 <= (others => '0');
         GPS_SAT11LEV3 <= (others => '0');
         GPS_SAT11LEV2 <= (others => '0');
         GPS_SAT11LEV1 <= (others => '0');
         GPS_SAT11LEV0 <= (others => '0');
         GPS_SATNUM12 <= (others => '0');
         GPS_SAT12LEV3 <= (others => '0');
         GPS_SAT12LEV2 <= (others => '0');
         GPS_SAT12LEV1 <= (others => '0');
         GPS_SAT12LEV0 <= (others => '0');
       when 2 => GPS_SATNUM1 <= DECODE_BYTE1;
       when 3 => GPS_SAT1LEV3 <= DECODE_BYTE1;
       when 4 => GPS_SAT1LEV2 <= DECODE_BYTE1;
       when 5 => GPS_SAT1LEV1 <= DECODE_BYTE1;
       when 6 => GPS_SAT1LEV0 <= DECODE_BYTE1;
       when 7 => GPS_SATNUM2 <= DECODE_BYTE1;
       when 8 => GPS_SAT2LEV3 <= DECODE_BYTE1;
       when 9 => GPS_SAT2LEV2 <= DECODE_BYTE1;
       when 10 => GPS_SAT2LEV1 <= DECODE_BYTE1;
       when 11 => GPS_SAT2LEV0 <= DECODE_BYTE1;
       when 12 => GPS_SATNUM3 <= DECODE_BYTE1;
       when 13 => GPS_SAT3LEV3 <= DECODE_BYTE1;
       when 14 => GPS_SAT3LEV2 <= DECODE_BYTE1;
       when 15 => GPS_SAT3LEV1 <= DECODE_BYTE1;
       when 16 => GPS_SAT3LEV0 <= DECODE_BYTE1;
       when 17 => GPS_SATNUM4 <= DECODE_BYTE1;
       when 18 => GPS_SAT4LEV3 <= DECODE_BYTE1;
       when 19 => GPS_SAT4LEV2 <= DECODE_BYTE1;
       when 20 => GPS_SAT4LEV1 <= DECODE_BYTE1;
       when 21 => GPS_SAT4LEV0 <= DECODE_BYTE1;
       when 22 => GPS_SATNUM5 <= DECODE_BYTE1;
       when 23 => GPS_SAT5LEV3 <= DECODE_BYTE1;
       when 24 => GPS_SAT5LEV2 <= DECODE_BYTE1;
       when 25 => GPS_SAT5LEV1 <= DECODE_BYTE1;
       when 26 => GPS_SAT5LEV0 <= DECODE_BYTE1;
       when 27 => GPS_SATNUM6 <= DECODE_BYTE1;
       when 28 => GPS_SAT6LEV3 <= DECODE_BYTE1;
       when 29 => GPS_SAT6LEV2 <= DECODE_BYTE1;
       when 30 => GPS_SAT6LEV1 <= DECODE_BYTE1;
       when 31 => GPS_SAT6LEV0 <= DECODE_BYTE1;
       when 32 => GPS_SATNUM7 <= DECODE_BYTE1;
       when 33 => GPS_SAT7LEV3 <= DECODE_BYTE1;
       when 34 => GPS_SAT7LEV2 <= DECODE_BYTE1;
       when 35 => GPS_SAT7LEV1 <= DECODE_BYTE1;
       when 36 => GPS_SAT7LEV0 <= DECODE_BYTE1;
       when 37 => GPS_SATNUM8 <= DECODE_BYTE1;
       when 38 => GPS_SAT8LEV3 <= DECODE_BYTE1;
       when 39 => GPS_SAT8LEV2 <= DECODE_BYTE1;
       when 40 => GPS_SAT8LEV1 <= DECODE_BYTE1;
       when 41 => GPS_SAT8LEV0 <= DECODE_BYTE1;
       when 42 => GPS_SATNUM9 <= DECODE_BYTE1;
       when 43 => GPS_SAT9LEV3 <= DECODE_BYTE1;
       when 44 => GPS_SAT9LEV2 <= DECODE_BYTE1;
       when 45 => GPS_SAT9LEV1 <= DECODE_BYTE1;
       when 46 => GPS_SAT9LEV0 <= DECODE_BYTE1;
       when 47 => GPS_SATNUM10 <= DECODE_BYTE1;
       when 48 => GPS_SAT10LEV3 <= DECODE_BYTE1;
       when 49 => GPS_SAT10LEV2 <= DECODE_BYTE1;
       when 50 => GPS_SAT10LEV1 <= DECODE_BYTE1;
       when 51 => GPS_SAT10LEV0 <= DECODE_BYTE1;
       when 52 => GPS_SATNUM11 <= DECODE_BYTE1;
       when 53 => GPS_SAT11LEV3 <= DECODE_BYTE1;
       when 54 => GPS_SAT11LEV2 <= DECODE_BYTE1;
       when 55 => GPS_SAT11LEV1 <= DECODE_BYTE1;
       when 56 => GPS_SAT11LEV0 <= DECODE_BYTE1;
       when 57 => GPS_SATNUM12 <= DECODE_BYTE1;
       when 58 => GPS_SAT12LEV3 <= DECODE_BYTE1;
       when 59 => GPS_SAT12LEV2 <= DECODE_BYTE1;
       when 60 => GPS_SAT12LEV1 <= DECODE_BYTE1;
       when 61 => GPS_SAT12LEV0 <= DECODE_BYTE1;
       when others =>
       end case;
     end if;
   end if;
 end process;

------------------ End Recieving GPS data -----------------------------------------

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ONE_PPS_DEL1 <= '0';
      ONE_PPS_DEL2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      ONE_PPS_DEL1 <= ONE_PPS;
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ONE_PPS_SLOW_DEL1 <= '0';
      ONE_PPS_SLOW_DEL2 <= '0';
      ONE_PPS_SLOW_DEL3 <= '0';
      TS_ONE_PPS_READOUT_DONE_DEL1 <= '0';
      TS_ONE_PPS_READOUT_DONE_DEL2 <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      ONE_PPS_SLOW_DEL1 <= ONE_PPS;
      ONE_PPS_SLOW_DEL2 <= ONE_PPS_SLOW_DEL1;
      ONE_PPS_SLOW_DEL3 <= ONE_PPS_SLOW_DEL2;
      TS_ONE_PPS_READOUT_DONE_DEL1 <= TS_ONE_PPS_READOUT_DONE;
      TS_ONE_PPS_READOUT_DONE_DEL2 <= TS_ONE_PPS_READOUT_DONE_DEL1;
    end if;
  end process;

  -- CTP COUNTER
  -- The CTP counter counts from ONE_PPS to ONE_PPS
  process (CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      CTP_COUNT <= "00000000000000000000000000000001";
    elsif CLK200MHz'event and CLK200MHz ='1' then
      if ONE_PPS_DEL1 = '1'and ONE_PPS_DEL2 = '0' then
        CTP_COUNT <= "00000000000000000000000000000001";
      else
        CTP_COUNT <= CTP_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      NEG_FASE_BIT <= '0';
      NEG_FASE_BIT_DEL <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '0') then -- on a negative edge of the CLK200MHz clock
      NEG_FASE_BIT <= ONE_PPS;
      NEG_FASE_BIT_DEL <= NEG_FASE_BIT;
    end if;
  end process;

  -- Latch GPS_TIME and counter values on positive edge of ONE_PPS
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      CTP_TS_ONE_PPS_OUT <= (others => '0');
      GPS_SEC_BUF <= (others => '0');
      GPS_MIN_BUF <= (others => '0');
      GPS_HOUR_BUF <= (others => '0');
      GPS_DAY_BUF <= (others => '0');
      GPS_MONTH_BUF <= (others => '0');
      GPS_YEAR1_BUF <= (others => '0');
      GPS_YEAR0_BUF <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then
        CTP_TS_ONE_PPS_OUT(30 downto 0) <= CTP_COUNT(30 downto 0);
        CTP_TS_ONE_PPS_OUT(31) <= NEG_FASE_BIT_DEL;
        GPS_SEC_BUF <= GPS_SEC;
        GPS_MIN_BUF <= GPS_MIN;
        GPS_HOUR_BUF <= GPS_HOUR;
        GPS_DAY_BUF <= GPS_DAY;
        GPS_MONTH_BUF <= GPS_MONTH;
        GPS_YEAR1_BUF <= GPS_YEAR1;
        GPS_YEAR0_BUF <= GPS_YEAR0;
      end if;
    end if;
  end process;

  -- Latch GPS_TIME and counter values on positive edge of ONE_PPS
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      GPS_TS_ONE_PPS_OUT <= (others => '0');
      CTD_TS_ONE_PPS_OUT <= (others => '0');
      LONGITUDE_OUT <= (others => '0');
      LATITUDE_OUT <= (others => '0');
      ALTITUDE_OUT <= (others => '0');
      TEMP_OUT <= (others => '0');
      SAT_INFO_OUT <= (others => '0');
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if ONE_PPS_SLOW_DEL2 = '1' and ONE_PPS_SLOW_DEL3 = '0' then
        GPS_TS_ONE_PPS_OUT(55 downto 48) <= GPS_DAY; -- Day
        GPS_TS_ONE_PPS_OUT(47 downto 40) <= GPS_MONTH; -- Month
        GPS_TS_ONE_PPS_OUT(39 downto 32) <= GPS_YEAR1; -- Year
        GPS_TS_ONE_PPS_OUT(31 downto 24) <= GPS_YEAR0; -- Year
        GPS_TS_ONE_PPS_OUT(23 downto 16) <= GPS_HOUR; -- Hours
        GPS_TS_ONE_PPS_OUT(15 downto 8) <= GPS_MIN; -- Minutes
        GPS_TS_ONE_PPS_OUT(7 downto 0) <= GPS_SEC; -- Seconds
        CTD_TS_ONE_PPS_OUT(31 downto 24) <= GPS_QUANT3;
        CTD_TS_ONE_PPS_OUT(23 downto 16) <= GPS_QUANT2;
        CTD_TS_ONE_PPS_OUT(15 downto 8) <= GPS_QUANT1;
        CTD_TS_ONE_PPS_OUT(7 downto 0) <= GPS_QUANT0;
        LATITUDE_OUT(63 downto 56) <= GPS_LAT7;
        LATITUDE_OUT(55 downto 48) <= GPS_LAT6;
        LATITUDE_OUT(47 downto 40) <= GPS_LAT5;
        LATITUDE_OUT(39 downto 32) <= GPS_LAT4;
        LATITUDE_OUT(31 downto 24) <= GPS_LAT3;
        LATITUDE_OUT(23 downto 16) <= GPS_LAT2;
        LATITUDE_OUT(15 downto 8) <= GPS_LAT1;
        LATITUDE_OUT(7 downto 0) <= GPS_LAT0;
        LONGITUDE_OUT(63 downto 56) <= GPS_LONG7;
        LONGITUDE_OUT(55 downto 48) <= GPS_LONG6;
        LONGITUDE_OUT(47 downto 40) <= GPS_LONG5;
        LONGITUDE_OUT(39 downto 32) <= GPS_LONG4;
        LONGITUDE_OUT(31 downto 24) <= GPS_LONG3;
        LONGITUDE_OUT(23 downto 16) <= GPS_LONG2;
        LONGITUDE_OUT(15 downto 8) <= GPS_LONG1;
        LONGITUDE_OUT(7 downto 0) <= GPS_LONG0;
        ALTITUDE_OUT(63 downto 56) <= GPS_ALT7;
        ALTITUDE_OUT(55 downto 48) <= GPS_ALT6;
        ALTITUDE_OUT(47 downto 40) <= GPS_ALT5;
        ALTITUDE_OUT(39 downto 32) <= GPS_ALT4;
        ALTITUDE_OUT(31 downto 24) <= GPS_ALT3;
        ALTITUDE_OUT(23 downto 16) <= GPS_ALT2;
        ALTITUDE_OUT(15 downto 8) <= GPS_ALT1;
        ALTITUDE_OUT(7 downto 0) <= GPS_ALT0;
        TEMP_OUT(31 downto 24) <= GPS_TEMP3;
        TEMP_OUT(23 downto 16) <= GPS_TEMP2;
        TEMP_OUT(15 downto 8) <= GPS_TEMP1;
        TEMP_OUT(7 downto 0) <= GPS_TEMP0;
        SAT_INFO_OUT(487 downto 480) <= GPS_SATCOUNT;
        SAT_INFO_OUT(479 downto 472) <= GPS_SATNUM1;
        SAT_INFO_OUT(471 downto 464) <= GPS_SAT1LEV3;
        SAT_INFO_OUT(463 downto 456) <= GPS_SAT1LEV2;
        SAT_INFO_OUT(455 downto 448) <= GPS_SAT1LEV1;
        SAT_INFO_OUT(447 downto 440) <= GPS_SAT1LEV0;
        SAT_INFO_OUT(439 downto 432) <= GPS_SATNUM2;
        SAT_INFO_OUT(431 downto 424) <= GPS_SAT2LEV3;
        SAT_INFO_OUT(423 downto 416) <= GPS_SAT2LEV2;
        SAT_INFO_OUT(415 downto 408) <= GPS_SAT2LEV1;
        SAT_INFO_OUT(407 downto 400) <= GPS_SAT2LEV0;
        SAT_INFO_OUT(399 downto 392) <= GPS_SATNUM3;
        SAT_INFO_OUT(391 downto 384) <= GPS_SAT3LEV3;
        SAT_INFO_OUT(383 downto 376) <= GPS_SAT3LEV2;
        SAT_INFO_OUT(375 downto 368) <= GPS_SAT3LEV1;
        SAT_INFO_OUT(367 downto 360) <= GPS_SAT3LEV0;
        SAT_INFO_OUT(359 downto 352) <= GPS_SATNUM4;
        SAT_INFO_OUT(351 downto 344) <= GPS_SAT4LEV3;
        SAT_INFO_OUT(343 downto 336) <= GPS_SAT4LEV2;
        SAT_INFO_OUT(335 downto 328) <= GPS_SAT4LEV1;
        SAT_INFO_OUT(327 downto 320) <= GPS_SAT4LEV0;
        SAT_INFO_OUT(319 downto 312) <= GPS_SATNUM5;
        SAT_INFO_OUT(311 downto 304) <= GPS_SAT5LEV3;
        SAT_INFO_OUT(303 downto 296) <= GPS_SAT5LEV2;
        SAT_INFO_OUT(295 downto 288) <= GPS_SAT5LEV1;
        SAT_INFO_OUT(287 downto 280) <= GPS_SAT5LEV0;
        SAT_INFO_OUT(279 downto 272) <= GPS_SATNUM6;
        SAT_INFO_OUT(271 downto 264) <= GPS_SAT6LEV3;
        SAT_INFO_OUT(263 downto 256) <= GPS_SAT6LEV2;
        SAT_INFO_OUT(255 downto 248) <= GPS_SAT6LEV1;
        SAT_INFO_OUT(247 downto 240) <= GPS_SAT6LEV0;
        SAT_INFO_OUT(239 downto 232) <= GPS_SATNUM7;
        SAT_INFO_OUT(231 downto 224) <= GPS_SAT7LEV3;
        SAT_INFO_OUT(223 downto 216) <= GPS_SAT7LEV2;
        SAT_INFO_OUT(215 downto 208) <= GPS_SAT7LEV1;
        SAT_INFO_OUT(207 downto 200) <= GPS_SAT7LEV0;
        SAT_INFO_OUT(199 downto 192) <= GPS_SATNUM8;
        SAT_INFO_OUT(191 downto 184) <= GPS_SAT8LEV3;
        SAT_INFO_OUT(183 downto 176) <= GPS_SAT8LEV2;
        SAT_INFO_OUT(175 downto 168) <= GPS_SAT8LEV1;
        SAT_INFO_OUT(167 downto 160) <= GPS_SAT8LEV0;
        SAT_INFO_OUT(159 downto 152) <= GPS_SATNUM9;
        SAT_INFO_OUT(151 downto 144) <= GPS_SAT9LEV3;
        SAT_INFO_OUT(143 downto 136) <= GPS_SAT9LEV2;
        SAT_INFO_OUT(135 downto 128) <= GPS_SAT9LEV1;
        SAT_INFO_OUT(127 downto 120) <= GPS_SAT9LEV0;
        SAT_INFO_OUT(119 downto 112) <= GPS_SATNUM10;
        SAT_INFO_OUT(111 downto 104) <= GPS_SAT10LEV3;
        SAT_INFO_OUT(103 downto 96) <= GPS_SAT10LEV2;
        SAT_INFO_OUT(95 downto 88) <= GPS_SAT10LEV1;
        SAT_INFO_OUT(87 downto 80) <= GPS_SAT10LEV0;
        SAT_INFO_OUT(79 downto 72) <= GPS_SATNUM11;
        SAT_INFO_OUT(71 downto 64) <= GPS_SAT11LEV3;
        SAT_INFO_OUT(63 downto 56) <= GPS_SAT11LEV2;
        SAT_INFO_OUT(55 downto 48) <= GPS_SAT11LEV1;
        SAT_INFO_OUT(47 downto 40) <= GPS_SAT11LEV0;
        SAT_INFO_OUT(39 downto 32) <= GPS_SATNUM12;
        SAT_INFO_OUT(31 downto 24) <= GPS_SAT12LEV3;
        SAT_INFO_OUT(23 downto 16) <= GPS_SAT12LEV2;
        SAT_INFO_OUT(15 downto 8) <= GPS_SAT12LEV1;
        SAT_INFO_OUT(7 downto 0) <= GPS_SAT12LEV0;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TS_ONE_PPS_VALID_OUT <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if STARTUP_BLOCK = '0' and ONE_PPS_SLOW_DEL2 = '1' and ONE_PPS_SLOW_DEL3 = '0' then
        TS_ONE_PPS_VALID_OUT <= '1';
      elsif TS_ONE_PPS_READOUT_DONE_DEL1 = '1' and TS_ONE_PPS_READOUT_DONE_DEL2 = '0' then
        TS_ONE_PPS_VALID_OUT <= '0';
      end if;
    end if;
  end process;

  GPS_TS_OUT(55 downto 48) <= GPS_DAY_BUF; -- Day
  GPS_TS_OUT(47 downto 40) <= GPS_MONTH_BUF; -- Month
  GPS_TS_OUT(39 downto 32) <= GPS_YEAR1_BUF; -- Year
  GPS_TS_OUT(31 downto 24) <= GPS_YEAR0_BUF; -- Year
  GPS_TS_OUT(23 downto 16) <= GPS_HOUR_BUF; -- Hours
  GPS_TS_OUT(15 downto 8) <= GPS_MIN_BUF; -- Minutes
  GPS_TS_OUT(7 downto 0) <= GPS_SEC_BUF; -- Seconds
  CTD_OUT <= CTP_COUNT;

------------------------- Comparator stuff ----------------------------------

  -- Delays and synchronization
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_IN_DEL1 <= '0';
      COMPL1_IN_DEL2 <= '0';
      COMPH1_IN_DEL1 <= '0';
      COMPH1_IN_DEL2 <= '0';
      COMPL2_IN_DEL1 <= '0';
      COMPL2_IN_DEL2 <= '0';
      COMPH2_IN_DEL1 <= '0';
      COMPH2_IN_DEL2 <= '0';
      RST_COMPL1 <= '0';
      RST_COMPH1 <= '0';
      RST_COMPL2 <= '0';
      RST_COMPH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COMPL1_IN_DEL1 <= COMPL1_IN;
      COMPL1_IN_DEL2 <= COMPL1_IN_DEL1;
      COMPH1_IN_DEL1 <= COMPH1_IN;
      COMPH1_IN_DEL2 <= COMPH1_IN_DEL1;
      COMPL2_IN_DEL1 <= COMPL2_IN;
      COMPL2_IN_DEL2 <= COMPL2_IN_DEL1;
      COMPH2_IN_DEL1 <= COMPH2_IN;
      COMPH2_IN_DEL2 <= COMPH2_IN_DEL1;
      RST_COMPL1 <= RST_COMPL1_10MHZ;
      RST_COMPH1 <= RST_COMPH1_10MHZ;
      RST_COMPL2 <= RST_COMPL2_10MHZ;
      RST_COMPH2 <= RST_COMPH2_10MHZ;
    end if;
  end process;

  process (CLK10MHz, SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPL1_10MHZ <= '0';
      VALID_COMPH1_10MHZ <= '0';
      VALID_COMPL2_10MHZ <= '0';
      VALID_COMPH2_10MHZ <= '0';
      VALID_COMPL1_10MHZ_DEL <= '0';
      VALID_COMPH1_10MHZ_DEL <= '0';
      VALID_COMPL2_10MHZ_DEL <= '0';
      VALID_COMPH2_10MHZ_DEL <= '0';
      COMPDATA_READOUT_DONE_DEL1 <= '0';
      COMPDATA_READOUT_DONE_DEL2 <= '0';
    elsif CLK10MHz'event and CLK10MHz = '1' then
      VALID_COMPL1_10MHZ <= VALID_COMPL1;
      VALID_COMPH1_10MHZ <= VALID_COMPH1;
      VALID_COMPL2_10MHZ <= VALID_COMPL2;
      VALID_COMPH2_10MHZ <= VALID_COMPH2;
      VALID_COMPL1_10MHZ_DEL <= VALID_COMPL1_10MHZ;
      VALID_COMPH1_10MHZ_DEL <= VALID_COMPH1_10MHZ;
      VALID_COMPL2_10MHZ_DEL <= VALID_COMPL2_10MHZ;
      VALID_COMPH2_10MHZ_DEL <= VALID_COMPH2_10MHZ;
      COMPDATA_READOUT_DONE_DEL1 <= COMPDATA_READOUT_DONE;
      COMPDATA_READOUT_DONE_DEL2 <= COMPDATA_READOUT_DONE_DEL1;
    end if;
  end process;

  -- Time over threshold counters
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL1 = '1' then
        COMPL1_COUNT <= (others => '0');
      elsif COMPL1_COUNT = "11111111111111111111111111111111" then
        COMPL1_COUNT <= COMPL1_COUNT;
      elsif COMPL1_IN_DEL1 = '1' then
        COMPL1_COUNT <= COMPL1_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH1 = '1' then
        COMPH1_COUNT <= (others => '0');
      elsif COMPH1_COUNT = "11111111111111111111111111111111" then
        COMPH1_COUNT <= COMPH1_COUNT;
      elsif COMPH1_IN_DEL1 = '1' then
        COMPH1_COUNT <= COMPH1_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL2 = '1' then
        COMPL2_COUNT <= (others => '0');
      elsif COMPL1_COUNT = "11111111111111111111111111111111" then
        COMPL2_COUNT <= COMPL2_COUNT;
      elsif COMPL2_IN_DEL1 = '1' then
        COMPL2_COUNT <= COMPL2_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH2 = '1' then
        COMPH2_COUNT <= (others => '0');
      elsif COMPL1_COUNT = "11111111111111111111111111111111" then
        COMPH2_COUNT <= COMPH2_COUNT;
      elsif COMPH2_IN_DEL1 = '1' then
        COMPH2_COUNT <= COMPH2_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;

  -- Set valid bits for comparator signals
  -- Valid on a negative edge of a COMP signal, because this is the end-time of the COMP counter
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPL1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL1 = '1' then
        VALID_COMPL1 <= '0';
      elsif COMPL1_IN_DEL1 = '0' and COMPL1_IN_DEL2 = '1' then
        VALID_COMPL1 <= '1';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPH1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH1 = '1' then
        VALID_COMPH1 <= '0';
      elsif COMPH1_IN_DEL1 = '0' and COMPH1_IN_DEL2 = '1' then
        VALID_COMPH1 <= '1';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPL2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL2 = '1' then
        VALID_COMPL2 <= '0';
      elsif COMPL2_IN_DEL1 = '0' and COMPL2_IN_DEL2 = '1' then
        VALID_COMPL2 <= '1';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH2 = '1' then
        VALID_COMPH2 <= '0';
      elsif COMPH2_IN_DEL1 = '0' and COMPH2_IN_DEL2 = '1' then
        VALID_COMPH2 <= '1';
      end if;
    end if;
  end process;

  -- Latch the time on a positive edge of a comparator signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL1_IN_DEL1 = '1' and COMPL1_IN_DEL2 = '0' then
        COMPL1_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPL1_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPL1_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPL1_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPL1_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPL1_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPL1_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPL1_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH1_IN_DEL1 = '1' and COMPH1_IN_DEL2 = '0' then
        COMPH1_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPH1_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPH1_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPH1_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPH1_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPH1_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPH1_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPH1_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL2_IN_DEL1 = '1' and COMPL2_IN_DEL2 = '0' then
        COMPL2_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPL2_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPL2_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPL2_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPL2_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPL2_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPL2_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPL2_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH2_IN_DEL1 = '1' and COMPL1_IN_DEL2 = '0' then
        COMPH2_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPH2_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPH2_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPH2_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPH2_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPH2_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPH2_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPH2_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;

  -- Output selector
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPDATA_L1 <= (others => '0');
      COMPDATA_H1 <= (others => '0');
      COMPDATA_L2 <= (others => '0');
      COMPDATA_H2 <= (others => '0');
      COMPDATA_OUT <= (others => '0');
      VALID_COMPL1_10MHZ_OUT <= '0';
      VALID_COMPH1_10MHZ_OUT <= '0';
      VALID_COMPL2_10MHZ_OUT <= '0';
      VALID_COMPH2_10MHZ_OUT <= '0';
      RST_COMPL1_10MHZ <= '0';
      RST_COMPH1_10MHZ <= '0';
      RST_COMPL2_10MHZ <= '0';
      RST_COMPH2_10MHZ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if VALID_COMPL1_10MHZ = '1' and VALID_COMPL1_10MHZ_DEL = '0' then -- at rising edge of VALID_COMPL1_10MHZ
        VALID_COMPL1_10MHZ_OUT <= '1'; -- set VALID_COMPL1_10MHZ_OUT
        COMPDATA_L1(127 downto 120) <= "00000001";
        COMPDATA_L1(119 downto 32) <= COMPL1_TIMESTAMP;
        COMPDATA_L1(31 downto 0) <= COMPL1_COUNT;
      end if;
      if VALID_COMPH1_10MHZ = '1' and VALID_COMPH1_10MHZ_DEL = '0' then -- at rising edge of VALID_COMPH1_10MHZ
        VALID_COMPH1_10MHZ_OUT <= '1'; -- set VALID_COMPL2_10MHZ_OUT
        COMPDATA_H1(127 downto 120) <= "00000010";
        COMPDATA_H1(119 downto 32) <= COMPH1_TIMESTAMP;
        COMPDATA_H1(31 downto 0) <= COMPH1_COUNT;
      end if;
      if VALID_COMPL2_10MHZ = '1' and VALID_COMPL2_10MHZ_DEL = '0' then -- at rising edge of VALID_COMPL2_10MHZ
        VALID_COMPL2_10MHZ_OUT <= '1'; -- set VALID_COMPL2_10MHZ_OUT
        COMPDATA_L2(127 downto 120) <= "00000100";
        COMPDATA_L2(119 downto 32) <= COMPL2_TIMESTAMP;
        COMPDATA_L2(31 downto 0) <= COMPL2_COUNT;
      end if;
      if VALID_COMPH2_10MHZ = '1' and VALID_COMPH2_10MHZ_DEL = '0' then -- at rising edge of VALID_COMPH2_10MHZ
        VALID_COMPH2_10MHZ_OUT <= '1'; -- set VALID_COMPH2_10MHZ_OUT
        COMPDATA_H2(127 downto 120) <= "00001000";
        COMPDATA_H2(119 downto 32) <= COMPH2_TIMESTAMP;
        COMPDATA_H2(31 downto 0) <= COMPH2_COUNT;
      end if;
      if VALID_COMPL1_10MHZ_OUT = '1' then
        COMPDATA_OUT <= COMPDATA_L1;
      elsif VALID_COMPH1_10MHZ_OUT = '1' then
        COMPDATA_OUT <= COMPDATA_H1;
      elsif VALID_COMPL2_10MHZ_OUT = '1' then
        COMPDATA_OUT <= COMPDATA_L2;
      elsif VALID_COMPH2_10MHZ_OUT = '1' then
        COMPDATA_OUT <= COMPDATA_H2;
      else
        COMPDATA_OUT <= (others => '0');
      end if;
      if COMPDATA_READOUT_DONE_DEL1 = '1' and COMPDATA_READOUT_DONE_DEL2 = '0' then
        if VALID_COMPL1_10MHZ_OUT = '1' then
          VALID_COMPL1_10MHZ_OUT <= '0';
          RST_COMPL1_10MHZ <= '1';
        elsif VALID_COMPH1_10MHZ_OUT = '1' then
          VALID_COMPH1_10MHZ_OUT <= '0';
          RST_COMPH1_10MHZ <= '1';
        elsif VALID_COMPL2_10MHZ_OUT = '1' then
          VALID_COMPL2_10MHZ_OUT <= '0';
          RST_COMPL2_10MHZ <= '1';
        elsif VALID_COMPH2_10MHZ_OUT = '1' then
          VALID_COMPH2_10MHZ_OUT <= '0';
          RST_COMPH2_10MHZ <= '1';
        end if;
      else
        RST_COMPL1_10MHZ <= '0';
        RST_COMPH1_10MHZ <= '0';
        RST_COMPL2_10MHZ <= '0';
        RST_COMPH2_10MHZ <= '0';
      end if;
    end if;
  end process;

  COMPDATA_VALID_OUT <= VALID_COMPL1_10MHZ_OUT or VALID_COMPH1_10MHZ_OUT or VALID_COMPL2_10MHZ_OUT or VALID_COMPH2_10MHZ_OUT;

end architecture a0 ; -- of GPS_STUFF

--------------------------------------------------------------------------------
-- Object        : Entity design.READOUT_TIMED_OUT
-- Last modified : Fri Jan 21 11:33:37 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity READOUT_TIMED_OUT is
  port(
    CLK10MHz          : in     std_logic;
    ONE_PPS           : in     std_logic;
    TIME_OUT_RESET    : out    std_logic;
    USB_RXF           : in     std_logic;
    USB_TXE           : in     std_logic;
    USB_WRITE_REQUEST : in     std_logic;
    nSYSRST           : in     std_logic);
end entity READOUT_TIMED_OUT;

--------------------------------------------------------------------------------
-- Object        : Architecture design.READOUT_TIMED_OUT.a0
-- Last modified : Fri Jan 21 11:33:37 2011.
--------------------------------------------------------------------------------


architecture a0 of READOUT_TIMED_OUT is

signal TIME_OUT_COUNT: std_logic_vector(3 downto 0); 
signal USB_TXE_DEL1: std_logic ; 
signal USB_TXE_DEL2: std_logic ; 
signal USB_RXF_DEL1: std_logic ; 
signal USB_RXF_DEL2: std_logic ; 
signal ONE_PPS_DEL1: std_logic ; 
signal ONE_PPS_DEL2: std_logic ; 


begin

  TIME_OUT_RESET <= TIME_OUT_COUNT(3);

  process(CLK10MHz,nSYSRST)
  begin
    if nSYSRST = '0' then
      USB_TXE_DEL1 <= '0';
      USB_TXE_DEL2 <= '0';
      USB_RXF_DEL1 <= '0';
      USB_RXF_DEL2 <= '0';
      ONE_PPS_DEL1 <= '0';
      ONE_PPS_DEL2 <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      USB_TXE_DEL1 <= USB_TXE;
      USB_TXE_DEL2 <= USB_TXE_DEL1;
      USB_RXF_DEL1 <= USB_RXF;
      USB_RXF_DEL2 <= USB_RXF_DEL1;
      ONE_PPS_DEL1 <= ONE_PPS;
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;
    end if;
  end process;

  process(CLK10MHz,nSYSRST)
  begin
    if nSYSRST = '0' then
      TIME_OUT_COUNT <= "0000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (USB_TXE_DEL1 = '0' and USB_TXE_DEL2 = '1') or (USB_RXF_DEL1 = '0' and USB_RXF_DEL2 = '1') then
        -- at falling edge of TXE or falling edge of RXF
        TIME_OUT_COUNT <= "0000";           -- reset counter
      elsif TIME_OUT_COUNT = "1000" then    -- after 8 seconds no TXE
        TIME_OUT_COUNT <= TIME_OUT_COUNT;   -- latch countvalue 8
      elsif USB_WRITE_REQUEST = '1' then
        if ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then
          -- at rising edge of PPS
          TIME_OUT_COUNT <= TIME_OUT_COUNT + "0001"; -- increase counter
        end if;
      end if;
    end if;
  end process;

end architecture a0 ; -- of READOUT_TIMED_OUT

--------------------------------------------------------------------------------
-- Object        : Entity design.USB_READ_HANDLER
-- Last modified : Mon Feb 27 11:40:51 2012.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity USB_READ_HANDLER is
  port(
    ADC_A0                      : out    std_logic;
    ADC_A1                      : out    std_logic;
    ADC_DATA_IN                 : in     std_logic_vector(7 downto 0);
    ADC_MODE                    : out    std_logic;
    ADC_nCS                     : out    std_logic;
    ADC_nINT                    : in     std_logic;
    ADC_nRD                     : out    std_logic;
    ADC_nWR_RDY                 : in     std_logic;
    CLK10MHz                    : in     std_logic;
    CLKRD                       : in     std_logic;
    COINC_TIME                  : out    integer range 1000 downto 0;
    COINC_TIME_OUT              : out    std_logic_vector(15 downto 0);
    DAC_A0                      : out    std_logic;
    DAC_A1                      : out    std_logic;
    DAC_A2                      : out    std_logic;
    DAC_DATA_0                  : out    std_logic;
    DAC_DATA_1                  : out    std_logic;
    DAC_DATA_2                  : out    std_logic;
    DAC_DATA_3                  : out    std_logic;
    DAC_DATA_4                  : out    std_logic;
    DAC_DATA_5                  : out    std_logic;
    DAC_DATA_6                  : out    std_logic;
    DAC_DATA_7                  : out    std_logic;
    DAC_nCLR                    : out    std_logic;
    DAC_nCS1                    : out    std_logic;
    DAC_nCS2                    : out    std_logic;
    DAC_nLDAC                   : out    std_logic;
    DAC_nRD                     : out    std_logic;
    DAC_nWR                     : out    std_logic;
    ERROR_READ_OUT              : out    std_logic;
    FAKE_DATA                   : out    std_logic;
    FORCE_MASTER                : out    std_logic;
    GPS_FLAGS                   : in     std_logic_vector(7 downto 0);
    GPS_PROG_ENABLE             : out    std_logic;
    MASTER                      : in     std_logic;
    ONE_PPS                     : in     std_logic;
    PARAMETER_LIST              : out    std_logic_vector(271 downto 0);
    PARAMETER_LIST_READOUT_DONE : in     std_logic;
    PARAMETER_LIST_VALID        : out    std_logic;
    POST_TIME                   : out    integer range 1600 downto 0;
    POST_TIME_OUT               : out    std_logic_vector(15 downto 0);
    PRE_TIME_OUT                : out    std_logic_vector(15 downto 0);
    READ_BUSY_OUT               : out    std_logic;
    READ_ERROR_DATA             : out    std_logic_vector(7 downto 0);
    READ_ERROR_READOUT_DONE     : in     std_logic;
    READ_ERROR_VALID            : out    std_logic;
    SECOND_MESSAGE_ALLOWED      : out    std_logic;
    SERIAL_NUMBER               : in     std_logic_vector(9 downto 0);
    SLAVE_PRESENT               : in     std_logic;
    SOFT_RESET                  : out    std_logic;
    STOP_READ_OUT               : out    std_logic;
    SYSRST                      : in     std_logic;
    THH1                        : out    std_logic_vector(11 downto 0);
    THH2                        : out    std_logic_vector(11 downto 0);
    THL1                        : out    std_logic_vector(11 downto 0);
    THL2                        : out    std_logic_vector(11 downto 0);
    TOTAL_TIME                  : out    integer range 2000 downto 0;
    TOTAL_TIME_3X               : out    integer range 6000 downto 0;
    TR_CONDITION                : out    std_logic_vector(7 downto 0);
    USB_DATA_IN                 : in     std_logic_vector(7 downto 0);
    USB_RD                      : out    std_logic;
    USB_RXF                     : in     std_logic;
    USB_WRITE_BUSY              : in     std_logic;
    USB_WRITE_ENABLE            : out    std_logic;
    USB_WRITE_REQUEST           : in     std_logic);
end entity USB_READ_HANDLER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.USB_READ_HANDLER.a0
-- Last modified : Mon Feb 27 11:40:51 2012.
--------------------------------------------------------------------------------


architecture a0 of USB_READ_HANDLER is

signal PRE_TIME_SET:   integer range  400 downto 0 :=  200;
        -- The maximum PRE_TIME_SET can be 2 us. This are 400 steps of 5 ns.
signal COINC_TIME_SET: integer range 1000 downto 0 :=  400;
        -- The maximum COINC_TIME_SET can be 5 us. This are 1000 steps of 5 ns.
signal POST_TIME_SET:  integer range 1600 downto 0 :=  400;
        -- The maximum POST_TIME_SET can be 8 us. This are 1600 steps of 5 ns.
signal TOTAL_TIME_TMP: integer range 2000 downto 0 := 1000;
        -- The maximum TOTAL_TIME can be 10 us. This are 2000 steps of 5 ns.
signal PRE_TIME_LOAD: std_logic_vector(15 downto 0);
signal COINC_TIME_LOAD: std_logic_vector(15 downto 0);
signal POST_TIME_LOAD: std_logic_vector(15 downto 0);
signal PRE_TIME_TMP: std_logic_vector(15 downto 0);
signal COINC_TIME_TMP: std_logic_vector(15 downto 0);
signal POST_TIME_TMP: std_logic_vector(15 downto 0);
signal PRE_TIME_TMP2: std_logic_vector(15 downto 0);
signal COINC_TIME_TMP2: std_logic_vector(15 downto 0);

signal CH1_OFFSET_ADJ_POS: std_logic_vector(7 downto 0);
signal CH1_OFFSET_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_OFFSET_ADJ_POS: std_logic;
signal CLR_CH1_OFFSET_ADJ_POS: std_logic;

signal CH1_OFFSET_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH1_OFFSET_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_OFFSET_ADJ_NEG: std_logic;
signal CLR_CH1_OFFSET_ADJ_NEG: std_logic;

signal CH2_OFFSET_ADJ_POS: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_OFFSET_ADJ_POS: std_logic;
signal CLR_CH2_OFFSET_ADJ_POS: std_logic;

signal CH2_OFFSET_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_OFFSET_ADJ_NEG: std_logic;
signal CLR_CH2_OFFSET_ADJ_NEG: std_logic;

signal CH1_GAIN_ADJ_POS: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_GAIN_ADJ_POS: std_logic;
signal CLR_CH1_GAIN_ADJ_POS: std_logic;

signal CH1_GAIN_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_GAIN_ADJ_NEG: std_logic;
signal CLR_CH1_GAIN_ADJ_NEG: std_logic;

signal CH2_GAIN_ADJ_POS: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_GAIN_ADJ_POS: std_logic;
signal CLR_CH2_GAIN_ADJ_POS: std_logic;

signal CH2_GAIN_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_GAIN_ADJ_NEG: std_logic;
signal CLR_CH2_GAIN_ADJ_NEG: std_logic;

signal COMMON_OFFSET_ADJ: std_logic_vector(7 downto 0);
signal COMMON_OFFSET_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_COMMON_OFFSET_ADJ: std_logic;
signal CLR_COMMON_OFFSET_ADJ: std_logic;

signal FULL_SCALE_ADJ: std_logic_vector(7 downto 0);
signal FULL_SCALE_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_FULL_SCALE_ADJ: std_logic;
signal CLR_FULL_SCALE_ADJ: std_logic;

signal CH1_INTEGRATOR: std_logic_vector(7 downto 0);
signal CH1_INTEGRATOR_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_INTEGRATOR: std_logic;
signal CLR_CH1_INTEGRATOR: std_logic;

signal CH2_INTEGRATOR: std_logic_vector(7 downto 0);
signal CH2_INTEGRATOR_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_INTEGRATOR: std_logic;
signal CLR_CH2_INTEGRATOR: std_logic;

signal COMP_THRES_LOW: std_logic_vector(7 downto 0);
signal COMP_THRES_LOW_DEL: std_logic_vector(7 downto 0);
signal SET_COMP_THRES_LOW: std_logic;
signal CLR_COMP_THRES_LOW: std_logic;

signal COMP_THRES_HIGH: std_logic_vector(7 downto 0);
signal COMP_THRES_HIGH_DEL: std_logic_vector(7 downto 0);
signal SET_COMP_THRES_HIGH: std_logic;
signal CLR_COMP_THRES_HIGH: std_logic;

signal CH1_PMT_HV_ADJ: std_logic_vector(7 downto 0);
signal CH1_PMT_HV_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_PMT_HV_ADJ: std_logic;
signal CLR_CH1_PMT_HV_ADJ: std_logic;

signal CH2_PMT_HV_ADJ: std_logic_vector(7 downto 0);
signal CH2_PMT_HV_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_PMT_HV_ADJ: std_logic;
signal CLR_CH2_PMT_HV_ADJ: std_logic;

signal CH1_THRES_LOW: std_logic_vector(15 downto 0);
signal CH1_THRES_HIGH: std_logic_vector(15 downto 0);
signal CH2_THRES_LOW: std_logic_vector(15 downto 0);
signal CH2_THRES_HIGH: std_logic_vector(15 downto 0);

signal SPARE_BYTES: std_logic_vector(31 downto 0);

signal CH1_PMT_SUPPLY_CURR: std_logic_vector(7 downto 0);
signal CH2_PMT_SUPPLY_CURR: std_logic_vector(7 downto 0);
signal STATUS: std_logic_vector(7 downto 0);
signal VERSION: std_logic_vector(23 downto 0);
signal SOFTWARE_VERSION: std_logic_vector(7 downto 0);
signal CHANGE_MS_STATE: std_logic;
signal FORCE_MASTER_TMP: std_logic;

signal WRITE_PARAMETER_LIST: std_logic;
signal WRITE_PARAMETER_LIST_DEL: std_logic;
signal PARAMETER_LIST_READOUT_DONE_DEL1: std_logic;
signal READ_ERROR: std_logic;
signal READ_ERROR_READOUT_DONE_DEL1: std_logic;

signal USB_READ_BUSY: std_logic;
signal USB_WRITE_ENABLE_TMP: std_logic;
signal USB_WRITE_ALLOWED: std_logic; -- Least significant bit of SPARE_BYTES and controlled by LabView to enable writing to PC
signal STOP_READING: std_logic;
signal USB_WRITE_BUSY_DEL1: std_logic; -- to detect the falling edge of USB_WRITE_BUSY
signal USB_WRITE_BUSY_DEL2: std_logic;
signal USB_WRITE_BUSY_DEL3: std_logic;
signal USB_WRITE_BUSY_DEL4: std_logic;
signal USB_WRITE_BUSY_DEL5: std_logic;

signal CH1_OFFSET_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH1_OFFSET_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal COMMON_OFFSET_ADJ_TMP: std_logic_vector(7 downto 0);
signal FULL_SCALE_ADJ_TMP: std_logic_vector(7 downto 0);
signal CH1_INTEGRATOR_TMP: std_logic_vector(7 downto 0);
signal CH2_INTEGRATOR_TMP: std_logic_vector(7 downto 0);
signal COMP_THRES_LOW_TMP: std_logic_vector(7 downto 0);
signal COMP_THRES_HIGH_TMP: std_logic_vector(7 downto 0);
signal CH1_PMT_HV_ADJ_TMP: std_logic_vector(7 downto 0);
signal CH2_PMT_HV_ADJ_TMP: std_logic_vector(7 downto 0);
signal CH1_THRES_LOW_TMP: std_logic_vector(15 downto 0);
signal CH1_THRES_HIGH_TMP: std_logic_vector(15 downto 0);
signal CH2_THRES_LOW_TMP: std_logic_vector(15 downto 0);
signal CH2_THRES_HIGH_TMP: std_logic_vector(15 downto 0);
signal TR_CONDITION_TMP: std_logic_vector(7 downto 0);
signal PRE_TIME_LOAD_TMP: std_logic_vector(15 downto 0);
signal COINC_TIME_LOAD_TMP: std_logic_vector(15 downto 0);
signal POST_TIME_LOAD_TMP: std_logic_vector(15 downto 0);
signal SPARE_BYTES_TMP: std_logic_vector(31 downto 0);

signal RD_TMP: std_logic;
signal READ_COUNT: integer range 40 downto 0; -- Send message can be maximum 38 bytes (1 extra for error notification)
signal READ_ID: std_logic_vector(7 downto 0);
signal TIME_OUT_COUNT: std_logic_vector(23 downto 0); --Counts 1 s when read busy hangs

signal PRELOAD_DACS: std_logic;
signal PRELOAD_DACS_DEL1: std_logic;
signal PRELOAD_DACS_DEL2: std_logic;
signal PRELOAD_DAC_COUNT: std_logic_vector(2 downto 0);
signal WR_DACS: std_logic;
signal DAC_DATA_OUT: std_logic_vector(7 downto 0);

signal ONE_PPS_DEL1: std_logic;
signal ONE_PPS_DEL2: std_logic;
signal SET_CURR_ADC: std_logic;
signal CLR_CURR_ADC: std_logic;
signal CURR_ADC_COUNT: integer range 75 downto 0;

begin

  USB_WRITE_ALLOWED <= SPARE_BYTES(0);
  SECOND_MESSAGE_ALLOWED <= SPARE_BYTES(1);
--  GPS_PROG_ENABLE <= SPARE_BYTES(2);
  GPS_PROG_ENABLE <= '1';
  CHANGE_MS_STATE <= SPARE_BYTES(3);
  FAKE_DATA <= SPARE_BYTES(4);
  FORCE_MASTER <= FORCE_MASTER_TMP;
  FORCE_MASTER_TMP <= MASTER when CHANGE_MS_STATE = '0' else not MASTER;

  STATUS(5 downto 3) <= "000";
  STATUS(7)	<= GPS_FLAGS(0);
  STATUS(6)	<= GPS_FLAGS(1);
  STATUS(2) <= USB_WRITE_ALLOWED;
  STATUS(1) <= SLAVE_PRESENT;
  STATUS(0) <= FORCE_MASTER_TMP;
  SOFTWARE_VERSION <= "00010010";
  VERSION(23 downto 16) <= SOFTWARE_VERSION;
  VERSION(15 downto 10) <= "000000";
  VERSION(9) <= not SERIAL_NUMBER(9);
  VERSION(8) <= not SERIAL_NUMBER(8);
  VERSION(7) <= not SERIAL_NUMBER(7);
  VERSION(6) <= not SERIAL_NUMBER(6);
  VERSION(5) <= not SERIAL_NUMBER(5);
  VERSION(4) <= not SERIAL_NUMBER(4);
  VERSION(3) <= not SERIAL_NUMBER(3);
  VERSION(2) <= not SERIAL_NUMBER(2);
  VERSION(1) <= not SERIAL_NUMBER(1);
  VERSION(0) <= not SERIAL_NUMBER(0);
  THL1 <= CH1_THRES_LOW(11 downto 0);
  THH1 <= CH1_THRES_HIGH(11 downto 0);
  THL2 <= CH2_THRES_LOW(11 downto 0);
  THH2 <= CH2_THRES_HIGH(11 downto 0);
  PRE_TIME_OUT <= PRE_TIME_TMP;
  COINC_TIME_OUT <= COINC_TIME_TMP;
  POST_TIME_OUT <= POST_TIME_TMP;
  PRE_TIME_SET <= to_integer(unsigned(PRE_TIME_TMP2)) ;
  POST_TIME_SET <= to_integer(unsigned(POST_TIME_TMP)) ;
  COINC_TIME_SET <= to_integer(unsigned(COINC_TIME_TMP2)) ;
  COINC_TIME <= COINC_TIME_SET;
  POST_TIME <= POST_TIME_SET;
  TOTAL_TIME <= TOTAL_TIME_TMP;
  TOTAL_TIME_3X <= TOTAL_TIME_TMP + TOTAL_TIME_TMP + TOTAL_TIME_TMP;
  ADC_MODE <= '0';
  ADC_nCS <= '0';
  ADC_A1 <= '0';

  USB_WRITE_ENABLE <= USB_WRITE_ENABLE_TMP;
  READ_BUSY_OUT <= USB_READ_BUSY;
  STOP_READ_OUT <= STOP_READING;
  ERROR_READ_OUT <= READ_ERROR;

  process(CLK10MHz, SYSRST)
  begin
    if (SYSRST = '1') then
      PRE_TIME_TMP    <= "0000000011001000"; -- xc8= 200.
      PRE_TIME_TMP2   <= "0000000011001000";
      COINC_TIME_TMP  <= "0000000110010000"; --x190= 400.
      COINC_TIME_TMP2 <= "0000000110010000";
      POST_TIME_TMP   <= "0000000110010000"; --x190= 400.
      TOTAL_TIME_TMP  <= 1000;               --x3e8=1000.
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if PRE_TIME_LOAD <= "0000000110010000" then -- 400
        PRE_TIME_TMP <= PRE_TIME_LOAD;
      else
        PRE_TIME_TMP <= "0000000110010000";
      end if;
      if COINC_TIME_LOAD <= "0000001111101000" then -- 1000
        COINC_TIME_TMP <= COINC_TIME_LOAD;
      else
        COINC_TIME_TMP <= "0000001111101000";
      end if;

      PRE_TIME_TMP2 <= PRE_TIME_TMP;
      COINC_TIME_TMP2 <= COINC_TIME_TMP;

--      if FORCE_MASTER_TMP = '1' then
--        PRE_TIME_TMP2 <= PRE_TIME_TMP;
--        COINC_TIME_TMP2 <= COINC_TIME_TMP;
--      else--        PRE_TIME_TMP2 <= PRE_TIME_TMP + "0000000000000100"; -- When a module is a slave, the timing needs a 20ns correction
--        COINC_TIME_TMP2 <= COINC_TIME_TMP - "0000000000000100";
--      end if;

      if POST_TIME_LOAD + PRE_TIME_TMP2 + COINC_TIME_TMP2 > "0000011111010000" then -- 2000
        POST_TIME_TMP <= "0000011111010000" - PRE_TIME_TMP2 - COINC_TIME_TMP2;
      elsif POST_TIME_LOAD <= "0000011001000000" then -- 1600
        POST_TIME_TMP <= POST_TIME_LOAD;
      else
        POST_TIME_TMP <= "0000011001000000";
      end if;
      TOTAL_TIME_TMP <= PRE_TIME_SET + COINC_TIME_SET + POST_TIME_SET;
    end if;
  end process;

  PARAMETER_LIST(7 downto 0) <= CH1_OFFSET_ADJ_POS;
  PARAMETER_LIST(15 downto 8) <= CH1_OFFSET_ADJ_NEG;
  PARAMETER_LIST(23 downto 16) <= CH2_OFFSET_ADJ_POS;
  PARAMETER_LIST(31 downto 24) <= CH2_OFFSET_ADJ_NEG;
  PARAMETER_LIST(39 downto 32) <= CH1_GAIN_ADJ_POS;
  PARAMETER_LIST(47 downto 40) <= CH1_GAIN_ADJ_NEG;
  PARAMETER_LIST(55 downto 48) <= CH2_GAIN_ADJ_POS;
  PARAMETER_LIST(63 downto 56) <= CH2_GAIN_ADJ_NEG;
  PARAMETER_LIST(71 downto 64) <= COMMON_OFFSET_ADJ;
  PARAMETER_LIST(79 downto 72) <= FULL_SCALE_ADJ;
  PARAMETER_LIST(87 downto 80) <= CH1_INTEGRATOR;
  PARAMETER_LIST(95 downto 88) <= CH2_INTEGRATOR;
  PARAMETER_LIST(103 downto 96) <= COMP_THRES_LOW;
  PARAMETER_LIST(111 downto 104) <= COMP_THRES_HIGH;
  PARAMETER_LIST(119 downto 112) <= CH1_PMT_HV_ADJ;
  PARAMETER_LIST(127 downto 120) <= CH2_PMT_HV_ADJ;
  PARAMETER_LIST(143 downto 128) <= CH1_THRES_LOW;
  PARAMETER_LIST(159 downto 144) <= CH1_THRES_HIGH;
  PARAMETER_LIST(175 downto 160) <= CH2_THRES_LOW;
  PARAMETER_LIST(191 downto 176) <= CH2_THRES_HIGH;
  PARAMETER_LIST(199 downto 192) <= STATUS;
  PARAMETER_LIST(231 downto 200) <= SPARE_BYTES;
  PARAMETER_LIST(239 downto 232) <= CH1_PMT_SUPPLY_CURR;
  PARAMETER_LIST(247 downto 240) <= CH2_PMT_SUPPLY_CURR;
  PARAMETER_LIST(271 downto 248) <= VERSION;

  --USB_WRITE_ENABLE <= not USB_READ_ENABLE;
  USB_RD <= RD_TMP;
  DAC_nWR <= WR_DACS;
  DAC_nLDAC <= '0';
  DAC_nCLR <= '1';
  DAC_nRD <= '1';
  DAC_DATA_0 <= DAC_DATA_OUT(0);
  DAC_DATA_1 <= DAC_DATA_OUT(1);
  DAC_DATA_2 <= DAC_DATA_OUT(2);
  DAC_DATA_3 <= DAC_DATA_OUT(3);
  DAC_DATA_4 <= DAC_DATA_OUT(4);
  DAC_DATA_5 <= DAC_DATA_OUT(5);
  DAC_DATA_6 <= DAC_DATA_OUT(6);
  DAC_DATA_7 <= DAC_DATA_OUT(7);

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      PRELOAD_DACS_DEL1 <= '0';
      PRELOAD_DACS_DEL2 <= '0';
      CH1_OFFSET_ADJ_POS_DEL <= "00000000";
      CH1_OFFSET_ADJ_NEG_DEL <= "00000000";
      CH2_OFFSET_ADJ_POS_DEL <= "00000000";
      CH2_OFFSET_ADJ_NEG_DEL <= "00000000";
      CH1_GAIN_ADJ_POS_DEL <= "00000000";
      CH1_GAIN_ADJ_NEG_DEL <= "00000000";
      CH2_GAIN_ADJ_POS_DEL <= "00000000";
      CH2_GAIN_ADJ_NEG_DEL <= "00000000";
      COMMON_OFFSET_ADJ_DEL <= "00000000";
      FULL_SCALE_ADJ_DEL <= "00000000";
      CH1_INTEGRATOR_DEL <= "00000000";
      CH2_INTEGRATOR_DEL <= "00000000";
      COMP_THRES_LOW_DEL <= "00000000";
      COMP_THRES_HIGH_DEL <= "00000000";
      CH1_PMT_HV_ADJ_DEL <= "00000000";
      CH2_PMT_HV_ADJ_DEL <= "00000000";
      ONE_PPS_DEL1 <= '0';
      ONE_PPS_DEL2 <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      PRELOAD_DACS_DEL1 <= PRELOAD_DACS;
      PRELOAD_DACS_DEL2 <= PRELOAD_DACS_DEL1;
      CH1_OFFSET_ADJ_POS_DEL <= CH1_OFFSET_ADJ_POS;
      CH1_OFFSET_ADJ_NEG_DEL <= CH1_OFFSET_ADJ_NEG;
      CH2_OFFSET_ADJ_POS_DEL <= CH2_OFFSET_ADJ_POS;
      CH2_OFFSET_ADJ_NEG_DEL <= CH2_OFFSET_ADJ_NEG;
      CH1_GAIN_ADJ_POS_DEL <= CH1_GAIN_ADJ_POS;
      CH1_GAIN_ADJ_NEG_DEL <= CH1_GAIN_ADJ_NEG;
      CH2_GAIN_ADJ_POS_DEL <= CH2_GAIN_ADJ_POS;
      CH2_GAIN_ADJ_NEG_DEL <= CH2_GAIN_ADJ_NEG;
      COMMON_OFFSET_ADJ_DEL <= COMMON_OFFSET_ADJ;
      FULL_SCALE_ADJ_DEL <= FULL_SCALE_ADJ;
      CH1_INTEGRATOR_DEL <= CH1_INTEGRATOR;
      CH2_INTEGRATOR_DEL <= CH2_INTEGRATOR;
      COMP_THRES_LOW_DEL <= COMP_THRES_LOW;
      COMP_THRES_HIGH_DEL <= COMP_THRES_HIGH;
      CH1_PMT_HV_ADJ_DEL <= CH1_PMT_HV_ADJ;
      CH2_PMT_HV_ADJ_DEL <= CH2_PMT_HV_ADJ;
      ONE_PPS_DEL1 <= ONE_PPS;
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_PARAMETER_LIST_DEL <= '0';
      PARAMETER_LIST_READOUT_DONE_DEL1 <= '0';
      READ_ERROR_READOUT_DONE_DEL1 <= '0';
      USB_WRITE_BUSY_DEL1 <= '0';
      USB_WRITE_BUSY_DEL2 <= '0';
      USB_WRITE_BUSY_DEL3 <= '0';
      USB_WRITE_BUSY_DEL4 <= '0';
      USB_WRITE_BUSY_DEL5 <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      WRITE_PARAMETER_LIST_DEL <= WRITE_PARAMETER_LIST;
      PARAMETER_LIST_READOUT_DONE_DEL1 <= PARAMETER_LIST_READOUT_DONE;
      READ_ERROR_READOUT_DONE_DEL1 <= READ_ERROR_READOUT_DONE;
      USB_WRITE_BUSY_DEL1 <= USB_WRITE_BUSY;
      USB_WRITE_BUSY_DEL2 <= USB_WRITE_BUSY_DEL1;
      USB_WRITE_BUSY_DEL3 <= USB_WRITE_BUSY_DEL2;
      USB_WRITE_BUSY_DEL4 <= USB_WRITE_BUSY_DEL3;
      USB_WRITE_BUSY_DEL5 <= USB_WRITE_BUSY_DEL4;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      PARAMETER_LIST_VALID <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WRITE_PARAMETER_LIST = '1' and WRITE_PARAMETER_LIST_DEL = '0' then
        PARAMETER_LIST_VALID <= '1';
      elsif PARAMETER_LIST_READOUT_DONE = '1' and PARAMETER_LIST_READOUT_DONE_DEL1 = '0' then
        PARAMETER_LIST_VALID <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      READ_ERROR_VALID <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if READ_ERROR = '1' then
        READ_ERROR_VALID <= '1';
      elsif READ_ERROR_READOUT_DONE = '1' and READ_ERROR_READOUT_DONE_DEL1 = '0' then
        READ_ERROR_VALID <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      USB_WRITE_ENABLE_TMP <= '0'; -- Default (on power up) USB is in read mode
      USB_READ_BUSY <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if STOP_READING = '1' or READ_ERROR = '1' then -- on stop or error, reset USB_READ_BUSY
        USB_READ_BUSY <= '0';
      elsif USB_WRITE_BUSY_DEL4 = '0' and USB_WRITE_BUSY_DEL5 = '1' then -- on falling edge of USB_WRITE_BUSY, reset USB_WRITE_ENABLE
        USB_WRITE_ENABLE_TMP <= '0';
      elsif USB_WRITE_ENABLE_TMP = '1' or USB_READ_BUSY = '1' then -- if writing or reading is busy then do nothing
        USB_READ_BUSY <= USB_READ_BUSY;
        USB_WRITE_ENABLE_TMP <= USB_WRITE_ENABLE_TMP;
      elsif USB_READ_BUSY = '0' and USB_RXF = '0' then -- reading has first priority; USB_RXF = '0' when there is data to readout
        USB_READ_BUSY <= '1';
      elsif USB_WRITE_ENABLE_TMP = '0' and USB_WRITE_REQUEST = '1' and USB_WRITE_ALLOWED = '1' then
        USB_WRITE_ENABLE_TMP <= '1';
      else
        USB_READ_BUSY <= '0';
        USB_WRITE_ENABLE_TMP <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST,READ_ID,USB_DATA_IN)
  begin
    if SYSRST = '1' then
      RD_TMP <= '1';
      READ_COUNT <= 0;
      READ_ID <= (others => '0');
      READ_ERROR <= '0';
      READ_ERROR_DATA <= (others => '0');
      STOP_READING <= '0';
      TIME_OUT_COUNT <= (others => '0');
      CH1_OFFSET_ADJ_POS_TMP <= (others => '0');
      CH1_OFFSET_ADJ_NEG_TMP <= (others => '0');
      CH2_OFFSET_ADJ_POS_TMP <= (others => '0');
      CH2_OFFSET_ADJ_NEG_TMP <= (others => '0');
      CH1_GAIN_ADJ_POS_TMP <= (others => '0');
      CH1_GAIN_ADJ_NEG_TMP <= (others => '0');
      CH2_GAIN_ADJ_POS_TMP <= (others => '0');
      CH2_GAIN_ADJ_NEG_TMP <= (others => '0');
      COMMON_OFFSET_ADJ_TMP <= (others => '0');
      FULL_SCALE_ADJ_TMP <= (others => '0');
      CH1_INTEGRATOR_TMP <= (others => '0');
      CH2_INTEGRATOR_TMP <= (others => '0');
      COMP_THRES_LOW_TMP <= (others => '0');
      COMP_THRES_HIGH_TMP <= (others => '0');
      CH1_PMT_HV_ADJ_TMP <= (others => '0');
      CH2_PMT_HV_ADJ_TMP <= (others => '0');
      CH1_THRES_LOW_TMP <= (others => '0');
      CH1_THRES_HIGH_TMP <= (others => '0');
      CH2_THRES_LOW_TMP <= (others => '0');
      CH2_THRES_HIGH_TMP <= (others => '0');
      TR_CONDITION_TMP <= "01000000"; --(others => '0');
      PRE_TIME_LOAD_TMP <= (others => '0');
      COINC_TIME_LOAD_TMP <= (others => '0');
      POST_TIME_LOAD_TMP <= (others => '0');
      SPARE_BYTES_TMP <= (others => '0');
      CH1_OFFSET_ADJ_POS <= "10000000";
      CH1_OFFSET_ADJ_NEG <= "10000000";
      CH2_OFFSET_ADJ_POS <= "10000000";
      CH2_OFFSET_ADJ_NEG <= "10000000";
      CH1_GAIN_ADJ_POS <= "10000000";
      CH1_GAIN_ADJ_NEG <= "10000000";
      CH2_GAIN_ADJ_POS <= "10000000";
      CH2_GAIN_ADJ_NEG <= "10000000";
      COMMON_OFFSET_ADJ <= "00000000";
      FULL_SCALE_ADJ <= "00000000";
      CH1_INTEGRATOR <= "11111111";
      CH2_INTEGRATOR <= "11111111";
      COMP_THRES_LOW <= "01011000";
      COMP_THRES_HIGH <= "11100110";
      CH1_PMT_HV_ADJ <= "00000000";
      CH2_PMT_HV_ADJ <= "00000000";
      CH1_THRES_LOW <= "0000000100000000";
      CH1_THRES_HIGH <= "0000100000000000";
      CH2_THRES_LOW <= "0000000100000000";
      CH2_THRES_HIGH <= "0000100000000000";
      TR_CONDITION <= "00001000";
      PRE_TIME_LOAD <= "0000000011001000";
      COINC_TIME_LOAD <= "0000000110010000";
      POST_TIME_LOAD <= "0000000110010000";
      SPARE_BYTES <= (others => '0');
      WRITE_PARAMETER_LIST <= '0';
      SOFT_RESET <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if USB_READ_BUSY = '1' and READ_ERROR = '0' and STOP_READING = '0' then
        TIME_OUT_COUNT <= TIME_OUT_COUNT + "000000000000000000000001"; -- counts 1s if reading hangs
        if TIME_OUT_COUNT(23) = '1' then
          READ_ERROR <= '1';
          READ_ERROR_DATA <= "11111111"; -- Timed out
        elsif USB_RXF = '0' then
          if RD_TMP = '1' then
            RD_TMP <= '0';
          else
            RD_TMP <= '1';
            if READ_COUNT = 0 then -- wait for startbyte 99h
              if USB_DATA_IN = "10011001" then -- if there is a startbyte
                READ_COUNT <= READ_COUNT + 1; -- count the startbyte
              else -- if there is no startbyte
                READ_ERROR <= '1';
                READ_ERROR_DATA <= "10011001"; -- Missing start byte
              end if;
            elsif READ_COUNT = 1 then -- get ID
              if USB_DATA_IN = "00010000" or USB_DATA_IN = "00010001" or USB_DATA_IN = "00010010" or USB_DATA_IN = "00010011"
              or USB_DATA_IN = "00010100" or USB_DATA_IN = "00010101" or USB_DATA_IN = "00010110" or USB_DATA_IN = "00010111"
              or USB_DATA_IN = "00011000" or USB_DATA_IN = "00011001" or USB_DATA_IN = "00011010" or USB_DATA_IN = "00011011"
              or USB_DATA_IN = "00011100" or USB_DATA_IN = "00011101" or USB_DATA_IN = "00011110" or USB_DATA_IN = "00011111"
              or USB_DATA_IN = "00100000" or USB_DATA_IN = "00100001" or USB_DATA_IN = "00100010" or USB_DATA_IN = "00100011"
              or USB_DATA_IN = "00110000" or USB_DATA_IN = "00110001" or USB_DATA_IN = "00110010" or USB_DATA_IN = "00110011"
              or USB_DATA_IN = "00110101"
              or USB_DATA_IN = "01000000" or USB_DATA_IN = "01000001" or USB_DATA_IN = "01000010" or USB_DATA_IN = "01000011"
              or USB_DATA_IN = "01000100" or USB_DATA_IN = "01000101" or USB_DATA_IN = "01000110" or USB_DATA_IN = "01000111"
              or USB_DATA_IN = "01010000" or USB_DATA_IN = "01010101" or USB_DATA_IN = "10001000" or USB_DATA_IN = "11111111" then -- if there is a valid ID
                READ_COUNT <= READ_COUNT + 1; -- count the ID byte
                READ_ID <= USB_DATA_IN;
              else -- if there is no valid ID
                READ_ERROR <= '1';
                READ_ERROR_DATA <= "10001001"; -- Wrong ID 89h
              end if;
            elsif READ_COUNT = 2 then -- get first data byte or end byte
              READ_COUNT <= READ_COUNT + 1;
              if READ_ID = "01010101" then
                if USB_DATA_IN = "01100110" then
                  WRITE_PARAMETER_LIST <= '1';
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "11111111" then
                if USB_DATA_IN = "01100110" then
                  SOFT_RESET <= '1';
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              case (READ_ID) is
                when "00010000" => CH1_OFFSET_ADJ_POS_TMP <= USB_DATA_IN;
                when "00010001" => CH1_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN;
                when "00010010" => CH2_OFFSET_ADJ_POS_TMP <= USB_DATA_IN;
                when "00010011" => CH2_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN;
                when "00010100" => CH1_GAIN_ADJ_POS_TMP <= USB_DATA_IN;
                when "00010101" => CH1_GAIN_ADJ_NEG_TMP <= USB_DATA_IN;
                when "00010110" => CH2_GAIN_ADJ_POS_TMP <= USB_DATA_IN;
                when "00010111" => CH2_GAIN_ADJ_NEG_TMP <= USB_DATA_IN;
                when "00011000" => COMMON_OFFSET_ADJ_TMP <= USB_DATA_IN;
                when "00011001" => FULL_SCALE_ADJ_TMP <= USB_DATA_IN;
                when "00011010" => CH1_INTEGRATOR_TMP <= USB_DATA_IN;
                when "00011011" => CH2_INTEGRATOR_TMP <= USB_DATA_IN;
                when "00011100" => COMP_THRES_LOW_TMP <= USB_DATA_IN;
                when "00011101" => COMP_THRES_HIGH_TMP <= USB_DATA_IN;
                when "00011110" => CH1_PMT_HV_ADJ_TMP <= USB_DATA_IN;
                when "00011111" => CH2_PMT_HV_ADJ_TMP <= USB_DATA_IN;
                when "00100000" => CH1_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN;
                when "00100001" => CH1_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
                when "00100010" => CH2_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00100011" => CH2_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
     	        when "00110000" => TR_CONDITION_TMP <= USB_DATA_IN;
      	        when "00110001" => PRE_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00110010" => COINC_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00110011" => POST_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00110101" => SPARE_BYTES_TMP(31 downto 24) <= USB_DATA_IN;
      	        when "01010000" => CH1_OFFSET_ADJ_POS_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 3 then -- get second data byte or end byte
              READ_COUNT <= READ_COUNT + 1;
              if READ_ID = "00010000" then
                if USB_DATA_IN = "01100110" then
                  CH1_OFFSET_ADJ_POS <= CH1_OFFSET_ADJ_POS_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00010001" then
                if USB_DATA_IN = "01100110" then
                  CH1_OFFSET_ADJ_NEG <= CH1_OFFSET_ADJ_NEG_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00010010" then
                if USB_DATA_IN = "01100110" then
                  CH2_OFFSET_ADJ_POS <= CH2_OFFSET_ADJ_POS_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00010011" then
                if USB_DATA_IN = "01100110" then
                  CH2_OFFSET_ADJ_NEG <= CH2_OFFSET_ADJ_NEG_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00010100" then
                if USB_DATA_IN = "01100110" then
                  CH1_GAIN_ADJ_POS <= CH1_GAIN_ADJ_POS_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00010101" then
                if USB_DATA_IN = "01100110" then
                  CH1_GAIN_ADJ_NEG <= CH1_GAIN_ADJ_NEG_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00010110" then
                if USB_DATA_IN = "01100110" then
                  CH2_GAIN_ADJ_POS <= CH2_GAIN_ADJ_POS_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00010111" then
                if USB_DATA_IN = "01100110" then
                  CH2_GAIN_ADJ_NEG <= CH2_GAIN_ADJ_NEG_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011000" then
                if USB_DATA_IN = "01100110" then
                  COMMON_OFFSET_ADJ <= COMMON_OFFSET_ADJ_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011001" then
                if USB_DATA_IN = "01100110" then
                  FULL_SCALE_ADJ <= FULL_SCALE_ADJ_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011010" then
                if USB_DATA_IN = "01100110" then
                  CH1_INTEGRATOR <= CH1_INTEGRATOR_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011011" then
                if USB_DATA_IN = "01100110" then
                  CH2_INTEGRATOR <= CH2_INTEGRATOR_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011100" then
                if USB_DATA_IN = "01100110" then
                  COMP_THRES_LOW <= COMP_THRES_LOW_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011101" then
                if USB_DATA_IN = "01100110" then
                  COMP_THRES_HIGH <= COMP_THRES_HIGH_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011110" then
                if USB_DATA_IN = "01100110" then
                  CH1_PMT_HV_ADJ <= CH1_PMT_HV_ADJ_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00011111" then
                if USB_DATA_IN = "01100110" then
                  CH2_PMT_HV_ADJ <= CH2_PMT_HV_ADJ_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00110000" then
                if USB_DATA_IN = "01100110" then
                  TR_CONDITION <= TR_CONDITION_TMP;
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              case (READ_ID) is
                when "00100000" => CH1_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN;
                when "00100001" => CH1_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
                when "00100010" => CH2_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN;
                when "00100011" => CH2_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
                when "00110001" => PRE_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
                when "00110010" => COINC_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
                when "00110011" => POST_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "00110101" => SPARE_BYTES_TMP(23 downto 16) <= USB_DATA_IN;
                when "01010000" => CH1_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 4 then -- get third data byte or end byte
              READ_COUNT <= READ_COUNT + 1;
              if READ_ID = "00100000" then
                if USB_DATA_IN = "01100110" then
                  CH1_THRES_LOW(15 downto 8) <= CH1_THRES_LOW_TMP(15 downto 8);
                  CH1_THRES_LOW(7 downto 0) <= CH1_THRES_LOW_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00100001" then
                if USB_DATA_IN = "01100110" then
                  CH1_THRES_HIGH(15 downto 8) <= CH1_THRES_HIGH_TMP(15 downto 8);
                  CH1_THRES_HIGH(7 downto 0) <= CH1_THRES_HIGH_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00100010" then
                if USB_DATA_IN = "01100110" then
                  CH2_THRES_LOW(15 downto 8) <= CH2_THRES_LOW_TMP(15 downto 8);
                  CH2_THRES_LOW(7 downto 0) <= CH2_THRES_LOW_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00100011" then
                if USB_DATA_IN = "01100110" then
                  CH2_THRES_HIGH(15 downto 8) <= CH2_THRES_HIGH_TMP(15 downto 8);
                  CH2_THRES_HIGH(7 downto 0) <= CH2_THRES_HIGH_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00110001" then
                if USB_DATA_IN = "01100110" then
                  PRE_TIME_LOAD(15 downto 8) <= PRE_TIME_LOAD_TMP(15 downto 8);
                  PRE_TIME_LOAD(7 downto 0) <= PRE_TIME_LOAD_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00110010" then
                if USB_DATA_IN = "01100110" then
                  COINC_TIME_LOAD(15 downto 8) <= COINC_TIME_LOAD_TMP(15 downto 8);
                  COINC_TIME_LOAD(7 downto 0) <= COINC_TIME_LOAD_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              if READ_ID = "00110011" then
                if USB_DATA_IN = "01100110" then
                  POST_TIME_LOAD(15 downto 8) <= POST_TIME_LOAD_TMP(15 downto 8);
                  POST_TIME_LOAD(7 downto 0) <= POST_TIME_LOAD_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              case (READ_ID) is
                when "00110101" => SPARE_BYTES_TMP(15 downto 8) <= USB_DATA_IN;
                when "01010000" => CH2_OFFSET_ADJ_POS_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 5 then -- get fourth data byte or end byte
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
              when "00110101" => SPARE_BYTES_TMP(7 downto 0) <= USB_DATA_IN;
              when "01010000" => CH2_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN;
              when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 6 then -- get fifth data byte or end byte
              READ_COUNT <= READ_COUNT + 1;
              if READ_ID = "00110101" then
                if USB_DATA_IN = "01100110" then
                  SPARE_BYTES(31 downto 24) <= SPARE_BYTES_TMP(31 downto 24);
                  SPARE_BYTES(23 downto 16) <= SPARE_BYTES_TMP(23 downto 16);
                  SPARE_BYTES(15 downto 8) <= SPARE_BYTES_TMP(15 downto 8);
                  SPARE_BYTES(7 downto 0) <= SPARE_BYTES_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
              case (READ_ID) is
                when "01010000" => CH1_GAIN_ADJ_POS_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 7 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH1_GAIN_ADJ_NEG_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 8 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_GAIN_ADJ_POS_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 9 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_GAIN_ADJ_NEG_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 10 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => COMMON_OFFSET_ADJ_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 11 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => FULL_SCALE_ADJ_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 12 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH1_INTEGRATOR_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 13 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_INTEGRATOR_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 14 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => COMP_THRES_LOW_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 15 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => COMP_THRES_HIGH_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 16 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH1_PMT_HV_ADJ_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 17 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_PMT_HV_ADJ_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 18 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH1_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 19 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH1_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 20 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH1_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 21 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH1_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 22 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 23 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 24 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 25 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => CH2_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 26 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => TR_CONDITION_TMP <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 27 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => PRE_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 28 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => PRE_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 29 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => COINC_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 30 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => COINC_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 31 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => POST_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 32 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => POST_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 33 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => SPARE_BYTES_TMP(31 downto 24) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 34 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => SPARE_BYTES_TMP(23 downto 16) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 35 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => SPARE_BYTES_TMP(15 downto 8) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 36 then
              READ_COUNT <= READ_COUNT + 1;
              case (READ_ID) is
                when "01010000" => SPARE_BYTES_TMP(7 downto 0) <= USB_DATA_IN;
                when others =>  -- Do nothing
              end case;
            elsif READ_COUNT = 37 then
              READ_COUNT <= READ_COUNT + 1;
              if READ_ID = "01010000" then
                if USB_DATA_IN = "01100110" then
                  CH1_OFFSET_ADJ_POS <= CH1_OFFSET_ADJ_POS_TMP;
                  CH1_OFFSET_ADJ_NEG <= CH1_OFFSET_ADJ_NEG_TMP;
                  CH2_OFFSET_ADJ_POS <= CH2_OFFSET_ADJ_POS_TMP;
                  CH2_OFFSET_ADJ_NEG <= CH2_OFFSET_ADJ_NEG_TMP;
                  CH1_GAIN_ADJ_POS <= CH1_GAIN_ADJ_POS_TMP;
                  CH1_GAIN_ADJ_NEG <= CH1_GAIN_ADJ_NEG_TMP;
                  CH2_GAIN_ADJ_POS <= CH2_GAIN_ADJ_POS_TMP;
                  CH2_GAIN_ADJ_NEG <= CH2_GAIN_ADJ_NEG_TMP;
                  COMMON_OFFSET_ADJ <= COMMON_OFFSET_ADJ_TMP;
                  FULL_SCALE_ADJ <= FULL_SCALE_ADJ_TMP;
                  CH1_INTEGRATOR <= CH1_INTEGRATOR_TMP;
                  CH2_INTEGRATOR <= CH2_INTEGRATOR_TMP;
                  COMP_THRES_LOW <= COMP_THRES_LOW_TMP;
                  COMP_THRES_HIGH <= COMP_THRES_HIGH_TMP;
                  CH1_PMT_HV_ADJ <= CH1_PMT_HV_ADJ_TMP;
                  CH2_PMT_HV_ADJ <= CH2_PMT_HV_ADJ_TMP;
                  CH1_THRES_LOW(15 downto 8) <= CH1_THRES_LOW_TMP(15 downto 8);
                  CH1_THRES_LOW(7 downto 0) <= CH1_THRES_LOW_TMP(7 downto 0);
                  CH1_THRES_HIGH(15 downto 8) <= CH1_THRES_HIGH_TMP(15 downto 8);
                  CH1_THRES_HIGH(7 downto 0) <= CH1_THRES_HIGH_TMP(7 downto 0);
                  CH2_THRES_LOW(15 downto 8) <= CH2_THRES_LOW_TMP(15 downto 8);
                  CH2_THRES_LOW(7 downto 0) <= CH2_THRES_LOW_TMP(7 downto 0);
                  CH2_THRES_HIGH(15 downto 8) <= CH2_THRES_HIGH_TMP(15 downto 8);
                  CH2_THRES_HIGH(7 downto 0) <= CH2_THRES_HIGH_TMP(7 downto 0);
                  TR_CONDITION <= TR_CONDITION_TMP;
                  PRE_TIME_LOAD(15 downto 8) <= PRE_TIME_LOAD_TMP(15 downto 8);
                  PRE_TIME_LOAD(7 downto 0) <= PRE_TIME_LOAD_TMP(7 downto 0);
                  COINC_TIME_LOAD(15 downto 8) <= COINC_TIME_LOAD_TMP(15 downto 8);
                  COINC_TIME_LOAD(7 downto 0) <= COINC_TIME_LOAD_TMP(7 downto 0);
                  POST_TIME_LOAD(15 downto 8) <= POST_TIME_LOAD_TMP(15 downto 8);
                  POST_TIME_LOAD(7 downto 0) <= POST_TIME_LOAD_TMP(7 downto 0);
                  SPARE_BYTES(31 downto 24) <= SPARE_BYTES_TMP(31 downto 24);
                  SPARE_BYTES(23 downto 16) <= SPARE_BYTES_TMP(23 downto 16);
                  SPARE_BYTES(15 downto 8) <= SPARE_BYTES_TMP(15 downto 8);
                  SPARE_BYTES(7 downto 0) <= SPARE_BYTES_TMP(7 downto 0);
                  STOP_READING <= '1';
                else
                  READ_ERROR <= '1';
                  READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
            elsif READ_COUNT = 38 then
              READ_ERROR <= '1';
              READ_ERROR_DATA <= "01100110"; -- Missing stop byte
            end if;
          end if;
        end if;
      else
        RD_TMP <= '1';
        READ_COUNT <= 0;
        READ_ERROR <= '0';
        STOP_READING <= '0';
        WRITE_PARAMETER_LIST <= '0';
        SOFT_RESET <= '0';
        TIME_OUT_COUNT <= (others => '0');
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      PRELOAD_DAC_COUNT <= "000";
      PRELOAD_DACS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if PRELOAD_DAC_COUNT /= "111" then
        PRELOAD_DAC_COUNT <= PRELOAD_DAC_COUNT + "001";
        PRELOAD_DACS <= '0';
      else
        PRELOAD_DAC_COUNT <= PRELOAD_DAC_COUNT;
        PRELOAD_DACS <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_OFFSET_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_OFFSET_ADJ_POS /= CH1_OFFSET_ADJ_POS_DEL) then
        SET_CH1_OFFSET_ADJ_POS <= '1';
      elsif CLR_CH1_OFFSET_ADJ_POS = '1' then
        SET_CH1_OFFSET_ADJ_POS <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_OFFSET_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_OFFSET_ADJ_NEG /= CH1_OFFSET_ADJ_NEG_DEL) then
        SET_CH1_OFFSET_ADJ_NEG <= '1';
      elsif CLR_CH1_OFFSET_ADJ_NEG = '1' then
        SET_CH1_OFFSET_ADJ_NEG <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_OFFSET_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_OFFSET_ADJ_POS /= CH2_OFFSET_ADJ_POS_DEL) then
        SET_CH2_OFFSET_ADJ_POS <= '1';
      elsif CLR_CH2_OFFSET_ADJ_POS = '1' then
        SET_CH2_OFFSET_ADJ_POS <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_OFFSET_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_OFFSET_ADJ_NEG /= CH2_OFFSET_ADJ_NEG_DEL) then
        SET_CH2_OFFSET_ADJ_NEG <= '1';
      elsif CLR_CH2_OFFSET_ADJ_NEG = '1' then
        SET_CH2_OFFSET_ADJ_NEG <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_GAIN_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_GAIN_ADJ_POS /= CH1_GAIN_ADJ_POS_DEL) then
        SET_CH1_GAIN_ADJ_POS <= '1';
      elsif CLR_CH1_GAIN_ADJ_POS = '1' then
        SET_CH1_GAIN_ADJ_POS <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_GAIN_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_GAIN_ADJ_NEG /= CH1_GAIN_ADJ_NEG_DEL) then
        SET_CH1_GAIN_ADJ_NEG <= '1';
      elsif CLR_CH1_GAIN_ADJ_NEG = '1' then
        SET_CH1_GAIN_ADJ_NEG <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_GAIN_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_GAIN_ADJ_POS /= CH2_GAIN_ADJ_POS_DEL) then
        SET_CH2_GAIN_ADJ_POS <= '1';
      elsif CLR_CH2_GAIN_ADJ_POS = '1' then
        SET_CH2_GAIN_ADJ_POS <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_GAIN_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_GAIN_ADJ_NEG /= CH2_GAIN_ADJ_NEG_DEL) then
        SET_CH2_GAIN_ADJ_NEG <= '1';
      elsif CLR_CH2_GAIN_ADJ_NEG = '1' then
        SET_CH2_GAIN_ADJ_NEG <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_COMMON_OFFSET_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (COMMON_OFFSET_ADJ /= COMMON_OFFSET_ADJ_DEL) then
        SET_COMMON_OFFSET_ADJ <= '1';
      elsif CLR_COMMON_OFFSET_ADJ = '1' then
        SET_COMMON_OFFSET_ADJ <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_FULL_SCALE_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (FULL_SCALE_ADJ /= FULL_SCALE_ADJ_DEL) then
        SET_FULL_SCALE_ADJ <= '1';
      elsif CLR_FULL_SCALE_ADJ = '1' then
        SET_FULL_SCALE_ADJ <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_INTEGRATOR <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_INTEGRATOR /= CH1_INTEGRATOR_DEL) then
        SET_CH1_INTEGRATOR <= '1';
      elsif CLR_CH1_INTEGRATOR = '1' then
        SET_CH1_INTEGRATOR <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_INTEGRATOR <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_INTEGRATOR /= CH2_INTEGRATOR_DEL) then
        SET_CH2_INTEGRATOR <= '1';
      elsif CLR_CH2_INTEGRATOR = '1' then
        SET_CH2_INTEGRATOR <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_COMP_THRES_LOW <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (COMP_THRES_LOW /= COMP_THRES_LOW_DEL) then
        SET_COMP_THRES_LOW <= '1';
      elsif CLR_COMP_THRES_LOW = '1' then
        SET_COMP_THRES_LOW <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_COMP_THRES_HIGH <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (COMP_THRES_HIGH /= COMP_THRES_HIGH_DEL) then
        SET_COMP_THRES_HIGH <= '1';
      elsif CLR_COMP_THRES_HIGH = '1' then
        SET_COMP_THRES_HIGH <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_PMT_HV_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_PMT_HV_ADJ /= CH1_PMT_HV_ADJ_DEL) then
        SET_CH1_PMT_HV_ADJ <= '1';
      elsif CLR_CH1_PMT_HV_ADJ = '1' then
        SET_CH1_PMT_HV_ADJ <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_PMT_HV_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_PMT_HV_ADJ /= CH2_PMT_HV_ADJ_DEL) then
        SET_CH2_PMT_HV_ADJ <= '1';
      elsif CLR_CH2_PMT_HV_ADJ = '1' then
        SET_CH2_PMT_HV_ADJ <= '0';
      end if;
    end if;
  end process;

  -- Changes are done because of channelswap on the board.
  -- The DAC outputs to the analog channels are driven with the register of the other
  -- E.g. If you set the offset of channel 1 (by software), the offset of channel 2 will be set instead

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_DACS <= '1';
      DAC_A2 <= '0';
      DAC_A1 <= '0';
      DAC_A0 <= '0';
      DAC_nCS1 <= '1';
      DAC_nCS2 <= '1';
      DAC_DATA_OUT <= "00000000";
      CLR_CH1_OFFSET_ADJ_POS <= '0';
      CLR_CH1_OFFSET_ADJ_NEG <= '0';
      CLR_CH2_OFFSET_ADJ_POS <= '0';
      CLR_CH2_OFFSET_ADJ_NEG <= '0';
      CLR_CH1_GAIN_ADJ_POS <= '0';
      CLR_CH1_GAIN_ADJ_NEG <= '0';
      CLR_CH2_GAIN_ADJ_POS <= '0';
      CLR_CH2_GAIN_ADJ_NEG <= '0';
      CLR_COMMON_OFFSET_ADJ <= '0';
      CLR_FULL_SCALE_ADJ <= '0';
      CLR_CH1_INTEGRATOR <= '0';
      CLR_CH2_INTEGRATOR <= '0';
      CLR_COMP_THRES_LOW <= '0';
      CLR_COMP_THRES_HIGH <= '0';
      CLR_CH1_PMT_HV_ADJ <= '0';
      CLR_CH2_PMT_HV_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if SET_CH1_OFFSET_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_OFFSET_ADJ_POS; -- DAC E
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH1_OFFSET_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_OFFSET_ADJ_POS <= '0';
        end if;
      elsif SET_CH1_OFFSET_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_OFFSET_ADJ_NEG; -- DAC F
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH1_OFFSET_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_OFFSET_ADJ_NEG <= '0';
        end if;
      elsif SET_CH2_OFFSET_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_OFFSET_ADJ_POS; -- DAC G
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH2_OFFSET_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_OFFSET_ADJ_POS <= '0';
        end if;
      elsif SET_CH2_OFFSET_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_OFFSET_ADJ_NEG; -- DAC H
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH2_OFFSET_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_OFFSET_ADJ_NEG <= '0';
        end if;
      elsif SET_CH1_GAIN_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_GAIN_ADJ_POS; -- DAC B
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_GAIN_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_GAIN_ADJ_POS <= '0';
        end if;
      elsif SET_CH1_GAIN_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_GAIN_ADJ_NEG; -- DAC D
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_GAIN_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_GAIN_ADJ_NEG <= '0';
        end if;
      elsif SET_CH2_GAIN_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_GAIN_ADJ_POS; -- DAC E
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_GAIN_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_GAIN_ADJ_POS <= '0';
        end if;
      elsif SET_CH2_GAIN_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_GAIN_ADJ_NEG; -- DAC G
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_GAIN_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_GAIN_ADJ_NEG <= '0';
        end if;
      elsif SET_COMMON_OFFSET_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= COMMON_OFFSET_ADJ; -- DAC C
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_COMMON_OFFSET_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_COMMON_OFFSET_ADJ <= '0';
        end if;
      elsif SET_FULL_SCALE_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= FULL_SCALE_ADJ; -- DAC D
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_FULL_SCALE_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_FULL_SCALE_ADJ <= '0';
        end if;
      elsif SET_CH1_INTEGRATOR = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_INTEGRATOR; -- DAC F
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_INTEGRATOR <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_INTEGRATOR <= '0';
        end if;
      elsif SET_CH2_INTEGRATOR = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_INTEGRATOR; -- DAC H
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_INTEGRATOR <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_INTEGRATOR <= '0';
        end if;
      elsif SET_COMP_THRES_LOW = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= COMP_THRES_LOW; -- DAC A
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_COMP_THRES_LOW <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_COMP_THRES_LOW <= '0';
        end if;
      elsif SET_COMP_THRES_HIGH = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= COMP_THRES_HIGH; -- DAC B
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_COMP_THRES_HIGH <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_COMP_THRES_HIGH <= '0';
        end if;
      elsif SET_CH1_PMT_HV_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_PMT_HV_ADJ; -- DAC A
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_PMT_HV_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_PMT_HV_ADJ <= '0';
        end if;
      elsif SET_CH2_PMT_HV_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_PMT_HV_ADJ; -- DAC C
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_PMT_HV_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_PMT_HV_ADJ <= '0';
        end if;
      end if;
    end if;
  end process;

  -- Readout Current ADCs

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      SET_CURR_ADC <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then  -- Starts at ONE_PPS
        SET_CURR_ADC <= '1';
      elsif CLR_CURR_ADC = '1' then
        SET_CURR_ADC <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST,CURR_ADC_COUNT,ADC_DATA_IN)
  begin
    if SYSRST = '1' then
      CH1_PMT_SUPPLY_CURR <= "00000000";
      CH2_PMT_SUPPLY_CURR <= "00000000";
      CLR_CURR_ADC <= '0';
      ADC_nRD <= '1';
      ADC_A0 <= '0';
      CURR_ADC_COUNT <= 0;
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if SET_CURR_ADC = '1' then
        CURR_ADC_COUNT <= CURR_ADC_COUNT + 1;
        case (CURR_ADC_COUNT) is
        when 1 =>  ADC_A0 <= '0';
                   ADC_nRD <= '1';
        when 8 =>  ADC_A0 <= '0';
                   ADC_nRD <= '0';                      -- 700ns aquisition time
        when 36 => ADC_A0 <= '1';
                   ADC_nRD <= '1';
                   CH1_PMT_SUPPLY_CURR <= ADC_DATA_IN;  -- 2800ns conversion time
        when 43 => ADC_A0 <= '1';
                   ADC_nRD <= '0';                      -- 700ns aquisition time
        when 71 => ADC_A0 <= '0';
                   ADC_nRD <= '1';
                   CH2_PMT_SUPPLY_CURR <= ADC_DATA_IN;
                   CLR_CURR_ADC <= '1';                 -- 2800ns conversion time
        when others =>  -- Do nothing
        end case;
      else
        CLR_CURR_ADC <= '0';
        ADC_nRD <= '1';
        ADC_A0 <= '0';
        CURR_ADC_COUNT <= 0;
      end if;
    end if;
  end process;

end architecture a0 ; -- of USB_READ_HANDLER

--------------------------------------------------------------------------------
-- Object        : Entity design.USB_WRITE_HANDLER
-- Last modified : Mon Feb 27 11:18:52 2012.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity USB_WRITE_HANDLER is
  port(
    ALTITUDE                    : in     std_logic_vector(63 downto 0);
    CLK10MHz                    : in     std_logic;
    CLKRD                       : in     std_logic;
    COINC_TIME                  : in     std_logic_vector(15 downto 0);
    COMPDATA                    : in     std_logic_vector(127 downto 0);
    COMPDATA_READOUT_DONE       : out    std_logic;
    COMPDATA_VALID              : in     std_logic;
    CTD_IN                      : in     std_logic_vector(31 downto 0);
    CTD_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
    CTP_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
    EVENT_DATA_IN               : in     std_logic_vector(7 downto 0);
    EVENT_READOUT_BUSY          : in     std_logic;
    EVENT_WR                    : out    std_logic;
    EVENT_WR_EN                 : in     std_logic;
    GPS_TS_IN                   : in     std_logic_vector(55 downto 0);
    GPS_TS_ONE_PPS              : in     std_logic_vector(55 downto 0);
    LATITUDE                    : in     std_logic_vector(63 downto 0);
    LONGITUDE                   : in     std_logic_vector(63 downto 0);
    NEW_DATA_WHILE_READOUT      : out    std_logic;
    PARAMETER_LIST              : in     std_logic_vector(271 downto 0);
    PARAMETER_LIST_READOUT_DONE : out    std_logic;
    PARAMETER_LIST_VALID        : in     std_logic;
    POST_TIME                   : in     std_logic_vector(15 downto 0);
    PRE_TIME                    : in     std_logic_vector(15 downto 0);
    READ_ERROR_DATA             : in     std_logic_vector(7 downto 0);
    READ_ERROR_READOUT_DONE     : out    std_logic;
    READ_ERROR_VALID            : in     std_logic;
    SAT_INFO                    : in     std_logic_vector(487 downto 0);
    SECOND_MESSAGE_ALLOWED      : in     std_logic;
    SEND_EVENT_DATA             : out    std_logic;
    START_WRITE_EVENT           : in     std_logic;
    SYSRST                      : in     std_logic;
    TEMP                        : in     std_logic_vector(31 downto 0);
    TH_COUNTERS_IN              : in     std_logic_vector(63 downto 0);
    TRIGGER_PATTERN             : in     std_logic_vector(15 downto 0);
    TR_CONDITION                : in     std_logic_vector(7 downto 0);
    TS_ONE_PPS_READOUT_DONE     : out    std_logic;
    TS_ONE_PPS_VALID_INPUT      : in     std_logic;
    USB_DATA_OUT                : out    std_logic_vector(7 downto 0);
    USB_TXE                     : in     std_logic;
    USB_WR                      : out    std_logic;
    USB_WRITE_BUSY              : out    std_logic;
    USB_WRITE_ENABLE            : in     std_logic;
    USB_WRITE_REQUEST           : out    std_logic);
end entity USB_WRITE_HANDLER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.USB_WRITE_HANDLER.a0
-- Last modified : Mon Feb 27 11:18:52 2012.
--------------------------------------------------------------------------------


architecture a0 of USB_WRITE_HANDLER is

signal WR_TMP: std_logic ;
signal WRITE_EVENT_MODE: std_logic ; -- True when event data is send to computer
signal WRITE_EVENT_MODE_DEL: std_logic ;
signal WRITE_GPS_MODE: std_logic ; -- True when data of GPS counters is send to computer
signal WRITE_GPS_MODE_DEL: std_logic ;
signal WRITE_PARAMETER_LIST_MODE: std_logic ; -- True when PARAMETER_LIST is send to computer
signal WRITE_PARAMETER_LIST_MODE_DEL: std_logic ;
signal WRITE_READ_ERROR_MODE: std_logic ; -- True when READ_ERROR data is send to computer
signal WRITE_READ_ERROR_MODE_DEL: std_logic ;
signal WRITE_COMP_MODE: std_logic ; -- True when data of comperators is send to computer
signal WRITE_COMP_MODE_DEL: std_logic ;
signal START_WRITE_EVENT_PRIOR: std_logic ;
signal START_WRITE_EVENT_PRIOR_DEL: std_logic ;
signal START_WRITE_GPS_COUNT_PRIOR: std_logic ;
signal START_WRITE_GPS_COUNT_PRIOR_DEL: std_logic ;
signal START_WRITE_PARAMETER_LIST_PRIOR: std_logic ;
signal START_WRITE_PARAMETER_LIST_PRIOR_DEL: std_logic ;
signal START_WRITE_READ_ERROR_PRIOR: std_logic ;
signal START_WRITE_READ_ERROR_PRIOR_DEL: std_logic ;
signal START_WRITE_COMP_DATA_PRIOR: std_logic ;
signal START_WRITE_COMP_DATA_PRIOR_DEL: std_logic ;
signal ADDITIONAL_DATA_COUNT: integer range 22 downto 0;
signal WRITE_ENABLE_ADDITIONAL_DATA: std_logic ;
signal WRITE_ENABLE_ADDITIONAL_DATA_DEL1: std_logic ;
signal WR_ADDITIONAL_DATA: std_logic ;
signal WR_ADDITIONAL_DATA_DEL: std_logic ;
signal USB_WR_EN: std_logic ;
signal EVENT_READOUT_BUSY_DEL: std_logic ;
signal SEND_EVENT_DATA_TMP: std_logic ;
signal WR_END_BYTE: std_logic ;
signal WR_END_BYTE_DEL: std_logic ;
signal WR_END_BYTE_ENABLE: std_logic ;
signal WR_END_BYTE_ENABLE_DEL1: std_logic ;
signal ADDITIONAL_DATA_TMP: std_logic_vector(7 downto 0);
signal USB_DATA_PRE: std_logic_vector(7 downto 0);
signal USB_DATA: std_logic_vector(7 downto 0);
signal USB_DATA_MODE_PRE: std_logic_vector(2 downto 0);
signal USB_DATA_MODE: std_logic_vector(4 downto 0);
signal WR_GPS_DATA_ENABLE: std_logic ;
signal WR_GPS_DATA_ENABLE_DEL: std_logic ;
signal GPS_DATA_COUNT: integer range 87 downto 0;
signal GPS_DATA_TMP: std_logic_vector(7 downto 0);
signal WR_GPS_DATA: std_logic ;
signal WR_GPS_DATA_DEL: std_logic ;
signal WR_PARAMETER_LIST_ENABLE: std_logic ;
signal WR_PARAMETER_LIST_ENABLE_DEL: std_logic ;
signal PARAMETER_LIST_COUNT: integer range 79 downto 0;
signal WR_PARAMETER_LIST: std_logic ;
signal WR_PARAMETER_LIST_DEL: std_logic ;
signal PARAMETER_LIST_TMP: std_logic_vector(7 downto 0);
signal WR_READ_ERROR_ENABLE: std_logic ;
signal WR_READ_ERROR_ENABLE_DEL: std_logic ;
signal READ_ERROR_COUNT: integer range 4 downto 0;
signal WR_READ_ERROR: std_logic ;
signal WR_READ_ERROR_DEL: std_logic ;
signal READ_ERROR_TMP: std_logic_vector(7 downto 0);
signal WR_COMP_DATA_ENABLE: std_logic ;
signal WR_COMP_DATA_ENABLE_DEL: std_logic ;
signal COMP_DATA_COUNT: integer range 19 downto 0;
signal COMP_DATA_TMP: std_logic_vector(7 downto 0);
signal WR_COMP_DATA: std_logic ;
signal WR_COMP_DATA_DEL: std_logic ;

signal TS_ONE_PPS_VALID_IN: std_logic ;
signal TS_ONE_PPS_VALID_IN_DEL: std_logic ;
signal START_WRITE_EVENT_DEL: std_logic ;
signal PARAMETER_LIST_VALID_DEL: std_logic ;
signal READ_ERROR_VALID_DEL: std_logic ;
signal COMPDATA_VALID_DEL: std_logic ;
signal USB_WRITE_BUSY_TMP: std_logic ;
signal USB_BUSYHOLD_COUNT: std_logic_vector(3 downto 0); -- Forces a gap between 2 BUSY signals

begin

  TS_ONE_PPS_VALID_IN <= TS_ONE_PPS_VALID_INPUT and SECOND_MESSAGE_ALLOWED; -- Enable One second message with bit 1 of spare bytes

  USB_WRITE_REQUEST <= TS_ONE_PPS_VALID_IN or START_WRITE_EVENT or PARAMETER_LIST_VALID or READ_ERROR_VALID or COMPDATA_VALID;
  USB_WRITE_BUSY_TMP <= WRITE_EVENT_MODE or WRITE_GPS_MODE or WRITE_PARAMETER_LIST_MODE or WRITE_READ_ERROR_MODE or WRITE_COMP_MODE;
  USB_WRITE_BUSY <= USB_WRITE_BUSY_TMP;
  USB_WR <= WR_TMP;
  USB_WR_EN <= WRITE_ENABLE_ADDITIONAL_DATA or EVENT_WR_EN or WR_END_BYTE_ENABLE or WR_GPS_DATA_ENABLE or WR_PARAMETER_LIST_ENABLE or WR_READ_ERROR_ENABLE or WR_COMP_DATA_ENABLE;
  SEND_EVENT_DATA <= SEND_EVENT_DATA_TMP;
  WR_ADDITIONAL_DATA <= WR_TMP when WRITE_ENABLE_ADDITIONAL_DATA = '1' else '0';
  EVENT_WR <= WR_TMP when SEND_EVENT_DATA_TMP = '1' else '0';
  WR_END_BYTE <= WR_TMP when WR_END_BYTE_ENABLE = '1' else '0';
  USB_DATA_MODE_PRE(0) <= WRITE_ENABLE_ADDITIONAL_DATA;
  USB_DATA_MODE_PRE(1) <= SEND_EVENT_DATA_TMP;
  USB_DATA_MODE_PRE(2) <= WR_END_BYTE_ENABLE;
  USB_DATA_MODE(0) <= WRITE_ENABLE_ADDITIONAL_DATA or SEND_EVENT_DATA_TMP or WR_END_BYTE_ENABLE;
  USB_DATA_MODE(1) <= WR_GPS_DATA_ENABLE;
  USB_DATA_MODE(2) <= WR_PARAMETER_LIST_ENABLE;
  USB_DATA_MODE(3) <= WR_READ_ERROR_ENABLE;
  USB_DATA_MODE(4) <= WR_COMP_DATA_ENABLE;
  WR_GPS_DATA <= WR_TMP when WR_GPS_DATA_ENABLE = '1' else '0';
  TS_ONE_PPS_READOUT_DONE <= not WR_GPS_DATA_ENABLE and WR_GPS_DATA_ENABLE_DEL;
  WR_PARAMETER_LIST <= WR_TMP when WR_PARAMETER_LIST_ENABLE = '1' else '0';
  PARAMETER_LIST_READOUT_DONE <= not WR_PARAMETER_LIST_ENABLE and WR_PARAMETER_LIST_ENABLE_DEL;
  WR_READ_ERROR <= WR_TMP when WR_READ_ERROR_ENABLE = '1' else '0';
  READ_ERROR_READOUT_DONE <= not WR_READ_ERROR_ENABLE and WR_READ_ERROR_ENABLE_DEL;
  WR_COMP_DATA <= WR_TMP when WR_COMP_DATA_ENABLE = '1' else '0';
  COMPDATA_READOUT_DONE <= not WR_COMP_DATA_ENABLE and WR_COMP_DATA_ENABLE_DEL;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_EVENT_MODE_DEL <= '0';
      WRITE_ENABLE_ADDITIONAL_DATA_DEL1 <= '0';
      EVENT_READOUT_BUSY_DEL <= '0';
      WR_END_BYTE_ENABLE_DEL1 <= '0';
      START_WRITE_EVENT_PRIOR_DEL <= '0';
      START_WRITE_GPS_COUNT_PRIOR_DEL <= '0';
      START_WRITE_PARAMETER_LIST_PRIOR_DEL <= '0';
      START_WRITE_READ_ERROR_PRIOR_DEL <= '0';
      START_WRITE_COMP_DATA_PRIOR_DEL <= '0';
      WRITE_GPS_MODE_DEL <= '0';
      WR_GPS_DATA_ENABLE_DEL <= '0';
      WRITE_PARAMETER_LIST_MODE_DEL <= '0';
      WR_PARAMETER_LIST_ENABLE_DEL <= '0';
      WRITE_READ_ERROR_MODE_DEL <= '0';
      WR_READ_ERROR_ENABLE_DEL <= '0';
      WRITE_COMP_MODE_DEL <= '0';
      WR_COMP_DATA_ENABLE_DEL <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      WRITE_EVENT_MODE_DEL <= WRITE_EVENT_MODE;
      WRITE_ENABLE_ADDITIONAL_DATA_DEL1 <= WRITE_ENABLE_ADDITIONAL_DATA;
      EVENT_READOUT_BUSY_DEL <= EVENT_READOUT_BUSY;
      WR_END_BYTE_ENABLE_DEL1 <= WR_END_BYTE_ENABLE;
      START_WRITE_EVENT_PRIOR_DEL <= START_WRITE_EVENT_PRIOR;
      START_WRITE_GPS_COUNT_PRIOR_DEL <= START_WRITE_GPS_COUNT_PRIOR;
      START_WRITE_PARAMETER_LIST_PRIOR_DEL <= START_WRITE_PARAMETER_LIST_PRIOR;
      START_WRITE_READ_ERROR_PRIOR_DEL <= START_WRITE_READ_ERROR_PRIOR;
      START_WRITE_COMP_DATA_PRIOR_DEL <= START_WRITE_COMP_DATA_PRIOR;
      WRITE_GPS_MODE_DEL <= WRITE_GPS_MODE;
      WR_GPS_DATA_ENABLE_DEL <= WR_GPS_DATA_ENABLE;
      WRITE_PARAMETER_LIST_MODE_DEL <= WRITE_PARAMETER_LIST_MODE;
      WR_PARAMETER_LIST_ENABLE_DEL <= WR_PARAMETER_LIST_ENABLE;
      WRITE_READ_ERROR_MODE_DEL <= WRITE_READ_ERROR_MODE;
      WR_READ_ERROR_ENABLE_DEL <= WR_READ_ERROR_ENABLE;
      WRITE_COMP_MODE_DEL <= WRITE_COMP_MODE;
      WR_COMP_DATA_ENABLE_DEL <= WR_COMP_DATA_ENABLE;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      TS_ONE_PPS_VALID_IN_DEL <= '0';
      START_WRITE_EVENT_DEL <= '0';
      PARAMETER_LIST_VALID_DEL <= '0';
      READ_ERROR_VALID_DEL <= '0';
      COMPDATA_VALID_DEL <= '0';
      NEW_DATA_WHILE_READOUT <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      TS_ONE_PPS_VALID_IN_DEL <= TS_ONE_PPS_VALID_IN;
      START_WRITE_EVENT_DEL <= START_WRITE_EVENT;
      PARAMETER_LIST_VALID_DEL <= PARAMETER_LIST_VALID;
      READ_ERROR_VALID_DEL <= READ_ERROR_VALID;
      COMPDATA_VALID_DEL <= COMPDATA_VALID;
      if USB_WRITE_BUSY_TMP = '1' and
      ((TS_ONE_PPS_VALID_IN = '1' and TS_ONE_PPS_VALID_IN_DEL = '0') or
      (START_WRITE_EVENT = '1' and START_WRITE_EVENT_DEL = '0') or
      (PARAMETER_LIST_VALID = '1' and PARAMETER_LIST_VALID_DEL = '0') or
      (READ_ERROR_VALID = '1' and READ_ERROR_VALID_DEL = '0') or
      (COMPDATA_VALID = '1' and COMPDATA_VALID_DEL = '0')) then
        NEW_DATA_WHILE_READOUT <= '1';
      else
        NEW_DATA_WHILE_READOUT <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_ADDITIONAL_DATA_DEL <= '0';
      WR_END_BYTE_DEL <= '0';
      WR_GPS_DATA_DEL <= '0';
      WR_PARAMETER_LIST_DEL <= '0';
      WR_READ_ERROR_DEL <= '0';
      WR_COMP_DATA_DEL <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      WR_ADDITIONAL_DATA_DEL <= WR_ADDITIONAL_DATA;
      WR_END_BYTE_DEL <= WR_END_BYTE;
      WR_GPS_DATA_DEL <= WR_GPS_DATA;
      WR_PARAMETER_LIST_DEL <= WR_PARAMETER_LIST;
      WR_READ_ERROR_DEL <= WR_READ_ERROR;
      WR_COMP_DATA_DEL <= WR_COMP_DATA;
    end if;
  end process;

  -- Priority encoding for writing to USB
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      START_WRITE_EVENT_PRIOR <= '0';
      START_WRITE_GPS_COUNT_PRIOR <= '0';
      START_WRITE_PARAMETER_LIST_PRIOR <= '0';
      START_WRITE_READ_ERROR_PRIOR <= '0';
      START_WRITE_COMP_DATA_PRIOR <= '0';
      USB_BUSYHOLD_COUNT <= "0000";
    elsif (CLKRD'event and CLKRD = '1') then
      if USB_WRITE_ENABLE = '1' then
        if USB_WRITE_BUSY_TMP = '0' then  -- if there is no writing to USB
          if USB_BUSYHOLD_COUNT > "1000" then
            USB_BUSYHOLD_COUNT <= USB_BUSYHOLD_COUNT;
            if TS_ONE_PPS_VALID_IN = '1' then -- Start WRITE_GPS_MODE
              START_WRITE_GPS_COUNT_PRIOR <= '1';
            elsif START_WRITE_EVENT = '1' then -- Start WRITE_EVENT_MODE
              START_WRITE_EVENT_PRIOR <= '1';
            elsif COMPDATA_VALID = '1' then -- Start WRITE_COMP_MODE
              START_WRITE_COMP_DATA_PRIOR <= '1';
            elsif PARAMETER_LIST_VALID = '1' then -- Start WRITE_PARAMETER_LIST_MODE
              START_WRITE_PARAMETER_LIST_PRIOR <= '1';
            elsif READ_ERROR_VALID = '1' then -- Start WRITE_READ_ERROR_MODE
              START_WRITE_READ_ERROR_PRIOR <= '1';
            end if;
          else
            USB_BUSYHOLD_COUNT <= USB_BUSYHOLD_COUNT + "0001";
          end if;
        else
          START_WRITE_EVENT_PRIOR <= '0';
          START_WRITE_GPS_COUNT_PRIOR <= '0';
          START_WRITE_PARAMETER_LIST_PRIOR <= '0';
          START_WRITE_READ_ERROR_PRIOR <= '0';
          START_WRITE_COMP_DATA_PRIOR <= '0';
          USB_BUSYHOLD_COUNT <= "0000";
        end if;
      end if;
    end if;
  end process;

---------------------------------- Write event data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_EVENT_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WR_END_BYTE_ENABLE = '0' and WR_END_BYTE_ENABLE_DEL1 = '1' then -- At downgoing edge of WR_END_BYTE_ENABLE
        WRITE_EVENT_MODE <= '0';
      elsif WRITE_EVENT_MODE = '1' then -- WRITE_EVENT_MODE locks itself
        WRITE_EVENT_MODE <= WRITE_EVENT_MODE;
      elsif START_WRITE_EVENT_PRIOR = '1' and START_WRITE_EVENT_PRIOR_DEL = '0' then -- Start WRITE_EVENT_MODE
        WRITE_EVENT_MODE <= '1';
      end if;
    end if;
  end process;

  -- Write ADDITIONAL_DATA
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ADDITIONAL_DATA_COUNT <= 22;
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_EVENT_MODE = '1' and WRITE_EVENT_MODE_DEL = '0' then  -- upgoing edge of WRITE_EVENT_MODE
        ADDITIONAL_DATA_COUNT <= 22;
      elsif WR_ADDITIONAL_DATA = '1' and WR_ADDITIONAL_DATA_DEL = '0' then  -- upgoing edge of WR_ADDITIONAL_DATA
        ADDITIONAL_DATA_COUNT <= ADDITIONAL_DATA_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_ENABLE_ADDITIONAL_DATA <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_EVENT_MODE = '1' and WRITE_EVENT_MODE_DEL = '0' then  -- upgoing edge of WRITE_EVENT_MODE
        WRITE_ENABLE_ADDITIONAL_DATA <= '1';
      elsif WR_ADDITIONAL_DATA = '0' and WR_ADDITIONAL_DATA_DEL = '1' and ADDITIONAL_DATA_COUNT = 0 then  -- downgoing edge of WR_ADDITIONAL_DATA
        WRITE_ENABLE_ADDITIONAL_DATA <= '0';
      end if;
    end if;
  end process;

  -- Write event data
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      SEND_EVENT_DATA_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WRITE_ENABLE_ADDITIONAL_DATA = '0' and WRITE_ENABLE_ADDITIONAL_DATA_DEL1 = '1' then  -- downgoing edge of WRITE_ENABLE_TRIGGER_PATTERN
        SEND_EVENT_DATA_TMP <= '1';
      elsif EVENT_READOUT_BUSY = '0' and EVENT_READOUT_BUSY_DEL = '1' then  -- downgoing edge of EVENT_READOUT_BUSY
        SEND_EVENT_DATA_TMP <= '0';
      end if;
    end if;
  end process;

  -- Write end byte
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_END_BYTE_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if EVENT_READOUT_BUSY = '0' and EVENT_READOUT_BUSY_DEL = '1' then  -- downgoing edge of EVENT_READOUT_BUSY
        WR_END_BYTE_ENABLE <= '1';
      elsif WR_END_BYTE = '0' and WR_END_BYTE_DEL = '1' then  -- downgoing edge of WR_END_BYTE
        WR_END_BYTE_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WR_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if USB_WR_EN = '1' then
        if USB_TXE = '0' then
          WR_TMP <= not WR_TMP;
        else
          WR_TMP <= '0';
        end if;
      else
        WR_TMP <= '0';
      end if;
    end if;
  end process;

  process(ADDITIONAL_DATA_COUNT,TR_CONDITION,TRIGGER_PATTERN,PRE_TIME,COINC_TIME,POST_TIME,GPS_TS_IN,CTD_IN)
  begin
    case (ADDITIONAL_DATA_COUNT) is
      when 21 => ADDITIONAL_DATA_TMP <= "10011001"; -- 99h
      when 20 => ADDITIONAL_DATA_TMP <= "10100000"; -- A0h
      when 19 => ADDITIONAL_DATA_TMP <= TR_CONDITION;
      when 18 => ADDITIONAL_DATA_TMP <= TRIGGER_PATTERN(15 downto 8);
      when 17 => ADDITIONAL_DATA_TMP <= TRIGGER_PATTERN(7 downto 0);
      when 16 => ADDITIONAL_DATA_TMP <= PRE_TIME(15 downto 8);
      when 15 => ADDITIONAL_DATA_TMP <= PRE_TIME(7 downto 0);
      when 14 => ADDITIONAL_DATA_TMP <= COINC_TIME(15 downto 8);
      when 13 => ADDITIONAL_DATA_TMP <= COINC_TIME(7 downto 0);
      when 12 => ADDITIONAL_DATA_TMP <= POST_TIME(15 downto 8);
      when 11 => ADDITIONAL_DATA_TMP <= POST_TIME(7 downto 0);
      when 10 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(55 downto 48);
      when 9 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(47 downto 40);
      when 8 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(39 downto 32);
      when 7 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(31 downto 24);
      when 6 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(23 downto 16);
      when 5 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(15 downto 8);
      when 4 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(7 downto 0);
      when 3 => ADDITIONAL_DATA_TMP <= CTD_IN(31 downto 24);
      when 2 => ADDITIONAL_DATA_TMP <= CTD_IN(23 downto 16);
      when 1 => ADDITIONAL_DATA_TMP <= CTD_IN(15 downto 8);
      when 0 => ADDITIONAL_DATA_TMP <= CTD_IN(7 downto 0);
      when others => ADDITIONAL_DATA_TMP <= "00000000";
    end case;
  end process;

  process(USB_DATA_MODE_PRE,ADDITIONAL_DATA_TMP,EVENT_DATA_IN)
  begin
    case (USB_DATA_MODE_PRE) is
      when "001" => USB_DATA_PRE <= ADDITIONAL_DATA_TMP;
      when "010" => USB_DATA_PRE <= EVENT_DATA_IN;
      when "100" => USB_DATA_PRE <= "01100110"; -- 66h
      when others => USB_DATA_PRE <= "00000000";
    end case;
  end process;

---------------------------------- GPS counter data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_GPS_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WR_GPS_DATA_ENABLE = '0' and WR_GPS_DATA_ENABLE_DEL = '1' then -- At downgoing edge of WR_GPS_DATA_ENABLE
        WRITE_GPS_MODE <= '0';
      elsif WRITE_GPS_MODE = '1' then -- WRITE_GPS_MODE locks itself
        WRITE_GPS_MODE <= WRITE_GPS_MODE;
      elsif START_WRITE_GPS_COUNT_PRIOR = '1' and START_WRITE_GPS_COUNT_PRIOR_DEL = '0' then -- Start WRITE_GPS_MODE
        WRITE_GPS_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      GPS_DATA_COUNT <= 87;
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_GPS_MODE = '1' and WRITE_GPS_MODE_DEL = '0' then  -- upgoing edge of WRITE_GPS_MODE
        GPS_DATA_COUNT <= 87;
      elsif WR_GPS_DATA = '1' and WR_GPS_DATA_DEL = '0' then  -- upgoing edge of WR_GPS_DATA
        GPS_DATA_COUNT <= GPS_DATA_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_GPS_DATA_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_GPS_MODE = '1' and WRITE_GPS_MODE_DEL = '0' then  -- upgoing edge of WRITE_GPS_MODE
        WR_GPS_DATA_ENABLE <= '1';
      elsif WR_GPS_DATA = '0' and WR_GPS_DATA_DEL = '1' and GPS_DATA_COUNT = 0 then  -- downgoing edge of WR_GPS_DATA
        WR_GPS_DATA_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(GPS_DATA_COUNT,GPS_TS_ONE_PPS,CTP_TS_ONE_PPS,CTD_TS_ONE_PPS,TH_COUNTERS_IN,SAT_INFO)
  begin
    case (GPS_DATA_COUNT) is
      when 86 => GPS_DATA_TMP <= "10011001"; -- 99h
      when 85 => GPS_DATA_TMP <= "10100100"; -- A4h
      when 84 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(55 downto 48);
      when 83 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(47 downto 40);
      when 82 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(39 downto 32);
      when 81 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(31 downto 24);
      when 80 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(23 downto 16);
      when 79 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(15 downto 8);
      when 78 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(7 downto 0);
      when 77 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(31 downto 24);
      when 76 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(23 downto 16);
      when 75 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(15 downto 8);
      when 74 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(7 downto 0);
      when 73 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(31 downto 24);
      when 72 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(23 downto 16);
      when 71 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(15 downto 8);
      when 70 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(7 downto 0);
      when 69 => GPS_DATA_TMP <= TH_COUNTERS_IN(63 downto 56);
      when 68 => GPS_DATA_TMP <= TH_COUNTERS_IN(55 downto 48);
      when 67 => GPS_DATA_TMP <= TH_COUNTERS_IN(47 downto 40);
      when 66 => GPS_DATA_TMP <= TH_COUNTERS_IN(39 downto 32);
      when 65 => GPS_DATA_TMP <= TH_COUNTERS_IN(31 downto 24);
      when 64 => GPS_DATA_TMP <= TH_COUNTERS_IN(23 downto 16);
      when 63 => GPS_DATA_TMP <= TH_COUNTERS_IN(15 downto 8);
      when 62 => GPS_DATA_TMP <= TH_COUNTERS_IN(7 downto 0);
      when 61 => GPS_DATA_TMP <= SAT_INFO(487 downto 480);
      when 60 => GPS_DATA_TMP <= SAT_INFO(479 downto 472);
      when 59 => GPS_DATA_TMP <= SAT_INFO(471 downto 464);
      when 58 => GPS_DATA_TMP <= SAT_INFO(463 downto 456);
      when 57 => GPS_DATA_TMP <= SAT_INFO(455 downto 448);
      when 56 => GPS_DATA_TMP <= SAT_INFO(447 downto 440);
      when 55 => GPS_DATA_TMP <= SAT_INFO(439 downto 432);
      when 54 => GPS_DATA_TMP <= SAT_INFO(431 downto 424);
      when 53 => GPS_DATA_TMP <= SAT_INFO(423 downto 416);
      when 52 => GPS_DATA_TMP <= SAT_INFO(415 downto 408);
      when 51 => GPS_DATA_TMP <= SAT_INFO(407 downto 400);
      when 50 => GPS_DATA_TMP <= SAT_INFO(399 downto 392);
      when 49 => GPS_DATA_TMP <= SAT_INFO(391 downto 384);
      when 48 => GPS_DATA_TMP <= SAT_INFO(383 downto 376);
      when 47 => GPS_DATA_TMP <= SAT_INFO(375 downto 368);
      when 46 => GPS_DATA_TMP <= SAT_INFO(367 downto 360);
      when 45 => GPS_DATA_TMP <= SAT_INFO(359 downto 352);
      when 44 => GPS_DATA_TMP <= SAT_INFO(351 downto 344);
      when 43 => GPS_DATA_TMP <= SAT_INFO(343 downto 336);
      when 42 => GPS_DATA_TMP <= SAT_INFO(335 downto 328);
      when 41 => GPS_DATA_TMP <= SAT_INFO(327 downto 320);
      when 40 => GPS_DATA_TMP <= SAT_INFO(319 downto 312);
      when 39 => GPS_DATA_TMP <= SAT_INFO(311 downto 304);
      when 38 => GPS_DATA_TMP <= SAT_INFO(303 downto 296);
      when 37 => GPS_DATA_TMP <= SAT_INFO(295 downto 288);
      when 36 => GPS_DATA_TMP <= SAT_INFO(287 downto 280);
      when 35 => GPS_DATA_TMP <= SAT_INFO(279 downto 272);
      when 34 => GPS_DATA_TMP <= SAT_INFO(271 downto 264);
      when 33 => GPS_DATA_TMP <= SAT_INFO(263 downto 256);
      when 32 => GPS_DATA_TMP <= SAT_INFO(255 downto 248);
      when 31 => GPS_DATA_TMP <= SAT_INFO(247 downto 240);
      when 30 => GPS_DATA_TMP <= SAT_INFO(239 downto 232);
      when 29 => GPS_DATA_TMP <= SAT_INFO(231 downto 224);
      when 28 => GPS_DATA_TMP <= SAT_INFO(223 downto 216);
      when 27 => GPS_DATA_TMP <= SAT_INFO(215 downto 208);
      when 26 => GPS_DATA_TMP <= SAT_INFO(207 downto 200);
      when 25 => GPS_DATA_TMP <= SAT_INFO(199 downto 192);
      when 24 => GPS_DATA_TMP <= SAT_INFO(191 downto 184);
      when 23 => GPS_DATA_TMP <= SAT_INFO(183 downto 176);
      when 22 => GPS_DATA_TMP <= SAT_INFO(175 downto 168);
      when 21 => GPS_DATA_TMP <= SAT_INFO(167 downto 160);
      when 20 => GPS_DATA_TMP <= SAT_INFO(159 downto 152);
      when 19 => GPS_DATA_TMP <= SAT_INFO(151 downto 144);
      when 18 => GPS_DATA_TMP <= SAT_INFO(143 downto 136);
      when 17 => GPS_DATA_TMP <= SAT_INFO(135 downto 128);
      when 16 => GPS_DATA_TMP <= SAT_INFO(127 downto 120);
      when 15 => GPS_DATA_TMP <= SAT_INFO(119 downto 112);
      when 14 => GPS_DATA_TMP <= SAT_INFO(111 downto 104);
      when 13 => GPS_DATA_TMP <= SAT_INFO(103 downto 96);
      when 12 => GPS_DATA_TMP <= SAT_INFO(95 downto 88);
      when 11 => GPS_DATA_TMP <= SAT_INFO(87 downto 80);
      when 10 => GPS_DATA_TMP <= SAT_INFO(79 downto 72);
      when 9 => GPS_DATA_TMP <= SAT_INFO(71 downto 64);
      when 8 => GPS_DATA_TMP <= SAT_INFO(63 downto 56);
      when 7 => GPS_DATA_TMP <= SAT_INFO(55 downto 48);
      when 6 => GPS_DATA_TMP <= SAT_INFO(47 downto 40);
      when 5 => GPS_DATA_TMP <= SAT_INFO(39 downto 32);
      when 4 => GPS_DATA_TMP <= SAT_INFO(31 downto 24);
      when 3 => GPS_DATA_TMP <= SAT_INFO(23 downto 16);
      when 2 => GPS_DATA_TMP <= SAT_INFO(15 downto 8);
      when 1 => GPS_DATA_TMP <= SAT_INFO(7 downto 0);
      when 0 => GPS_DATA_TMP <= "01100110"; -- 66h
      when others => GPS_DATA_TMP <= "00000000";
    end case;
  end process;

---------------------------------- Comparator data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_COMP_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WR_COMP_DATA_ENABLE = '0' and WR_COMP_DATA_ENABLE_DEL = '1' then -- At downgoing edge of WR_COMP_DATA_ENABLE
        WRITE_COMP_MODE <= '0';
      elsif WRITE_COMP_MODE = '1' then -- WRITE_GPS_MODE locks itself
        WRITE_COMP_MODE <= WRITE_COMP_MODE;
      elsif START_WRITE_COMP_DATA_PRIOR = '1' and START_WRITE_COMP_DATA_PRIOR_DEL = '0' then -- Start WRITE_COMP_MODE
        WRITE_COMP_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMP_DATA_COUNT <= 19;
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_COMP_MODE = '1' and WRITE_COMP_MODE_DEL = '0' then  -- upgoing edge of WRITE_COMP_MODE
        COMP_DATA_COUNT <= 19;
      elsif WR_COMP_DATA = '1' and WR_COMP_DATA_DEL = '0' then  -- upgoing edge of WR_COMP_DATA
        COMP_DATA_COUNT <= COMP_DATA_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_COMP_DATA_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_COMP_MODE = '1' and WRITE_COMP_MODE_DEL = '0' then  -- upgoing edge of WRITE_COMP_MODE
        WR_COMP_DATA_ENABLE <= '1';
      elsif WR_COMP_DATA = '0' and WR_COMP_DATA_DEL = '1' and COMP_DATA_COUNT = 0 then  -- downgoing edge of WR_COMP_DATA
        WR_COMP_DATA_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(COMP_DATA_COUNT,COMPDATA)
  begin
    case (COMP_DATA_COUNT) is
      when 18 => COMP_DATA_TMP <= "10011001"; -- 99h
      when 17 => COMP_DATA_TMP <= "10100010"; -- A2h
      when 16 => COMP_DATA_TMP <= COMPDATA(127 downto 120);
      when 15 => COMP_DATA_TMP <= COMPDATA(119 downto 112);
      when 14 => COMP_DATA_TMP <= COMPDATA(111 downto 104);
      when 13 => COMP_DATA_TMP <= COMPDATA(103 downto 96);
      when 12 => COMP_DATA_TMP <= COMPDATA(95 downto 88);
      when 11 => COMP_DATA_TMP <= COMPDATA(87 downto 80);
      when 10 => COMP_DATA_TMP <= COMPDATA(79 downto 72);
      when 9 => COMP_DATA_TMP <= COMPDATA(71 downto 64);
      when 8 => COMP_DATA_TMP <= COMPDATA(63 downto 56);
      when 7 => COMP_DATA_TMP <= COMPDATA(55 downto 48);
      when 6 => COMP_DATA_TMP <= COMPDATA(47 downto 40);
      when 5 => COMP_DATA_TMP <= COMPDATA(39 downto 32);
      when 4 => COMP_DATA_TMP <= COMPDATA(31 downto 24);
      when 3 => COMP_DATA_TMP <= COMPDATA(23 downto 16);
      when 2 => COMP_DATA_TMP <= COMPDATA(15 downto 8);
      when 1 => COMP_DATA_TMP <= COMPDATA(7 downto 0);
      when 0 => COMP_DATA_TMP <= "01100110"; -- 66h
      when others => COMP_DATA_TMP <= "00000000";
    end case;
  end process;

---------------------------------- PARAMETER_LIST data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_PARAMETER_LIST_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WR_PARAMETER_LIST_ENABLE = '0' and WR_PARAMETER_LIST_ENABLE_DEL = '1' then -- At downgoing edge of WR_PARAMETER_LIST_ENABLE
        WRITE_PARAMETER_LIST_MODE <= '0';
      elsif WRITE_PARAMETER_LIST_MODE = '1' then -- WRITE_PARAMETER_LIST_MODE locks itself
        WRITE_PARAMETER_LIST_MODE <= WRITE_PARAMETER_LIST_MODE;
      elsif START_WRITE_PARAMETER_LIST_PRIOR = '1' and START_WRITE_PARAMETER_LIST_PRIOR_DEL = '0' then -- Start WRITE_PARAMETER_LIST_MODE
        WRITE_PARAMETER_LIST_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      PARAMETER_LIST_COUNT <= 79;
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_PARAMETER_LIST_MODE = '1' and WRITE_PARAMETER_LIST_MODE_DEL = '0' then  -- upgoing edge of WRITE_PARAMETER_LIST_MODE
        PARAMETER_LIST_COUNT <= 79;
      elsif WR_PARAMETER_LIST = '1' and WR_PARAMETER_LIST_DEL = '0' then  -- upgoing edge of WR_PARAMETER_LIST
        PARAMETER_LIST_COUNT <= PARAMETER_LIST_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_PARAMETER_LIST_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_PARAMETER_LIST_MODE = '1' and WRITE_PARAMETER_LIST_MODE_DEL = '0' then  -- upgoing edge of WRITE_PARAMETER_LIST_MODE
        WR_PARAMETER_LIST_ENABLE <= '1';
      elsif WR_PARAMETER_LIST = '0' and WR_PARAMETER_LIST_DEL = '1' and PARAMETER_LIST_COUNT = 0 then  -- downgoing edge of WR_PARAMETER_LIST
        WR_PARAMETER_LIST_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(PARAMETER_LIST_COUNT,PARAMETER_LIST,TR_CONDITION,PRE_TIME,COINC_TIME,POST_TIME,GPS_TS_ONE_PPS,LONGITUDE,LATITUDE,ALTITUDE,TEMP)
  begin
    case (PARAMETER_LIST_COUNT) is
      when 78 => PARAMETER_LIST_TMP <= "10011001"; -- 99h
      when 77 => PARAMETER_LIST_TMP <= "01010101"; -- 55h
      when 76 => PARAMETER_LIST_TMP <= PARAMETER_LIST(7 downto 0);-- CH1_OFFSET_ADJ_POS
      when 75 => PARAMETER_LIST_TMP <= PARAMETER_LIST(15 downto 8);-- CH1_OFFSET_ADJ_NEG
      when 74 => PARAMETER_LIST_TMP <= PARAMETER_LIST(23 downto 16);-- CH2_OFFSET_ADJ_POS
      when 73 => PARAMETER_LIST_TMP <= PARAMETER_LIST(31 downto 24);-- CH2_OFFSET_ADJ_NEG
      when 72 => PARAMETER_LIST_TMP <= PARAMETER_LIST(39 downto 32);-- CH1_GAIN_ADJ_POS
      when 71 => PARAMETER_LIST_TMP <= PARAMETER_LIST(47 downto 40);-- CH1_GAIN_ADJ_NEG
      when 70 => PARAMETER_LIST_TMP <= PARAMETER_LIST(55 downto 48);-- CH2_GAIN_ADJ_POS
      when 69 => PARAMETER_LIST_TMP <= PARAMETER_LIST(63 downto 56);-- CH2_GAIN_ADJ_NEG
      when 68 => PARAMETER_LIST_TMP <= PARAMETER_LIST(71 downto 64);-- COMMON_OFFSET_ADJ
      when 67 => PARAMETER_LIST_TMP <= PARAMETER_LIST(79 downto 72);-- FULL_SCALE_ADJ
      when 66 => PARAMETER_LIST_TMP <= PARAMETER_LIST(87 downto 80);-- CH1_INTEGRATOR
      when 65 => PARAMETER_LIST_TMP <= PARAMETER_LIST(95 downto 88);-- CH2_INTEGRATOR
      when 64 => PARAMETER_LIST_TMP <= PARAMETER_LIST(103 downto 96);-- COMP_THRES_LOW
      when 63 => PARAMETER_LIST_TMP <= PARAMETER_LIST(111 downto 104);-- COMP_THRES_HIGH
      when 62 => PARAMETER_LIST_TMP <= PARAMETER_LIST(119 downto 112);-- CH1_PMT_HV_ADJ
      when 61 => PARAMETER_LIST_TMP <= PARAMETER_LIST(127 downto 120);-- CH2_PMT_HV_ADJ
      when 60 => PARAMETER_LIST_TMP <= PARAMETER_LIST(143 downto 136);-- CH1_THRES_LOW - higher byte
      when 59 => PARAMETER_LIST_TMP <= PARAMETER_LIST(135 downto 128);-- CH1_THRES_LOW - lower byte
      when 58 => PARAMETER_LIST_TMP <= PARAMETER_LIST(159 downto 152);-- CH1_THRES_HIGH - higher byte
      when 57 => PARAMETER_LIST_TMP <= PARAMETER_LIST(151 downto 144);-- CH1_THRES_HIGH - lower byte
      when 56 => PARAMETER_LIST_TMP <= PARAMETER_LIST(175 downto 168);-- CH2_THRES_LOW - higher byte
      when 55 => PARAMETER_LIST_TMP <= PARAMETER_LIST(167 downto 160);-- CH2_THRES_LOW - lower byte
      when 54 => PARAMETER_LIST_TMP <= PARAMETER_LIST(191 downto 184);-- CH2_THRES_HIGH - higher byte
      when 53 => PARAMETER_LIST_TMP <= PARAMETER_LIST(183 downto 176);-- CH2_THRES_HIGH - lower byte
      when 52 => PARAMETER_LIST_TMP <= TR_CONDITION;
      when 51 => PARAMETER_LIST_TMP <= PRE_TIME(15 downto 8);
      when 50 => PARAMETER_LIST_TMP <= PRE_TIME(7 downto 0);
      when 49 => PARAMETER_LIST_TMP <= COINC_TIME(15 downto 8);
      when 48 => PARAMETER_LIST_TMP <= COINC_TIME(7 downto 0);
      when 47 => PARAMETER_LIST_TMP <= POST_TIME(15 downto 8);
      when 46 => PARAMETER_LIST_TMP <= POST_TIME(7 downto 0);
      when 45 => PARAMETER_LIST_TMP <= PARAMETER_LIST(199 downto 192);-- STATUS
      when 44 => PARAMETER_LIST_TMP <= PARAMETER_LIST(231 downto 224);-- SPARE_BYTES - highest byte
      when 43 => PARAMETER_LIST_TMP <= PARAMETER_LIST(223 downto 216);
      when 42 => PARAMETER_LIST_TMP <= PARAMETER_LIST(215 downto 208);
      when 41 => PARAMETER_LIST_TMP <= PARAMETER_LIST(207 downto 200);-- SPARE_BYTES - lowest byte
      when 40 => PARAMETER_LIST_TMP <= PARAMETER_LIST(239 downto 232);-- CH1_PMT_SUPPLY_CURR
      when 39 => PARAMETER_LIST_TMP <= PARAMETER_LIST(247 downto 240);-- CH2_PMT_SUPPLY_CURR
      when 38 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(55 downto 48);
      when 37 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(47 downto 40);
      when 36 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(39 downto 32);
      when 35 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(31 downto 24);
      when 34 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(23 downto 16);
      when 33 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(15 downto 8);
      when 32 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(7 downto 0);
      when 31 => PARAMETER_LIST_TMP <= LONGITUDE(63 downto 56);
      when 30 => PARAMETER_LIST_TMP <= LONGITUDE(55 downto 48);
      when 29 => PARAMETER_LIST_TMP <= LONGITUDE(47 downto 40);
      when 28 => PARAMETER_LIST_TMP <= LONGITUDE(39 downto 32);
      when 27 => PARAMETER_LIST_TMP <= LONGITUDE(31 downto 24);
      when 26 => PARAMETER_LIST_TMP <= LONGITUDE(23 downto 16);
      when 25 => PARAMETER_LIST_TMP <= LONGITUDE(15 downto 8);
      when 24 => PARAMETER_LIST_TMP <= LONGITUDE(7 downto 0);
      when 23 => PARAMETER_LIST_TMP <= LATITUDE(63 downto 56);
      when 22 => PARAMETER_LIST_TMP <= LATITUDE(55 downto 48);
      when 21 => PARAMETER_LIST_TMP <= LATITUDE(47 downto 40);
      when 20 => PARAMETER_LIST_TMP <= LATITUDE(39 downto 32);
      when 19 => PARAMETER_LIST_TMP <= LATITUDE(31 downto 24);
      when 18 => PARAMETER_LIST_TMP <= LATITUDE(23 downto 16);
      when 17 => PARAMETER_LIST_TMP <= LATITUDE(15 downto 8);
      when 16 => PARAMETER_LIST_TMP <= LATITUDE(7 downto 0);
      when 15 => PARAMETER_LIST_TMP <= ALTITUDE(63 downto 56);
      when 14 => PARAMETER_LIST_TMP <= ALTITUDE(55 downto 48);
      when 13 => PARAMETER_LIST_TMP <= ALTITUDE(47 downto 40);
      when 12 => PARAMETER_LIST_TMP <= ALTITUDE(39 downto 32);
      when 11 => PARAMETER_LIST_TMP <= ALTITUDE(31 downto 24);
      when 10 => PARAMETER_LIST_TMP <= ALTITUDE(23 downto 16);
      when 9 => PARAMETER_LIST_TMP <= ALTITUDE(15 downto 8);
      when 8 => PARAMETER_LIST_TMP <= ALTITUDE(7 downto 0);
      when 7 => PARAMETER_LIST_TMP <= TEMP(31 downto 24);
      when 6 => PARAMETER_LIST_TMP <= TEMP(23 downto 16);
      when 5 => PARAMETER_LIST_TMP <= TEMP(15 downto 8);
      when 4 => PARAMETER_LIST_TMP <= TEMP(7 downto 0);
      when 3 => PARAMETER_LIST_TMP <= PARAMETER_LIST(271 downto 264);-- VERSION - highest byte
      when 2 => PARAMETER_LIST_TMP <= PARAMETER_LIST(263 downto 256);
      when 1 => PARAMETER_LIST_TMP <= PARAMETER_LIST(255 downto 248);-- VERSION - lowest byte
      when 0 => PARAMETER_LIST_TMP <= "01100110"; -- 66h
      when others => PARAMETER_LIST_TMP <= "00000000";
    end case;
  end process;

---------------------------------- READ_ERROR data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_READ_ERROR_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WR_READ_ERROR_ENABLE = '0' and WR_READ_ERROR_ENABLE_DEL = '1' then -- At downgoing edge of WR_READ_ERROR_ENABLE
        WRITE_READ_ERROR_MODE <= '0';
      elsif WRITE_READ_ERROR_MODE = '1' then -- WRITE_READ_ERROR_MODE locks itself
        WRITE_READ_ERROR_MODE <= WRITE_READ_ERROR_MODE;
      elsif START_WRITE_READ_ERROR_PRIOR = '1' and START_WRITE_READ_ERROR_PRIOR_DEL = '0' then -- Start WRITE_READ_ERROR_MODE
        WRITE_READ_ERROR_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      READ_ERROR_COUNT <= 4;
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_READ_ERROR_MODE = '1' and WRITE_READ_ERROR_MODE_DEL = '0' then  -- upgoing edge of WRITE_READ_ERROR_MODE
        READ_ERROR_COUNT <= 4;
      elsif WR_READ_ERROR = '1' and WR_READ_ERROR_DEL = '0' then  -- upgoing edge of WR_READ_ERROR
        READ_ERROR_COUNT <= READ_ERROR_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_READ_ERROR_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if WRITE_READ_ERROR_MODE = '1' and WRITE_READ_ERROR_MODE_DEL = '0' then  -- upgoing edge of WRITE_READ_ERROR_MODE
        WR_READ_ERROR_ENABLE <= '1';
      elsif WR_READ_ERROR = '0' and WR_READ_ERROR_DEL = '1' and READ_ERROR_COUNT = 0 then  -- downgoing edge of WR_READ_ERROR
        WR_READ_ERROR_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(READ_ERROR_COUNT,READ_ERROR_DATA)
  begin
    case (READ_ERROR_COUNT) is
      when 3 => READ_ERROR_TMP <= "10011001"; -- 99h
      when 2 => READ_ERROR_TMP <= "10001000"; -- 88h
      when 1 => READ_ERROR_TMP <= READ_ERROR_DATA;
      when 0 => READ_ERROR_TMP <= "01100110"; -- 66h
      when others => READ_ERROR_TMP <= "00000000";
    end case;
  end process;

  process(USB_DATA_MODE,USB_DATA_PRE,GPS_DATA_TMP,COMP_DATA_TMP,PARAMETER_LIST_TMP,READ_ERROR_TMP)
  begin
    case (USB_DATA_MODE) is
      when "00001" => USB_DATA <= USB_DATA_PRE;
      when "00010" => USB_DATA <= GPS_DATA_TMP;
      when "00100" => USB_DATA <= PARAMETER_LIST_TMP;
      when "01000" => USB_DATA <= READ_ERROR_TMP;
      when "10000" => USB_DATA <= COMP_DATA_TMP;
      when others => USB_DATA <= "00000000";
    end case;
  end process;

  USB_DATA_OUT <= USB_DATA when USB_WRITE_ENABLE = '1' else "ZZZZZZZZ";

end architecture a0 ; -- of USB_WRITE_HANDLER

--------------------------------------------------------------------------------
-- Object        : Entity design.EVENT_DATA_HANDLER
-- Last modified : Mon Feb 27 11:06:12 2012.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity EVENT_DATA_HANDLER is
  port(
    CLKRD           : in     std_logic;
    DATA_IN         : in     std_logic_vector(7 downto 0);
    DATA_READY      : in     std_logic;
    DATA_READY_FIFO : in     std_logic;
    DIN_VALID       : in     std_logic;
    RDEN            : out    std_logic;
    READOUT_BUSY    : out    std_logic;
    SYSRST          : in     std_logic;
    USB_DATA        : out    std_logic_vector(7 downto 0);
    WR              : in     std_logic;
    WR_EN           : out    std_logic);
end entity EVENT_DATA_HANDLER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.EVENT_DATA_HANDLER.a0
-- Last modified : Mon Feb 27 11:06:12 2012.
--------------------------------------------------------------------------------


architecture a0 of EVENT_DATA_HANDLER is

signal RDEN_TMP: std_logic ;
signal VALID_BUF1: std_logic ;
signal VALID_BUF1_DEL1: std_logic ;
signal VALID_BUF1_DEL2: std_logic ;
signal VALID_BUF2: std_logic ;
signal RST_VALID_BUF1: std_logic ;
signal RST_VALID_BUF2: std_logic ;
signal DATA_BUF1: std_logic_vector(7 downto 0) ;
signal DATA_BUF2: std_logic_vector(7 downto 0) ;
signal USB_DATA_TMP: std_logic_vector(7 downto 0) ;

begin

  RDEN <= RDEN_TMP;
  USB_DATA <= USB_DATA_TMP;
  READOUT_BUSY <= DATA_READY_FIFO or VALID_BUF1;
  WR_EN <= VALID_BUF1_DEL2 or VALID_BUF2;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_BUF1_DEL1 <= '0';
      VALID_BUF1_DEL2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then
      if RST_VALID_BUF1 = '1' then
        VALID_BUF1_DEL1 <= '0';
        VALID_BUF1_DEL2 <= '0';
      else
        VALID_BUF1_DEL1 <= VALID_BUF1;
        VALID_BUF1_DEL2 <= VALID_BUF1_DEL1;
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      RDEN_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '0') then -- RDEN changes on a negative clock edge
      if DATA_READY = '1' then
        if VALID_BUF1 = '0' then
          RDEN_TMP <= not RDEN_TMP;
        else
          RDEN_TMP <= '0';
        end if;
      else
        RDEN_TMP <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_BUF1 <= "00000000";
      DATA_BUF2 <= "00000000";
      VALID_BUF1 <= '0';
      VALID_BUF2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then
      if RST_VALID_BUF1 = '1' then
        VALID_BUF1 <= '0';
      elsif DIN_VALID = '1' then
        DATA_BUF1 <= DATA_IN;
        VALID_BUF1 <= DIN_VALID;
      end if;
      if RST_VALID_BUF2 = '1' then
        VALID_BUF2 <= '0';
      elsif DIN_VALID = '1' and VALID_BUF1 = '1' then
        VALID_BUF2 <= VALID_BUF1;
        DATA_BUF2 <= DATA_BUF1;
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      RST_VALID_BUF1 <= '0';
      RST_VALID_BUF2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then
      if WR = '1' then
        if VALID_BUF2  = '1' then
          RST_VALID_BUF2 <= '1';
        elsif VALID_BUF1_DEL2  = '1' then
          RST_VALID_BUF1 <= '1';
        end if;
      else
        RST_VALID_BUF1 <= '0';
        RST_VALID_BUF2 <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      USB_DATA_TMP <= "00000000";
    elsif (CLKRD'event and CLKRD = '1') then
      if VALID_BUF2 = '1' then
        USB_DATA_TMP <= DATA_BUF2;
      elsif VALID_BUF1 = '1' then
        USB_DATA_TMP <= DATA_BUF1;
      else
        USB_DATA_TMP <= USB_DATA_TMP;
      end if;
    end if;
  end process;

end architecture a0 ; -- of EVENT_DATA_HANDLER

--------------------------------------------------------------------------------
-- Object        : Entity design.DATA_CONTROLLER
-- Last modified : Mon Feb 27 11:40:49 2012.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity DATA_CONTROLLER is
  port(
    ADC_A0                  : out    std_logic;
    ADC_A1                  : out    std_logic;
    ADC_DATA                : in     std_logic_vector(7 downto 0);
    ADC_MODE                : out    std_logic;
    ADC_nCS                 : out    std_logic;
    ADC_nINT                : in     std_logic;
    ADC_nRD                 : out    std_logic;
    ADC_nWR_RDY             : in     std_logic;
    ALTITUDE                : in     std_logic_vector(63 downto 0);
    CLK10MHz                : in     std_logic;
    CLKRD                   : in     std_logic;
    COINC_TIME              : out    integer range 1000 downto 0;
    COMPDATA                : in     std_logic_vector(127 downto 0);
    COMPDATA_READOUT_DONE   : out    std_logic;
    COMPDATA_VALID          : in     std_logic;
    CTD_IN                  : in     std_logic_vector(31 downto 0);
    CTD_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
    CTP_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
    DAC_A0                  : out    std_logic;
    DAC_A1                  : out    std_logic;
    DAC_A2                  : out    std_logic;
    DAC_DATA_0              : out    std_logic;
    DAC_DATA_1              : out    std_logic;
    DAC_DATA_2              : out    std_logic;
    DAC_DATA_3              : out    std_logic;
    DAC_DATA_4              : out    std_logic;
    DAC_DATA_5              : out    std_logic;
    DAC_DATA_6              : out    std_logic;
    DAC_DATA_7              : out    std_logic;
    DAC_nCLR                : out    std_logic;
    DAC_nCS_GAIN            : out    std_logic;
    DAC_nCS_OFFSET          : out    std_logic;
    DAC_nLDAC               : out    std_logic;
    DAC_nRD                 : out    std_logic;
    DAC_nWR                 : out    std_logic;
    DATA_IN                 : in     std_logic_vector(7 downto 0);
    DATA_READY_FIFO         : in     std_logic;
    DIN_VALID               : in     std_logic;
    ERROR_READ_OUT          : out    std_logic;
    FAKE_DATA               : out    std_logic;
    FORCE_MASTER            : out    std_logic;
    GPS_FLAGS               : in     std_logic_vector(7 downto 0);
    GPS_PROG_ENABLE         : out    std_logic;
    GPS_TS_IN               : in     std_logic_vector(55 downto 0);
    GPS_TS_ONE_PPS          : in     std_logic_vector(55 downto 0);
    LATITUDE                : in     std_logic_vector(63 downto 0);
    LONGITUDE               : in     std_logic_vector(63 downto 0);
    MASTER                  : in     std_logic;
    NEW_DATA_WHILE_READOUT  : out    std_logic;
    ONE_PPS                 : in     std_logic;
    POST_TIME               : out    integer range 1600 downto 0;
    RDEN                    : out    std_logic;
    READ_BUSY_OUT           : out    std_logic;
    SAT_INFO                : in     std_logic_vector(487 downto 0);
    SERIAL_NUMBER           : in     std_logic_vector(9 downto 0);
    SLAVE_PRESENT           : in     std_logic;
    SOFT_RESET              : out    std_logic;
    STOP_READ_OUT           : out    std_logic;
    SYSRST                  : in     std_logic;
    TEMP                    : in     std_logic_vector(31 downto 0);
    THH1                    : out    std_logic_vector(11 downto 0);
    THH2                    : out    std_logic_vector(11 downto 0);
    THL1                    : out    std_logic_vector(11 downto 0);
    THL2                    : out    std_logic_vector(11 downto 0);
    TH_COUNTERS_IN          : in     std_logic_vector(63 downto 0);
    TIME_OUT_RESET          : out    std_logic;
    TOTAL_TIME              : out    integer range 2000 downto 0;
    TOTAL_TIME_3X           : out    integer range 6000 downto 0;
    TRIGGER_PATTERN         : in     std_logic_vector(15 downto 0);
    TR_CONDITION            : out    std_logic_vector(7 downto 0);
    TS_ONE_PPS_READOUT_DONE : out    std_logic;
    TS_ONE_PPS_VALID_IN     : in     std_logic;
    USB_DATA                : inout  std_logic_vector(7 downto 0);
    USB_RD                  : out    std_logic;
    USB_RXF                 : in     std_logic;
    USB_TXE                 : in     std_logic;
    USB_WR                  : out    std_logic;
    USB_WRITE_ENABLE        : out    std_logic;
    nSYSRST                 : in     std_logic);
end entity DATA_CONTROLLER;

--------------------------------------------------------------------------------
-- Object        : Architecture design.DATA_CONTROLLER.a0
-- Last modified : Mon Feb 27 11:40:49 2012.
--------------------------------------------------------------------------------

architecture a0 of DATA_CONTROLLER is

  signal USB_DATA_net                :  std_logic_vector(7 downto 0);
  signal WR_EN                       :  std_logic;
  signal READOUT_BUSY                :  std_logic;
  signal SEND_EVENT_DATA             :  std_logic;
  signal EVENT_WR                    :  std_logic;
  signal POST_TIME_OUT               :  std_logic_vector(15 downto 0);
  signal COINC_TIME_OUT              :  std_logic_vector(15 downto 0);
  signal PRE_TIME_OUT                :  std_logic_vector(15 downto 0);
  signal PARAMETER_LIST_VALID        :  std_logic;
  signal PARAMETER_LIST_READOUT_DONE :  std_logic;
  signal READ_ERROR_VALID            :  std_logic;
  signal READ_ERROR_READOUT_DONE     :  std_logic;
  signal READ_ERROR_DATA             :  std_logic_vector(7 downto 0);
  signal USB_WRITE_ENABLE_net        :  std_logic;
  signal USB_WRITE_BUSY              :  std_logic;
  signal USB_WRITE_REQUEST0          :  std_logic;
  signal TR_CONDITION_net            :  std_logic_vector(7 downto 0);
  signal PARAMETER_LIST              :  std_logic_vector(271 downto 0);
  signal SECOND_MESSAGE_ALLOWED      :  std_logic;

  component EVENT_DATA_HANDLER
    port(
      CLKRD           : in     std_logic;
      DATA_IN         : in     std_logic_vector(7 downto 0);
      DATA_READY      : in     std_logic;
      DATA_READY_FIFO : in     std_logic;
      DIN_VALID       : in     std_logic;
      RDEN            : out    std_logic;
      READOUT_BUSY    : out    std_logic;
      SYSRST          : in     std_logic;
      USB_DATA        : out    std_logic_vector(7 downto 0);
      WR              : in     std_logic;
      WR_EN           : out    std_logic);
  end component EVENT_DATA_HANDLER;

  component USB_WRITE_HANDLER
    port(
      ALTITUDE                    : in     std_logic_vector(63 downto 0);
      CLK10MHz                    : in     std_logic;
      CLKRD                       : in     std_logic;
      COINC_TIME                  : in     std_logic_vector(15 downto 0);
      COMPDATA                    : in     std_logic_vector(127 downto 0);
      COMPDATA_READOUT_DONE       : out    std_logic;
      COMPDATA_VALID              : in     std_logic;
      CTD_IN                      : in     std_logic_vector(31 downto 0);
      CTD_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
      CTP_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
      EVENT_DATA_IN               : in     std_logic_vector(7 downto 0);
      EVENT_READOUT_BUSY          : in     std_logic;
      EVENT_WR                    : out    std_logic;
      EVENT_WR_EN                 : in     std_logic;
      GPS_TS_IN                   : in     std_logic_vector(55 downto 0);
      GPS_TS_ONE_PPS              : in     std_logic_vector(55 downto 0);
      LATITUDE                    : in     std_logic_vector(63 downto 0);
      LONGITUDE                   : in     std_logic_vector(63 downto 0);
      NEW_DATA_WHILE_READOUT      : out    std_logic;
      PARAMETER_LIST              : in     std_logic_vector(271 downto 0);
      PARAMETER_LIST_READOUT_DONE : out    std_logic;
      PARAMETER_LIST_VALID        : in     std_logic;
      POST_TIME                   : in     std_logic_vector(15 downto 0);
      PRE_TIME                    : in     std_logic_vector(15 downto 0);
      READ_ERROR_DATA             : in     std_logic_vector(7 downto 0);
      READ_ERROR_READOUT_DONE     : out    std_logic;
      READ_ERROR_VALID            : in     std_logic;
      SAT_INFO                    : in     std_logic_vector(487 downto 0);
      SECOND_MESSAGE_ALLOWED      : in     std_logic;
      SEND_EVENT_DATA             : out    std_logic;
      START_WRITE_EVENT           : in     std_logic;
      SYSRST                      : in     std_logic;
      TEMP                        : in     std_logic_vector(31 downto 0);
      TH_COUNTERS_IN              : in     std_logic_vector(63 downto 0);
      TRIGGER_PATTERN             : in     std_logic_vector(15 downto 0);
      TR_CONDITION                : in     std_logic_vector(7 downto 0);
      TS_ONE_PPS_READOUT_DONE     : out    std_logic;
      TS_ONE_PPS_VALID_INPUT      : in     std_logic;
      USB_DATA_OUT                : out    std_logic_vector(7 downto 0);
      USB_TXE                     : in     std_logic;
      USB_WR                      : out    std_logic;
      USB_WRITE_BUSY              : out    std_logic;
      USB_WRITE_ENABLE            : in     std_logic;
      USB_WRITE_REQUEST           : out    std_logic);
  end component USB_WRITE_HANDLER;

  component USB_READ_HANDLER
    port(
      ADC_A0                      : out    std_logic;
      ADC_A1                      : out    std_logic;
      ADC_DATA_IN                 : in     std_logic_vector(7 downto 0);
      ADC_MODE                    : out    std_logic;
      ADC_nCS                     : out    std_logic;
      ADC_nINT                    : in     std_logic;
      ADC_nRD                     : out    std_logic;
      ADC_nWR_RDY                 : in     std_logic;
      CLK10MHz                    : in     std_logic;
      CLKRD                       : in     std_logic;
      COINC_TIME                  : out    integer range 1000 downto 0;
      COINC_TIME_OUT              : out    std_logic_vector(15 downto 0);
      DAC_A0                      : out    std_logic;
      DAC_A1                      : out    std_logic;
      DAC_A2                      : out    std_logic;
      DAC_DATA_0                  : out    std_logic;
      DAC_DATA_1                  : out    std_logic;
      DAC_DATA_2                  : out    std_logic;
      DAC_DATA_3                  : out    std_logic;
      DAC_DATA_4                  : out    std_logic;
      DAC_DATA_5                  : out    std_logic;
      DAC_DATA_6                  : out    std_logic;
      DAC_DATA_7                  : out    std_logic;
      DAC_nCLR                    : out    std_logic;
      DAC_nCS1                    : out    std_logic;
      DAC_nCS2                    : out    std_logic;
      DAC_nLDAC                   : out    std_logic;
      DAC_nRD                     : out    std_logic;
      DAC_nWR                     : out    std_logic;
      ERROR_READ_OUT              : out    std_logic;
      FAKE_DATA                   : out    std_logic;
      FORCE_MASTER                : out    std_logic;
      GPS_FLAGS                   : in     std_logic_vector(7 downto 0);
      GPS_PROG_ENABLE             : out    std_logic;
      MASTER                      : in     std_logic;
      ONE_PPS                     : in     std_logic;
      PARAMETER_LIST              : out    std_logic_vector(271 downto 0);
      PARAMETER_LIST_READOUT_DONE : in     std_logic;
      PARAMETER_LIST_VALID        : out    std_logic;
      POST_TIME                   : out    integer range 1600 downto 0;
      POST_TIME_OUT               : out    std_logic_vector(15 downto 0);
      PRE_TIME_OUT                : out    std_logic_vector(15 downto 0);
      READ_BUSY_OUT               : out    std_logic;
      READ_ERROR_DATA             : out    std_logic_vector(7 downto 0);
      READ_ERROR_READOUT_DONE     : in     std_logic;
      READ_ERROR_VALID            : out    std_logic;
      SECOND_MESSAGE_ALLOWED      : out    std_logic;
      SERIAL_NUMBER               : in     std_logic_vector(9 downto 0);
      SLAVE_PRESENT               : in     std_logic;
      SOFT_RESET                  : out    std_logic;
      STOP_READ_OUT               : out    std_logic;
      SYSRST                      : in     std_logic;
      THH1                        : out    std_logic_vector(11 downto 0);
      THH2                        : out    std_logic_vector(11 downto 0);
      THL1                        : out    std_logic_vector(11 downto 0);
      THL2                        : out    std_logic_vector(11 downto 0);
      TOTAL_TIME                  : out    integer range 2000 downto 0;
      TOTAL_TIME_3X               : out    integer range 6000 downto 0;
      TR_CONDITION                : out    std_logic_vector(7 downto 0);
      USB_DATA_IN                 : in     std_logic_vector(7 downto 0);
      USB_RD                      : out    std_logic;
      USB_RXF                     : in     std_logic;
      USB_WRITE_BUSY              : in     std_logic;
      USB_WRITE_ENABLE            : out    std_logic;
      USB_WRITE_REQUEST           : in     std_logic);
  end component USB_READ_HANDLER;

  component READOUT_TIMED_OUT
    port(
      CLK10MHz          : in     std_logic;
      ONE_PPS           : in     std_logic;
      TIME_OUT_RESET    : out    std_logic;
      USB_RXF           : in     std_logic;
      USB_TXE           : in     std_logic;
      USB_WRITE_REQUEST : in     std_logic;
      nSYSRST           : in     std_logic);
  end component READOUT_TIMED_OUT;

begin
  USB_WRITE_ENABLE <= USB_WRITE_ENABLE_net;
  TR_CONDITION <= TR_CONDITION_net;
  u1: EVENT_DATA_HANDLER
    port map(
      CLKRD           => CLKRD,
      DATA_IN         => DATA_IN,
      DATA_READY      => SEND_EVENT_DATA,
      DATA_READY_FIFO => DATA_READY_FIFO,
      DIN_VALID       => DIN_VALID,
      RDEN            => RDEN,
      READOUT_BUSY    => READOUT_BUSY,
      SYSRST          => SYSRST,
      USB_DATA        => USB_DATA_net,
      WR              => EVENT_WR,
      WR_EN           => WR_EN);

  u2: USB_WRITE_HANDLER
    port map(
      ALTITUDE                    => ALTITUDE,
      CLK10MHz                    => CLK10MHz,
      CLKRD                       => CLKRD,
      COINC_TIME                  => COINC_TIME_OUT,
      COMPDATA                    => COMPDATA,
      COMPDATA_READOUT_DONE       => COMPDATA_READOUT_DONE,
      COMPDATA_VALID              => COMPDATA_VALID,
      CTD_IN                      => CTD_IN,
      CTD_TS_ONE_PPS              => CTD_TS_ONE_PPS,
      CTP_TS_ONE_PPS              => CTP_TS_ONE_PPS,
      EVENT_DATA_IN               => USB_DATA_net,
      EVENT_READOUT_BUSY          => READOUT_BUSY,
      EVENT_WR                    => EVENT_WR,
      EVENT_WR_EN                 => WR_EN,
      GPS_TS_IN                   => GPS_TS_IN,
      GPS_TS_ONE_PPS              => GPS_TS_ONE_PPS,
      LATITUDE                    => LATITUDE,
      LONGITUDE                   => LONGITUDE,
      NEW_DATA_WHILE_READOUT      => NEW_DATA_WHILE_READOUT,
      PARAMETER_LIST              => PARAMETER_LIST,
      PARAMETER_LIST_READOUT_DONE => PARAMETER_LIST_READOUT_DONE,
      PARAMETER_LIST_VALID        => PARAMETER_LIST_VALID,
      POST_TIME                   => POST_TIME_OUT,
      PRE_TIME                    => PRE_TIME_OUT,
      READ_ERROR_DATA             => READ_ERROR_DATA,
      READ_ERROR_READOUT_DONE     => READ_ERROR_READOUT_DONE,
      READ_ERROR_VALID            => READ_ERROR_VALID,
      SAT_INFO                    => SAT_INFO,
      SECOND_MESSAGE_ALLOWED      => SECOND_MESSAGE_ALLOWED,
      SEND_EVENT_DATA             => SEND_EVENT_DATA,
      START_WRITE_EVENT           => DATA_READY_FIFO,
      SYSRST                      => SYSRST,
      TEMP                        => TEMP,
      TH_COUNTERS_IN              => TH_COUNTERS_IN,
      TRIGGER_PATTERN             => TRIGGER_PATTERN,
      TR_CONDITION                => TR_CONDITION_net,
      TS_ONE_PPS_READOUT_DONE     => TS_ONE_PPS_READOUT_DONE,
      TS_ONE_PPS_VALID_INPUT      => TS_ONE_PPS_VALID_IN,
      USB_DATA_OUT                => USB_DATA,
      USB_TXE                     => USB_TXE,
      USB_WR                      => USB_WR,
      USB_WRITE_BUSY              => USB_WRITE_BUSY,
      USB_WRITE_ENABLE            => USB_WRITE_ENABLE_net,
      USB_WRITE_REQUEST           => USB_WRITE_REQUEST0);

  u4: USB_READ_HANDLER
    port map(
      ADC_A0                      => ADC_A0,
      ADC_A1                      => ADC_A1,
      ADC_DATA_IN                 => ADC_DATA,
      ADC_MODE                    => ADC_MODE,
      ADC_nCS                     => ADC_nCS,
      ADC_nINT                    => ADC_nINT,
      ADC_nRD                     => ADC_nRD,
      ADC_nWR_RDY                 => ADC_nWR_RDY,
      CLK10MHz                    => CLK10MHz,
      CLKRD                       => CLKRD,
      COINC_TIME                  => COINC_TIME,
      COINC_TIME_OUT              => COINC_TIME_OUT,
      DAC_A0                      => DAC_A0,
      DAC_A1                      => DAC_A1,
      DAC_A2                      => DAC_A2,
      DAC_DATA_0                  => DAC_DATA_0,
      DAC_DATA_1                  => DAC_DATA_1,
      DAC_DATA_2                  => DAC_DATA_2,
      DAC_DATA_3                  => DAC_DATA_3,
      DAC_DATA_4                  => DAC_DATA_4,
      DAC_DATA_5                  => DAC_DATA_5,
      DAC_DATA_6                  => DAC_DATA_6,
      DAC_DATA_7                  => DAC_DATA_7,
      DAC_nCLR                    => DAC_nCLR,
      DAC_nCS1                    => DAC_nCS_OFFSET,
      DAC_nCS2                    => DAC_nCS_GAIN,
      DAC_nLDAC                   => DAC_nLDAC,
      DAC_nRD                     => DAC_nRD,
      DAC_nWR                     => DAC_nWR,
      ERROR_READ_OUT              => ERROR_READ_OUT,
      FAKE_DATA                   => FAKE_DATA,
      FORCE_MASTER                => FORCE_MASTER,
      GPS_FLAGS                   => GPS_FLAGS,
      GPS_PROG_ENABLE             => GPS_PROG_ENABLE,
      MASTER                      => MASTER,
      ONE_PPS                     => ONE_PPS,
      PARAMETER_LIST              => PARAMETER_LIST,
      PARAMETER_LIST_READOUT_DONE => PARAMETER_LIST_READOUT_DONE,
      PARAMETER_LIST_VALID        => PARAMETER_LIST_VALID,
      POST_TIME                   => POST_TIME,
      POST_TIME_OUT               => POST_TIME_OUT,
      PRE_TIME_OUT                => PRE_TIME_OUT,
      READ_BUSY_OUT               => READ_BUSY_OUT,
      READ_ERROR_DATA             => READ_ERROR_DATA,
      READ_ERROR_READOUT_DONE     => READ_ERROR_READOUT_DONE,
      READ_ERROR_VALID            => READ_ERROR_VALID,
      SECOND_MESSAGE_ALLOWED      => SECOND_MESSAGE_ALLOWED,
      SERIAL_NUMBER               => SERIAL_NUMBER,
      SLAVE_PRESENT               => SLAVE_PRESENT,
      SOFT_RESET                  => SOFT_RESET,
      STOP_READ_OUT               => STOP_READ_OUT,
      SYSRST                      => SYSRST,
      THH1                        => THH1,
      THH2                        => THH2,
      THL1                        => THL1,
      THL2                        => THL2,
      TOTAL_TIME                  => TOTAL_TIME,
      TOTAL_TIME_3X               => TOTAL_TIME_3X,
      TR_CONDITION                => TR_CONDITION_net,
      USB_DATA_IN                 => USB_DATA,
      USB_RD                      => USB_RD,
      USB_RXF                     => USB_RXF,
      USB_WRITE_BUSY              => USB_WRITE_BUSY,
      USB_WRITE_ENABLE            => USB_WRITE_ENABLE_net,
      USB_WRITE_REQUEST           => USB_WRITE_REQUEST0);

  u0: READOUT_TIMED_OUT
    port map(
      CLK10MHz          => CLK10MHz,
      ONE_PPS           => ONE_PPS,
      TIME_OUT_RESET    => TIME_OUT_RESET,
      USB_RXF           => USB_RXF,
      USB_TXE           => USB_TXE,
      USB_WRITE_REQUEST => USB_WRITE_REQUEST0,
      nSYSRST           => nSYSRST);

end architecture a0 ; -- of DATA_CONTROLLER

--------------------------------------------------------------------------------
-- Object        : Entity design.CLK_DIV
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity CLK_DIV is
  port(
    CLK10MHz : in     std_logic;
    CLKRD    : out    std_logic;
    nSYSRST  : in     std_logic);
end entity CLK_DIV;

--------------------------------------------------------------------------------
-- Object        : Architecture design.CLK_DIV.a0
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------


architecture a0 of CLK_DIV is

signal CLKRD_TMP: std_logic;

begin

  CLKRD <= CLKRD_TMP;

  process(CLK10MHz, nSYSRST)
  begin
    if (nSYSRST = '0') then
      CLKRD_TMP <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '0') then -- let op: CLKRD gaat op een negatieve flank
      CLKRD_TMP <=  not CLKRD_TMP;
    end if;
  end process;

end architecture a0 ; -- of CLK_DIV

--------------------------------------------------------------------------------
-- Object        : Entity design.LVDS_MUX
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity LVDS_MUX is
  port(
    CLK10MHz        : in     std_logic;
    CLK200MHz       : in     std_logic;
    COINC           : out    std_logic;
    COINC_MASTER    : in     std_logic;
    GPS_DATA_MASTER : in     std_logic;
    GPS_DATA_OUT    : out    std_logic;
    LVDS_IN1        : in     std_logic;
    LVDS_IN2        : in     std_logic;
    LVDS_IN3        : in     std_logic;
    LVDS_IN4        : in     std_logic;
    LVDS_OUT1       : out    std_logic;
    LVDS_OUT2       : out    std_logic;
    LVDS_OUT3       : out    std_logic;
    LVDS_OUT4       : out    std_logic;
    MASTER          : in     std_logic;
    MH1             : in     std_logic;
    MH2             : in     std_logic;
    ML1             : in     std_logic;
    ML2             : in     std_logic;
    ONE_PPS_MASTER  : in     std_logic;
    ONE_PPS_OUT     : out    std_logic;
    SH1             : out    std_logic;
    SH2             : out    std_logic;
    SL1             : out    std_logic;
    SL2             : out    std_logic;
    SYSRST          : in     std_logic);
end entity LVDS_MUX;

--------------------------------------------------------------------------------
-- Object        : Architecture design.LVDS_MUX.a0
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------


architecture a0 of LVDS_MUX is

signal ONE_PPS_TMP: std_logic ;
signal ONE_PPS_DEL1: std_logic ;
signal ONE_PPS_DEL2: std_logic ;
signal STARTUP_COUNT: std_logic_vector(3 downto 0);
signal STARTUP_BLOCK: std_logic ;

begin

  SL1 <= LVDS_IN1 when MASTER = '1' else '1';
  SH1 <= LVDS_IN2 when MASTER = '1' else '1';
  SL2 <= LVDS_IN3 when MASTER = '1' else '1';
  SH2 <= LVDS_IN4 when MASTER = '1' else '1';

  GPS_DATA_OUT <= GPS_DATA_MASTER when MASTER = '1' else LVDS_IN1;
  ONE_PPS_TMP <= ONE_PPS_MASTER when MASTER = '1' else LVDS_IN2;
  ONE_PPS_OUT <= ONE_PPS_TMP;

  process(CLK200MHz, STARTUP_BLOCK)
  begin
    if (STARTUP_BLOCK = '1') then
      COINC <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MASTER = '1' then
        COINC <= COINC_MASTER;
      else
        COINC <= LVDS_IN3;
      end if;
    end if;
  end process;

  LVDS_OUT1 <= GPS_DATA_MASTER when MASTER = '1' else ML1;
  LVDS_OUT2 <= ONE_PPS_MASTER when MASTER = '1' else MH1;
  LVDS_OUT3 <= COINC_MASTER when MASTER = '1' else ML2;
  LVDS_OUT4 <= '0' when MASTER = '1' else MH2;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ONE_PPS_DEL1 <= '0';
      ONE_PPS_DEL2 <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      ONE_PPS_DEL1 <= ONE_PPS_TMP;
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      STARTUP_COUNT <= "0000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if STARTUP_COUNT = "1000" then -- after 8 seconds
        STARTUP_COUNT <= STARTUP_COUNT; -- latch countvalue 8
      elsif ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then -- at rising edge of PPS
        STARTUP_COUNT <= STARTUP_COUNT + "0001"; -- increase counter
      end if;
    end if;
  end process;

  STARTUP_BLOCK <= not STARTUP_COUNT(3);

end architecture a0 ; -- of LVDS_MUX

--------------------------------------------------------------------------------
-- Object        : Entity design.THRESHOLD_COUNTERS
-- Last modified : Thu Jan 13 14:40:30 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity THRESHOLD_COUNTERS is
  port(
    CLK200MHz       : in     std_logic;
    MH1             : in     std_logic;
    MH2             : in     std_logic;
    ML1             : in     std_logic;
    ML2             : in     std_logic;
    ONE_PPS         : in     std_logic;
    SYSRST          : in     std_logic;
    TH_COUNTERS_OUT : out    std_logic_vector(63 downto 0));
end entity THRESHOLD_COUNTERS;

--------------------------------------------------------------------------------
-- Object        : Architecture design.THRESHOLD_COUNTERS.a0
-- Last modified : Thu Jan 13 14:40:30 2011.
--------------------------------------------------------------------------------


architecture a0 of THRESHOLD_COUNTERS is

signal ML1_DEL: std_logic ;
signal MH1_DEL: std_logic ;
signal ML2_DEL: std_logic ;
signal MH2_DEL: std_logic ;
signal ONE_PPS_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious ONE_PPS with the 200MHz
signal ONE_PPS_DEL2: std_logic ;
signal ONE_PPS_DEL3: std_logic ;
signal ML1_COUNTER: std_logic_vector(15 downto 0) ;
signal MH1_COUNTER: std_logic_vector(15 downto 0) ;
signal ML2_COUNTER: std_logic_vector(15 downto 0) ;
signal MH2_COUNTER: std_logic_vector(15 downto 0) ;

begin

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_DEL <= '0';
      MH1_DEL <= '0';
      ML2_DEL <= '0';
      MH2_DEL <= '0';
      ONE_PPS_DEL1 <= '0';
      ONE_PPS_DEL2 <= '0';
      ONE_PPS_DEL3 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      ML1_DEL <= ML1;
      MH1_DEL <= MH1;
      ML2_DEL <= ML2;
      MH2_DEL <= MH2;
      ONE_PPS_DEL1 <= ONE_PPS;
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;
      ONE_PPS_DEL3 <= ONE_PPS_DEL2;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        ML1_COUNTER <= "0000000000000000";
      elsif ML1 = '1' and ML1_DEL = '0' then
        ML1_COUNTER <= ML1_COUNTER + "0000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH1_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        MH1_COUNTER <= "0000000000000000";
      elsif MH1 = '1' and MH1_DEL = '0' then
        MH1_COUNTER <= MH1_COUNTER + "0000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML2_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        ML2_COUNTER <= "0000000000000000";
      elsif ML2 = '1' and ML2_DEL = '0' then
        ML2_COUNTER <= ML2_COUNTER + "0000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH2_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        MH2_COUNTER <= "0000000000000000";
      elsif MH2 = '1' and MH2_DEL = '0' then
        MH2_COUNTER <= MH2_COUNTER + "0000000000000001";
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TH_COUNTERS_OUT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then
        TH_COUNTERS_OUT(15 downto 0) <= ML1_COUNTER;
        TH_COUNTERS_OUT(31 downto 16) <= MH1_COUNTER;
        TH_COUNTERS_OUT(47 downto 32) <= ML2_COUNTER;
        TH_COUNTERS_OUT(63 downto 48) <= MH2_COUNTER;
      end if;
    end if;
  end process;

end architecture a0 ; -- of THRESHOLD_COUNTERS

--------------------------------------------------------------------------------
-- Object        : Entity design.TRIGGER_MATRIX
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity TRIGGER_MATRIX is
  port(
    BLOCK_COINC       : in     std_logic;
    CLK10MHz          : in     std_logic;
    CLK200MHz         : in     std_logic;
    COINC_TO_END_TIME : out    std_logic;
    COMPH1            : in     std_logic;
    COMPH2            : in     std_logic;
    COMPL1            : in     std_logic;
    COMPL2            : in     std_logic;
    EXT_TR            : in     std_logic;
    MASTER            : in     std_logic;
    MH1               : in     std_logic;
    MH2               : in     std_logic;
    ML1               : in     std_logic;
    ML2               : in     std_logic;
    ONE_PPS           : in     std_logic;
    POST_TIME         : in     integer range 1600 downto 0;
    SH1_IN            : in     std_logic;
    SH2_IN            : in     std_logic;
    SL1_IN            : in     std_logic;
    SL2_IN            : in     std_logic;
    SLAVE_PRESENT     : in     std_logic;
    STARTUP_BLOCK_OUT : out    std_logic;
    SYSRST            : in     std_logic;
    TRIGGER_PATTERN   : out    std_logic_vector(15 downto 0);
    TR_CONDITION      : in     std_logic_vector(7 downto 0));
end entity TRIGGER_MATRIX;

--------------------------------------------------------------------------------
-- Object        : Architecture design.TRIGGER_MATRIX.a0
-- Last modified : Wed Jan 12 14:01:58 2011.
--------------------------------------------------------------------------------


architecture a0 of TRIGGER_MATRIX is

signal SL1: std_logic ;
signal SL2: std_logic ;
signal SH1: std_logic ;
signal SH2: std_logic ;
signal ML1_DEL1: std_logic ;
signal ML2_DEL1: std_logic ;
signal MH1_DEL1: std_logic ;
signal MH2_DEL1: std_logic ;
signal ML1_DEL2: std_logic ;
signal ML2_DEL2: std_logic ;
signal MH1_DEL2: std_logic ;
signal MH2_DEL2: std_logic ;
signal ML1_DEL3: std_logic ;
signal ML2_DEL3: std_logic ;
signal MH1_DEL3: std_logic ;
signal MH2_DEL3: std_logic ;
signal ML1_DEL4: std_logic ;
signal ML2_DEL4: std_logic ;
signal MH1_DEL4: std_logic ;
signal MH2_DEL4: std_logic ;
signal SL1_DEL1: std_logic ;
signal SL2_DEL1: std_logic ;
signal SH1_DEL1: std_logic ;
signal SH2_DEL1: std_logic ;
signal SL1_DEL2: std_logic ;
signal SL2_DEL2: std_logic ;
signal SH1_DEL2: std_logic ;
signal SH2_DEL2: std_logic ;
signal SL1_DEL3: std_logic ;
signal SL2_DEL3: std_logic ;
signal SH1_DEL3: std_logic ;
signal SH2_DEL3: std_logic ;
signal SL1_DEL4: std_logic ;
signal SL2_DEL4: std_logic ;
signal SH1_DEL4: std_logic ;
signal SH2_DEL4: std_logic ;
signal ML1_LATCHED: std_logic ;
signal ML2_LATCHED: std_logic ;
signal MH1_LATCHED: std_logic ;
signal MH2_LATCHED: std_logic ;
signal SL1_LATCHED: std_logic ;
signal SL2_LATCHED: std_logic ;
signal SH1_LATCHED: std_logic ;
signal SH2_LATCHED: std_logic ;
signal ML1_NEW: std_logic ;
signal ML2_NEW: std_logic ;
signal MH1_NEW: std_logic ;
signal MH2_NEW: std_logic ;
signal SL1_NEW: std_logic ;
signal SL2_NEW: std_logic ;
signal SH1_NEW: std_logic ;
signal SH2_NEW: std_logic ;
signal TR_CONDITION1: std_logic ;
signal TR_CONDITION2: std_logic ;
signal TR_CONDITION3: std_logic ;
signal TR_CONDITION4: std_logic ;
signal TR_CONDITION5: std_logic ;
signal TR_CONDITION6: std_logic ;
signal TR_CONDITION7: std_logic ;
signal TR_CONDITION8: std_logic ;
signal TR_CONDITION9: std_logic ;
signal TR_CONDITION10: std_logic ;
signal TR_CONDITION11: std_logic ;
signal TR_CONDITION12: std_logic ;
signal TR_CONDITION13: std_logic ;
signal TR_CONDITION14: std_logic ;
signal TR_CONDITION15: std_logic ;
signal TR_CONDITION16: std_logic ;
signal TR_CONDITION17: std_logic ;
signal TR_CONDITION18: std_logic ;
signal TR_CONDITION19: std_logic ;
signal TR_CONDITION20: std_logic ;
signal TR_CONDITION21: std_logic ;
signal TR_CONDITION22: std_logic ;
signal TR_CONDITION23: std_logic ;
signal TR_CONDITION24: std_logic ;
signal TR_CONDITION25: std_logic ;
signal TR_CONDITION26: std_logic ;
signal TR_CONDITION27: std_logic ;
signal TR_CONDITION28: std_logic ;
signal TR_CONDITION29: std_logic ;
signal TR_CONDITION30: std_logic ;
signal TR_CONDITION1_NEW: std_logic ;
signal TR_CONDITION2_NEW: std_logic ;
signal TR_CONDITION3_NEW: std_logic ;
signal TR_CONDITION4_NEW: std_logic ;
signal TR_CONDITION5_NEW: std_logic ;
signal TR_CONDITION6_NEW: std_logic ;
signal TR_CONDITION7_NEW: std_logic ;
signal TR_CONDITION8_NEW: std_logic ;
signal TR_CONDITION9_NEW: std_logic ;
signal TR_CONDITION10_NEW: std_logic ;
signal TR_CONDITION11_NEW: std_logic ;
signal TR_CONDITION12_NEW: std_logic ;
signal TR_CONDITION13_NEW: std_logic ;
signal TR_CONDITION14_NEW: std_logic ;
signal TR_CONDITION15_NEW: std_logic ;
signal TR_CONDITION16_NEW: std_logic ;
signal TR_CONDITION17_NEW: std_logic ;
signal TR_CONDITION18_NEW: std_logic ;
signal TR_CONDITION19_NEW: std_logic ;
signal TR_CONDITION20_NEW: std_logic ;
signal TR_CONDITION21_NEW: std_logic ;
signal TR_CONDITION22_NEW: std_logic ;
signal TR_CONDITION23_NEW: std_logic ;
signal TR_CONDITION24_NEW: std_logic ;
signal TR_CONDITION25_NEW: std_logic ;
signal TR_CONDITION26_NEW: std_logic ;
signal TR_CONDITION27_NEW: std_logic ;
signal TR_CONDITION28_NEW: std_logic ;
signal TR_CONDITION29_NEW: std_logic ;
signal TR_CONDITION30_NEW: std_logic ;
signal TR_CONDITION1_DEL: std_logic ;
signal TR_CONDITION2_DEL: std_logic ;
signal TR_CONDITION3_DEL: std_logic ;
signal TR_CONDITION4_DEL: std_logic ;
signal TR_CONDITION5_DEL: std_logic ;
signal TR_CONDITION9_DEL: std_logic ;
signal TR_CONDITION12_DEL: std_logic ;
signal TR_CONDITION14_DEL: std_logic ;
signal TR_CONDITION1_NEW_DEL: std_logic ;
signal TR_CONDITION2_NEW_DEL: std_logic ;
signal TR_CONDITION3_NEW_DEL: std_logic ;
signal TR_CONDITION4_NEW_DEL: std_logic ;
signal TR_CONDITION5_NEW_DEL: std_logic ;
signal TR_CONDITION9_NEW_DEL: std_logic ;
signal TR_CONDITION12_NEW_DEL: std_logic ;
signal TR_CONDITION14_NEW_DEL: std_logic ;
signal SCINT_LATCH: std_logic ; -- Latched de triggervoorwaarden zoals MH1, SH1 enz, Aktief als aan de triggervoorwaarden voldaan is.
signal SCINT_LATCH_DEL: std_logic ; -- Nodig voor opgaande flank detectie
signal SCINT_PATTERN: std_logic_vector(5 downto 0); -- The 6 LSB bits of TR_CONDITION selects a SCINT_PATTERN; TR_CONDITION(6) selects the ext. trigger
signal TRIGGER_PATTERN_TMP: std_logic_vector(15 downto 0); -- Tijdelijke latching van het triggerpatroon voor de master en slave signalen. De comparatorsignalen worden later ingeklokt.
-- signal CAL_EXTTRIG_PATTERN: std_logic_vector(1 downto 0); -- TR_CONDITION(7) selects a calibration; TR_CONDITION(6) selects the ext. trigger
signal SCINT_COINC: std_logic ; -- Selected scintillator trigger
signal SCINT_COINC_DEL: std_logic ;
signal COINC_TMP: std_logic ;
signal COINC_DEL: std_logic ;
signal COINC_TO_END_TIME_TMP: std_logic ; -- Time from negative edge of COINC to end of POST_TIME
signal COINC_TO_END_TIME_DEL_TMP: std_logic ;
signal BEGIN_COINC_TO_END_TIME_TMP: std_logic ; -- Time from positive edge of COINC to end of POST_TIME
signal COINC_TO_END_TIME_CNT: integer range 1600 downto 0 ; -- Counter from end COINC to end of POST_TIME
signal BLOCK_START_OF_COINC: std_logic ; -- This signal is the OR of all signals which prevent starting COINC.
signal BLOCK_COINC_SLAVE: std_logic ; -- Dit signaal komt op als de fifo's in de slave vol zitten. De informatie zit in de threshold signalen
signal EXT_TR_DEL: std_logic ;
signal CAL_COUNT: std_logic_vector(22 downto 0); -- Calibration counter Full scale is about 2^23 times 100ns is 0.84 seconds
signal CAL_TR: std_logic ;
signal CAL_TR_DEL1: std_logic ;
signal CAL_TR_DEL2: std_logic ;

-- Next signals are necessary to disable coint at startup, otherwise there will be a false hit
signal ONE_PPS_DEL1: std_logic ;
signal ONE_PPS_DEL2: std_logic ;
signal ONE_PPS_DEL3: std_logic ;
signal STARTUP_COUNT: std_logic_vector(3 downto 0); -- Counts 8 seconds from startup to disable coinc
signal STARTUP_BLOCK: std_logic ;

begin

  SCINT_PATTERN <= TR_CONDITION(5 downto 0);
--  CAL_EXTTRIG_PATTERN <= TR_CONDITION(7 downto 6);
  COINC_TO_END_TIME <= BEGIN_COINC_TO_END_TIME_TMP;
  STARTUP_BLOCK_OUT <= STARTUP_BLOCK;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      SL1 <= '0';
      SL2 <= '0';
      SH1 <= '0';
      SH2 <= '0';
      BLOCK_COINC_SLAVE <= '0';
      SCINT_LATCH_DEL <= '0';
      EXT_TR_DEL <= '0';
      SCINT_COINC_DEL <= '0';
      COINC_DEL <= '0';
      COINC_TO_END_TIME_DEL_TMP <= '0';
      CAL_TR <= '0';
      CAL_TR_DEL1 <= '0';
      CAL_TR_DEL2 <= '0';
      TR_CONDITION1_DEL <= '0';
      TR_CONDITION2_DEL <= '0';
      TR_CONDITION3_DEL <= '0';
      TR_CONDITION4_DEL <= '0';
      TR_CONDITION5_DEL <= '0';
      TR_CONDITION9_DEL <= '0';
      TR_CONDITION12_DEL <= '0';
      TR_CONDITION14_DEL <= '0';
      TR_CONDITION1_NEW_DEL <= '0';
      TR_CONDITION2_NEW_DEL <= '0';
      TR_CONDITION3_NEW_DEL <= '0';
      TR_CONDITION4_NEW_DEL <= '0';
      TR_CONDITION5_NEW_DEL <= '0';
      TR_CONDITION9_NEW_DEL <= '0';
      TR_CONDITION12_NEW_DEL <= '0';
      TR_CONDITION14_NEW_DEL <= '0';
      ML1_DEL1 <= '0';
      ML2_DEL1 <= '0';
      MH1_DEL1 <= '0';
      MH2_DEL1 <= '0';
      ML1_DEL2 <= '0';
      ML2_DEL2 <= '0';
      MH1_DEL2 <= '0';
      MH2_DEL2 <= '0';
      ML1_DEL3 <= '0';
      ML2_DEL3 <= '0';
      MH1_DEL3 <= '0';
      MH2_DEL3 <= '0';
      ML1_DEL4 <= '0';
      ML2_DEL4 <= '0';
      MH1_DEL4 <= '0';
      MH2_DEL4 <= '0';
      SL1_DEL1 <= '0';
      SL2_DEL1 <= '0';
      SH1_DEL1 <= '0';
      SH2_DEL1 <= '0';
      SL1_DEL2 <= '0';
      SL2_DEL2 <= '0';
      SH1_DEL2 <= '0';
      SH2_DEL2 <= '0';
      SL1_DEL3 <= '0';
      SL2_DEL3 <= '0';
      SH1_DEL3 <= '0';
      SH2_DEL3 <= '0';
      SL1_DEL4 <= '0';
      SL2_DEL4 <= '0';
      SH1_DEL4 <= '0';
      SH2_DEL4 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      SCINT_LATCH_DEL <= SCINT_LATCH;
      COINC_TO_END_TIME_DEL_TMP <= COINC_TO_END_TIME_TMP;
      SCINT_COINC_DEL <= SCINT_COINC;
      COINC_DEL <= COINC_TMP;
      EXT_TR_DEL <= EXT_TR;
      CAL_TR <= CAL_COUNT(22);
      CAL_TR_DEL1 <= CAL_TR;
      CAL_TR_DEL2 <= CAL_TR_DEL1;
      TR_CONDITION1_DEL <= TR_CONDITION1;
      TR_CONDITION2_DEL <= TR_CONDITION2;
      TR_CONDITION3_DEL <= TR_CONDITION3;
      TR_CONDITION4_DEL <= TR_CONDITION4;
      TR_CONDITION5_DEL <= TR_CONDITION5;
      TR_CONDITION9_DEL <= TR_CONDITION9;
      TR_CONDITION12_DEL <= TR_CONDITION12;
      TR_CONDITION14_DEL <= TR_CONDITION14;
      TR_CONDITION1_NEW_DEL <= TR_CONDITION1_NEW;
      TR_CONDITION2_NEW_DEL <= TR_CONDITION2_NEW;
      TR_CONDITION3_NEW_DEL <= TR_CONDITION3_NEW;
      TR_CONDITION4_NEW_DEL <= TR_CONDITION4_NEW;
      TR_CONDITION5_NEW_DEL <= TR_CONDITION5_NEW;
      TR_CONDITION9_NEW_DEL <= TR_CONDITION9_NEW;
      TR_CONDITION12_NEW_DEL <= TR_CONDITION12_NEW;
      TR_CONDITION14_NEW_DEL <= TR_CONDITION14_NEW;
      ML1_DEL1 <= ML1;
      ML1_DEL2 <= ML1_DEL1;
      ML1_DEL3 <= ML1_DEL2;
      ML1_DEL4 <= ML1_DEL3;
      ML2_DEL1 <= ML2;
      ML2_DEL2 <= ML2_DEL1;
      ML2_DEL3 <= ML2_DEL2;
      ML2_DEL4 <= ML2_DEL3;
      MH1_DEL1 <= MH1;
      MH1_DEL2 <= MH1_DEL1;
      MH1_DEL3 <= MH1_DEL2;
      MH1_DEL4 <= MH1_DEL3;
      MH2_DEL1 <= MH2;
      MH2_DEL2 <= MH2_DEL1;
      MH2_DEL3 <= MH2_DEL2;
      MH2_DEL4 <= MH2_DEL3;

      SL1_DEL1 <= SL1;
      SL1_DEL2 <= SL1_DEL1;
      SL1_DEL3 <= SL1_DEL2;
      SL1_DEL4 <= SL1_DEL3;
      SL2_DEL1 <= SL2;
      SL2_DEL2 <= SL2_DEL1;
      SL2_DEL3 <= SL2_DEL2;
      SL2_DEL4 <= SL2_DEL3;
      SH1_DEL1 <= SH1;
      SH1_DEL2 <= SH1_DEL1;
      SH1_DEL3 <= SH1_DEL2;
      SH1_DEL4 <= SH1_DEL3;
      SH2_DEL1 <= SH2;
      SH2_DEL2 <= SH2_DEL1;
      SH2_DEL3 <= SH2_DEL2;
      SH2_DEL4 <= SH2_DEL3;
      if SLAVE_PRESENT = '1' then
        if SL1_IN = '0' and SL2_IN = '0' and SH1_IN = '1' and SH2_IN = '1' then
          BLOCK_COINC_SLAVE <= '1';
          SL1 <= '0';
          SL2 <= '0';
          SH1 <= '0';
          SH2 <= '0';
        else
          BLOCK_COINC_SLAVE <= '0';
          if SH1_IN = '1' then
            SL1 <= '1';
          else
            SL1 <= SL1_IN;
          end if;
          if SH2_IN = '1' then
            SL2 <= '1';
          else
            SL2 <= SL2_IN;
          end if;
          SH1 <= SH1_IN;
          SH2 <= SH2_IN;
        end if;
      else
        BLOCK_COINC_SLAVE <= '0';
        SL1 <= '0';
        SL2 <= '0';
        SH1 <= '0';
        SH2 <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      CAL_COUNT <= "00000000000000000000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      CAL_COUNT <= CAL_COUNT + "00000000000000000000001";
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ONE_PPS_DEL1 <= '0';
      ONE_PPS_DEL2 <= '0';
      ONE_PPS_DEL3 <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      ONE_PPS_DEL1 <= ONE_PPS;
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;
      ONE_PPS_DEL3 <= ONE_PPS_DEL2;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      STARTUP_COUNT <= "0000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if STARTUP_COUNT = "1000" then -- Als er 8 sekonden geteld zijn.
        STARTUP_COUNT <= STARTUP_COUNT; -- Tellerwaarde blijft hangen.
      elsif ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then -- Op de voorflank van het PPS signaal
        STARTUP_COUNT <= STARTUP_COUNT + "0001"; -- Verhoog de teller
      end if;
    end if;
  end process;

  STARTUP_BLOCK <= not STARTUP_COUNT(3);

-- Trigger condities die na 1 periode bepaald zijn

-- TR_CONDITION1
-- 0H and 1L, at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION1 <= (ML1 or ML2 or SL1 or SL2);
    end if;
  end process;

-- TR_CONDITION2
-- 0H and 2L, at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION2 <= (ML1 and ML2) or (ML1 and SL1) or (ML1 and SL2) or
                       (ML2 and SL1) or (ML2 and SL2) or
                       (SL1 and SL2);
    end if;
  end process;

-- TR_CONDITION3
-- 0H and 3L, at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION3 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION3 <= (ML1 and ML2 and SL1) or (ML1 and ML2 and SL2) or (ML1 and SL1 and SL2) or
                       (ML2 and SL1 and SL2);
    end if;
  end process;

-- TR_CONDITION4
-- 0H and 4L, all four low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION4 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION4 <= (ML1 and ML2 and SL1 and SL2);
    end if;
  end process;

-- TR_CONDITION5
-- 1H and 0L,  at least one high signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION5 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION5 <= (MH1 or MH2 or SH1 or SH2);
    end if;
  end process;

-- TR_CONDITION9
-- 2H and 0L, at least two high signals.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION9 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION9 <= (MH1 and MH2) or (MH1 and SH1) or (MH1 and SH2) or
                 (MH2 and SH1) or (MH2 and SH2) or
                 (SH1 and SH2);
    end if;
  end process;

-- TR_CONDITION12
-- 3H and 0L,  at least three high signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION12 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION12 <= (MH1 and MH2 and SH1) or (MH1 and MH2 and SH2) or (MH1 and SH1 and SH2) or
                        (MH2 and SH1 and SH2);
    end if;
  end process;

-- TR_CONDITION14
-- 4H and 0L, all four high signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION14 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION14 <= (MH1 and MH2 and SH1 and SH2);
    end if;
  end process;

-- Trigger condities die na 2 periodes bepaald zijn

-- TR_CONDITION6
-- 1H and 1L,  at least one high signal and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION6 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION6 <= TR_CONDITION5 and TR_CONDITION2;
    end if;
  end process;

-- TR_CONDITION7
-- 1H and 2L,  at least one high signal and at least two other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION7 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION7 <= TR_CONDITION5 and TR_CONDITION3;
    end if;
  end process;

-- TR_CONDITION8
-- 1H and 3L,  at least one high signal and at least three other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION8 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION8 <= TR_CONDITION5 and TR_CONDITION4;
    end if;
  end process;

-- TR_CONDITION10
-- 2H and 1L,  at least two high signals and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION10 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION10 <= TR_CONDITION9 and TR_CONDITION3;
    end if;
  end process;

-- TR_CONDITION11
-- 2H and 2L,  at least two high signals and at least two other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION11 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION11 <= TR_CONDITION9 and TR_CONDITION4;
    end if;
  end process;

-- TR_CONDITION13
-- 3H and 1L,  at least three high signals and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION13 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION13 <= TR_CONDITION12 and TR_CONDITION4;
    end if;
  end process;

-- TR_CONDITION15
-- 1H or 1L,  at least one high signal or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION15 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION15 <= TR_CONDITION5 or TR_CONDITION1;
    end if;
  end process;

-- TR_CONDITION16
-- 1H or 2L,  at least one high signal or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION16 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION16 <= TR_CONDITION5 or TR_CONDITION2;
    end if;
  end process;

-- TR_CONDITION17
-- 1H or 3L,  at least one high signal or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION17 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION17 <= TR_CONDITION5 or TR_CONDITION3;
    end if;
  end process;

-- TR_CONDITION18
-- 1H or 4L,  at least one high signal or all four signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION18 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION18 <= TR_CONDITION5 or TR_CONDITION4;
    end if;
  end process;

-- TR_CONDITION19
-- 2H or 1L,  at least two high signals or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION19 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION19 <= TR_CONDITION9 or TR_CONDITION1;
    end if;
  end process;

-- TR_CONDITION20
-- 2H or 2L,  at least two high signals or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION20 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION20 <= TR_CONDITION9 or TR_CONDITION2;
    end if;
  end process;

-- TR_CONDITION21
-- 2H or 3L,  at least two high signals or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION21 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION21 <= TR_CONDITION9 or TR_CONDITION3;
    end if;
  end process;

-- TR_CONDITION22
-- 2H or 4L,  at least two high signals or all four signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION22 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION22 <= TR_CONDITION9 or TR_CONDITION4;
    end if;
  end process;

-- TR_CONDITION23
-- 3H or 1L,  at least three high signals or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION23 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION23 <= TR_CONDITION12 or TR_CONDITION1;
    end if;
  end process;

-- TR_CONDITION24
-- 3H or 2L,  at least three high signals or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION24 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION24 <= TR_CONDITION12 or TR_CONDITION2;
    end if;
  end process;

-- TR_CONDITION25
-- 3H or 3L,  at least three high signals or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION25 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION25 <= TR_CONDITION12 or TR_CONDITION3;
    end if;
  end process;

-- TR_CONDITION26
-- 3H or 4L,  at least three high signals or all four signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION26 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION26 <= TR_CONDITION12 or TR_CONDITION4;
    end if;
  end process;

-- TR_CONDITION27
-- 4H or 1L,  all four high signals or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION27 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION27 <= TR_CONDITION14 or TR_CONDITION1;
    end if;
  end process;

-- TR_CONDITION28
-- 4H or 2L,  all four high signals or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION28 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION28 <= TR_CONDITION14 or TR_CONDITION2;
    end if;
  end process;

-- TR_CONDITION29
-- 4H or 3L,  all four high signals or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION29 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION29 <= TR_CONDITION14 or TR_CONDITION3;
    end if;
  end process;

-- TR_CONDITION30
-- 4H or 4L,  all four high signals or all four low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION30 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION30 <= TR_CONDITION14 or TR_CONDITION4;
    end if;
  end process;

-- Als aan het triggerpatroon voldaan wordt, moeten de signalen uit de scintillator gelatched worden

  process (CLK200MHz,SYSRST,SCINT_PATTERN)
  begin
    if SYSRST = '1' then
      SCINT_LATCH <= '0';
    elsif (CLK200MHz'event and CLK200MHz='1') then
      case SCINT_PATTERN is
        when "000001" => SCINT_LATCH <= TR_CONDITION1_DEL;
        when "000010" => SCINT_LATCH <= TR_CONDITION2_DEL;
        when "000011" => SCINT_LATCH <= TR_CONDITION3_DEL;
        when "000100" => SCINT_LATCH <= TR_CONDITION4_DEL;
        when "001000" => SCINT_LATCH <= TR_CONDITION5_DEL;
        when "001001" => SCINT_LATCH <= TR_CONDITION6;
        when "001010" => SCINT_LATCH <= TR_CONDITION7;
        when "001011" => SCINT_LATCH <= TR_CONDITION8;
        when "010000" => SCINT_LATCH <= TR_CONDITION9_DEL;
        when "010001" => SCINT_LATCH <= TR_CONDITION10;
        when "010010" => SCINT_LATCH <= TR_CONDITION11;
        when "011000" => SCINT_LATCH <= TR_CONDITION12_DEL;
        when "011001" => SCINT_LATCH <= TR_CONDITION13;
        when "100000" => SCINT_LATCH <= TR_CONDITION14_DEL;
        when "001100" => SCINT_LATCH <= TR_CONDITION15;
        when "001101" => SCINT_LATCH <= TR_CONDITION16;
        when "001110" => SCINT_LATCH <= TR_CONDITION17;
        when "001111" => SCINT_LATCH <= TR_CONDITION18;
        when "010100" => SCINT_LATCH <= TR_CONDITION19;
        when "010101" => SCINT_LATCH <= TR_CONDITION20;
        when "010110" => SCINT_LATCH <= TR_CONDITION21;
        when "010111" => SCINT_LATCH <= TR_CONDITION22;
        when "011100" => SCINT_LATCH <= TR_CONDITION23;
        when "011101" => SCINT_LATCH <= TR_CONDITION24;
        when "011110" => SCINT_LATCH <= TR_CONDITION25;
        when "011111" => SCINT_LATCH <= TR_CONDITION26;
        when "100100" => SCINT_LATCH <= TR_CONDITION27;
        when "100101" => SCINT_LATCH <= TR_CONDITION28;
        when "100110" => SCINT_LATCH <= TR_CONDITION29;
        when "100111" => SCINT_LATCH <= TR_CONDITION30;
        when others => SCINT_LATCH <= '0';
      end case;
    end if;
  end process;

-- Het vasthouden of blokkeren van de ingangssignalen wordt aangezet door de opgaande flank van SCINT_LATCH
-- en wordt geblockt door BLOCK_START_OF_COINC
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_LATCHED <= '0';
      ML2_LATCHED <= '0';
      MH1_LATCHED <= '0';
      MH2_LATCHED <= '0';
      SL1_LATCHED <= '0';
      SL2_LATCHED <= '0';
      SH1_LATCHED <= '0';
      SH2_LATCHED <= '0';
      TRIGGER_PATTERN_TMP <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if BLOCK_START_OF_COINC = '0' and SCINT_LATCH = '1' and SCINT_LATCH_DEL = '0' then
        ML1_LATCHED <= ML1_DEL3;
        ML2_LATCHED <= ML2_DEL3;
        MH1_LATCHED <= MH1_DEL3;
        MH2_LATCHED <= MH2_DEL3;
        SL1_LATCHED <= SL1_DEL3;
        SL2_LATCHED <= SL2_DEL3;
        SH1_LATCHED <= SH1_DEL3;
        SH2_LATCHED <= SH2_DEL3;
        TRIGGER_PATTERN_TMP(0) <= ML1_DEL3;
        TRIGGER_PATTERN_TMP(1) <= MH1_DEL3;
        TRIGGER_PATTERN_TMP(2) <= ML2_DEL3;
        TRIGGER_PATTERN_TMP(3) <= MH2_DEL3;
        TRIGGER_PATTERN_TMP(4) <= SL1_DEL3;
        TRIGGER_PATTERN_TMP(5) <= SH1_DEL3;
        TRIGGER_PATTERN_TMP(6) <= SL2_DEL3;
        TRIGGER_PATTERN_TMP(7) <= SH2_DEL3;
        TRIGGER_PATTERN_TMP(8) <= EXT_TR;
        TRIGGER_PATTERN_TMP(9) <= MASTER;
        TRIGGER_PATTERN_TMP(10) <= SLAVE_PRESENT;
        TRIGGER_PATTERN_TMP(15) <= '0';
      end if;
    end if;
  end process;

-- Hier worden de nieuwe ingangssignalen gemaakt. Degene die de coincidentie starten.
-- Mocht later de triggervoorwaarde verlengt worden door nog een geldige combinatie
-- dan wordt dit tegengehouden.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_NEW <= '0';
      ML2_NEW <= '0';
      MH1_NEW <= '0';
      MH2_NEW <= '0';
      SL1_NEW <= '0';
      SL2_NEW <= '0';
      SH1_NEW <= '0';
      SH2_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      ML1_NEW <= ML1_LATCHED and ML1_DEL4;
      ML2_NEW <= ML2_LATCHED and ML2_DEL4;
      MH1_NEW <= MH1_LATCHED and MH1_DEL4;
      MH2_NEW <= MH2_LATCHED and MH2_DEL4;
      SL1_NEW <= SL1_LATCHED and SL1_DEL4;
      SL2_NEW <= SL2_LATCHED and SL2_DEL4;
      SH1_NEW <= SH1_LATCHED and SH1_DEL4;
      SH2_NEW <= SH2_LATCHED and SH2_DEL4;
    end if;
  end process;

-- Van de nieuwe signalen moet weer opnieuw de triggerconditie bepaald worden.
-- Deze signalen kunnen alleen in het begin van een triggervoorwaarde opkomen en worden dus niet verlengd
-- door een andere geldige combinatie

-- Trigger condities die na 1 periode bepaald zijn

-- TR_CONDITION1_NEW
-- 0H and 1L, at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION1_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION1_NEW <= (ML1_NEW or ML2_NEW or SL1_NEW or SL2_NEW);
    end if;
  end process;

-- TR_CONDITION2_NEW
-- 0H and 2L, at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION2_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION2_NEW <= (ML1_NEW and ML2_NEW) or (ML1_NEW and SL1_NEW) or (ML1_NEW and SL2_NEW) or
                       (ML2_NEW and SL1_NEW) or (ML2_NEW and SL2_NEW) or
                       (SL1_NEW and SL2_NEW);
    end if;
  end process;

-- TR_CONDITION3_NEW
-- 0H and 3L, at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION3_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION3_NEW <= (ML1_NEW and ML2_NEW and SL1_NEW) or (ML1_NEW and ML2_NEW and SL2_NEW) or (ML1_NEW and SL1_NEW and SL2_NEW) or
                       (ML2_NEW and SL1_NEW and SL2_NEW);
    end if;
  end process;

-- TR_CONDITION4_NEW
-- 0H and 4L, all four low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION4_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION4_NEW <= (ML1_NEW and ML2_NEW and SL1_NEW and SL2_NEW);
    end if;
  end process;

-- TR_CONDITION5_NEW
-- 1H and 0L,  at least one high signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION5_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION5_NEW <= (MH1_NEW or MH2_NEW or SH1_NEW or SH2_NEW);
    end if;
  end process;

-- TR_CONDITION9_NEW
-- 2H and 0L, at least two high signals.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION9_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION9_NEW <= (MH1_NEW and MH2_NEW) or (MH1_NEW and SH1_NEW) or (MH1_NEW and SH2_NEW) or
                 (MH2_NEW and SH1_NEW) or (MH2_NEW and SH2_NEW) or
                 (SH1_NEW and SH2_NEW);
    end if;
  end process;

-- TR_CONDITION12_NEW
-- 3H and 0L,  at least three high signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION12_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION12_NEW <= (MH1_NEW and MH2_NEW and SH1_NEW) or (MH1_NEW and MH2_NEW and SH2_NEW) or (MH1_NEW and SH1_NEW and SH2_NEW) or
                        (MH2_NEW and SH1_NEW and SH2_NEW);
    end if;
  end process;

-- TR_CONDITION14_NEW
-- 4H and 0L, all four high signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION14_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION14_NEW <= (MH1_NEW and MH2_NEW and SH1_NEW and SH2_NEW);
    end if;
  end process;

-- Trigger condities die na 2 periodes bepaald zijn

-- TR_CONDITION6_NEW
-- 1H and 1L,  at least one high signal and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION6_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION6_NEW <= TR_CONDITION5_NEW and TR_CONDITION2_NEW;
    end if;
  end process;

-- TR_CONDITION7_NEW
-- 1H and 2L,  at least one high signal and at least two other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION7_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION7_NEW <= TR_CONDITION5_NEW and TR_CONDITION3_NEW;
    end if;
  end process;

-- TR_CONDITION8_NEW
-- 1H and 3L,  at least one high signal and at least three other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION8_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION8_NEW <= TR_CONDITION5_NEW and TR_CONDITION4_NEW;
    end if;
  end process;

-- TR_CONDITION10_NEW
-- 2H and 1L,  at least two high signals and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION10_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION10_NEW <= TR_CONDITION9_NEW and TR_CONDITION3_NEW;
    end if;
  end process;

-- TR_CONDITION11_NEW
-- 2H and 2L,  at least two high signals and at least two other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION11_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION11_NEW <= TR_CONDITION9_NEW and TR_CONDITION4_NEW;
    end if;
  end process;

-- TR_CONDITION13_NEW
-- 3H and 1L,  at least three high signals and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION13_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION13_NEW <= TR_CONDITION12_NEW and TR_CONDITION4_NEW;
    end if;
  end process;

-- TR_CONDITION15_NEW
-- 1H or 1L,  at least one high signal or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION15_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION15_NEW <= TR_CONDITION5_NEW or TR_CONDITION1_NEW;
    end if;
  end process;

-- TR_CONDITION16_NEW
-- 1H or 2L,  at least one high signal or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION16_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION16_NEW <= TR_CONDITION5_NEW or TR_CONDITION2_NEW;
    end if;
  end process;

-- TR_CONDITION17_NEW
-- 1H or 3L,  at least one high signal or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION17_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION17_NEW <= TR_CONDITION5_NEW or TR_CONDITION3_NEW;
    end if;
  end process;

-- TR_CONDITION18_NEW
-- 1H or 4L,  at least one high signal or all four signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION18_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION18_NEW <= TR_CONDITION5_NEW or TR_CONDITION4_NEW;
    end if;
  end process;

-- TR_CONDITION19_NEW
-- 2H or 1L,  at least two high signals or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION19_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION19_NEW <= TR_CONDITION9_NEW or TR_CONDITION1_NEW;
    end if;
  end process;

-- TR_CONDITION20_NEW
-- 2H or 2L,  at least two high signals or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION20_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION20_NEW <= TR_CONDITION9_NEW or TR_CONDITION2_NEW;
    end if;
  end process;

-- TR_CONDITION21_NEW
-- 2H or 3L,  at least two high signals or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION21_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION21_NEW <= TR_CONDITION9_NEW or TR_CONDITION3_NEW;
    end if;
  end process;

-- TR_CONDITION22_NEW
-- 2H or 4L,  at least two high signals or all four signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION22_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION22_NEW <= TR_CONDITION9_NEW or TR_CONDITION4_NEW;
    end if;
  end process;

-- TR_CONDITION23_NEW
-- 3H or 1L,  at least three high signals or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION23_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION23_NEW <= TR_CONDITION12_NEW or TR_CONDITION1_NEW;
    end if;
  end process;

-- TR_CONDITION24_NEW
-- 3H or 2L,  at least three high signals or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION24_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION24_NEW <= TR_CONDITION12_NEW or TR_CONDITION2_NEW;
    end if;
  end process;

-- TR_CONDITION25_NEW
-- 3H or 3L,  at least three high signals or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION25_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION25_NEW <= TR_CONDITION12_NEW or TR_CONDITION3_NEW;
    end if;
  end process;

-- TR_CONDITION26_NEW
-- 3H or 4L,  at least three high signals or all four signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION26_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION26_NEW <= TR_CONDITION12_NEW or TR_CONDITION4_NEW;
    end if;
  end process;

-- TR_CONDITION27_NEW
-- 4H or 1L,  all four high signals or at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION27_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION27_NEW <= TR_CONDITION14_NEW or TR_CONDITION1_NEW;
    end if;
  end process;

-- TR_CONDITION28_NEW
-- 4H or 2L,  all four high signals or at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION28_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION28_NEW <= TR_CONDITION14_NEW or TR_CONDITION2_NEW;
    end if;
  end process;

-- TR_CONDITION29_NEW
-- 4H or 3L,  all four high signals or at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION29_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION29_NEW <= TR_CONDITION14_NEW or TR_CONDITION3_NEW;
    end if;
  end process;

-- TR_CONDITION30_NEW
-- 4H or 4L,  all four high signals or all four low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION30_NEW <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION30_NEW <= TR_CONDITION14_NEW or TR_CONDITION4_NEW;
    end if;
  end process;

-- Van de NEW gemaakte signalen moet weer bekeken worden of ze een coincidentie maken, indien ze geselecteerd zijn.
  process (CLK200MHz,SYSRST,SCINT_PATTERN)
  begin
    if SYSRST = '1' then
      SCINT_COINC <= '0';
    elsif (CLK200MHz'event and CLK200MHz='1') then
      case SCINT_PATTERN is
        when "000001" => SCINT_COINC <= TR_CONDITION1_NEW_DEL;
        when "000010" => SCINT_COINC <= TR_CONDITION2_NEW_DEL;
        when "000011" => SCINT_COINC <= TR_CONDITION3_NEW_DEL;
        when "000100" => SCINT_COINC <= TR_CONDITION4_NEW_DEL;
        when "001000" => SCINT_COINC <= TR_CONDITION5_NEW_DEL;
        when "001001" => SCINT_COINC <= TR_CONDITION6_NEW;
        when "001010" => SCINT_COINC <= TR_CONDITION7_NEW;
        when "001011" => SCINT_COINC <= TR_CONDITION8_NEW;
        when "010000" => SCINT_COINC <= TR_CONDITION9_NEW_DEL;
        when "010001" => SCINT_COINC <= TR_CONDITION10_NEW;
        when "010010" => SCINT_COINC <= TR_CONDITION11_NEW;
        when "011000" => SCINT_COINC <= TR_CONDITION12_NEW_DEL;
        when "011001" => SCINT_COINC <= TR_CONDITION13_NEW;
        when "100000" => SCINT_COINC <= TR_CONDITION14_NEW_DEL;
        when "001100" => SCINT_COINC <= TR_CONDITION15_NEW;
        when "001101" => SCINT_COINC <= TR_CONDITION16_NEW;
        when "001110" => SCINT_COINC <= TR_CONDITION17_NEW;
        when "001111" => SCINT_COINC <= TR_CONDITION18_NEW;
        when "010100" => SCINT_COINC <= TR_CONDITION19_NEW;
        when "010101" => SCINT_COINC <= TR_CONDITION20_NEW;
        when "010110" => SCINT_COINC <= TR_CONDITION21_NEW;
        when "010111" => SCINT_COINC <= TR_CONDITION22_NEW;
        when "011100" => SCINT_COINC <= TR_CONDITION23_NEW;
        when "011101" => SCINT_COINC <= TR_CONDITION24_NEW;
        when "011110" => SCINT_COINC <= TR_CONDITION25_NEW;
        when "011111" => SCINT_COINC <= TR_CONDITION26_NEW;
        when "100100" => SCINT_COINC <= TR_CONDITION27_NEW;
        when "100101" => SCINT_COINC <= TR_CONDITION28_NEW;
        when "100110" => SCINT_COINC <= TR_CONDITION29_NEW;
        when "100111" => SCINT_COINC <= TR_CONDITION30_NEW;
        when others => SCINT_COINC <= '0';
      end case;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TMP <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if TR_CONDITION(7) = '1' then -- Calibration selected
        if CAL_TR_DEL1 = '0' and CAL_TR_DEL2 = '1' then  -- negative edge of calibration trigger
          COINC_TMP <= '0'; -- reset COINC_TMP
        elsif BLOCK_START_OF_COINC = '0' -- No running coinc and no block
          and CAL_TR_DEL1 = '1' and CAL_TR_DEL2 = '0' then  -- and positive edge of calibration trigger
          COINC_TMP <= '1';
        end if;
      elsif TR_CONDITION(6) = '1' then -- External trigger and triggers from scintillators selected; TR_CONDITION15 if SCINT_COINC = '0'; TR_CONDITION16  if SCINT_COINC = TR_CONDITION1 to 14
        if (EXT_TR = '0' and EXT_TR_DEL = '1') or (SCINT_COINC = '0' and SCINT_COINC_DEL = '1') then  -- negative edge of external trigger or negative edge of scintillator trigger
          COINC_TMP <= '0';
        elsif BLOCK_START_OF_COINC = '0' -- No running coinc and no block
          and ((EXT_TR = '1' and EXT_TR_DEL = '0') or (SCINT_COINC = '1' and SCINT_COINC_DEL = '0')) then  -- positive edge of external trigger or positive edge of scintillator trigger
          COINC_TMP <= '1';
        end if;
      elsif SCINT_COINC = '0' and SCINT_COINC_DEL = '1' then  -- negative edge of scintillator trigger
        COINC_TMP <= '0';
      elsif BLOCK_START_OF_COINC = '0' -- No running coinc and no block
        and SCINT_COINC = '1' and SCINT_COINC_DEL = '0' then  -- positive edge of scintillator trigger
        COINC_TMP <= '1';
      end if;
    end if;
  end process;

  -- Latch TRIGGER_PATTERN op de achterkant van posttime
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME_TMP = '0' and COINC_TO_END_TIME_DEL_TMP = '1' then
        TRIGGER_PATTERN(0) <= TRIGGER_PATTERN_TMP(0);
        TRIGGER_PATTERN(1) <= TRIGGER_PATTERN_TMP(1);
        TRIGGER_PATTERN(2) <= TRIGGER_PATTERN_TMP(2);
        TRIGGER_PATTERN(3) <= TRIGGER_PATTERN_TMP(3);
        TRIGGER_PATTERN(4) <= TRIGGER_PATTERN_TMP(4);
        TRIGGER_PATTERN(5) <= TRIGGER_PATTERN_TMP(5);
        TRIGGER_PATTERN(6) <= TRIGGER_PATTERN_TMP(6);
        TRIGGER_PATTERN(7) <= TRIGGER_PATTERN_TMP(7);
        TRIGGER_PATTERN(8) <= TRIGGER_PATTERN_TMP(8);
        TRIGGER_PATTERN(9) <= TRIGGER_PATTERN_TMP(9);
        TRIGGER_PATTERN(10) <= TRIGGER_PATTERN_TMP(10);
        TRIGGER_PATTERN(11) <= COMPL1;
        TRIGGER_PATTERN(12) <= COMPH1;
        TRIGGER_PATTERN(13) <= COMPL2;
        TRIGGER_PATTERN(14) <= COMPH2;
        TRIGGER_PATTERN(15) <= TRIGGER_PATTERN_TMP(15);
      end if;
    end if;
  end process;

  -- COINC_TO_END_TIME_TMP starts at a negative edge of COINC and stops when COINC_TO_END_TIME_CNT reaches POST_TIME
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_TMP <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TMP = '0' and COINC_DEL = '1' then -- on a negative edge of COINC
        COINC_TO_END_TIME_TMP <= '1';
      elsif COINC_TO_END_TIME_CNT > POST_TIME then
        COINC_TO_END_TIME_TMP <= '0';
      end if;
    end if;
  end process;

  -- COINC_TO_END_TIME_CNT starts when COINC_TO_END_TIME_TMP = '1'
  -- and counts as long COINC_TO_END_TIME_TMP is valid
  -- and resets when COINC_TO_END_TIME_TMP = '0'
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME_TMP = '1' then
        COINC_TO_END_TIME_CNT <= COINC_TO_END_TIME_CNT + 1;
      else
        COINC_TO_END_TIME_CNT <= 0;
      end if;
    end if;
  end process;

  -- BEGIN_COINC_TO_END_TIME_TMP goes from begin of coinc till end of posttime
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      BEGIN_COINC_TO_END_TIME_TMP <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      BEGIN_COINC_TO_END_TIME_TMP <= COINC_TMP or COINC_DEL or COINC_TO_END_TIME_TMP;
    end if;
  end process;

  -- BLOCK_START_OF_COINC goes from begin of coinc till end of COINC_TO_END_TIME_TMP
  process(CLK200MHz,SYSRST)
  begin
    if (CLK200MHz'event and CLK200MHz = '1') then
      BLOCK_START_OF_COINC <= BLOCK_COINC or COINC_TMP or COINC_DEL or COINC_TO_END_TIME_TMP or STARTUP_BLOCK or BLOCK_COINC_SLAVE;
    end if;
  end process;

end architecture a0 ; -- of TRIGGER_MATRIX

--------------------------------------------------------------------------------
-- Object        : Entity design.DISCRIMINATORS
-- Last modified : Wed Jun 02 14:57:00 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity DISCRIMINATORS is
  port(
    BLOCK_COINC   : in     std_logic;
    CLK200MHz     : in     std_logic;
    COINC_TIME    : in     integer range 1000 downto 0;
    COMPH1        : out    std_logic;
    COMPH1_IN     : in     std_logic;
    COMPH2        : out    std_logic;
    COMPH2_IN     : in     std_logic;
    COMPL1        : out    std_logic;
    COMPL1_IN     : in     std_logic;
    COMPL2        : out    std_logic;
    COMPL2_IN     : in     std_logic;
    DATA_ADC1_NEG : in     std_logic_vector(11 downto 0);
    DATA_ADC1_POS : in     std_logic_vector(11 downto 0);
    DATA_ADC2_NEG : in     std_logic_vector(11 downto 0);
    DATA_ADC2_POS : in     std_logic_vector(11 downto 0);
    EXT_TR_IN     : in     std_logic;
    EXT_TR_OUT    : out    std_logic;
    MASTER        : in     std_logic;
    MH1_OUT       : out    std_logic;
    MH2_OUT       : out    std_logic;
    ML1_OUT       : out    std_logic;
    ML2_OUT       : out    std_logic;
    POST_TIME     : in     integer range 1600 downto 0;
    SYSRST        : in     std_logic;
    THH1          : in     std_logic_vector(11 downto 0);
    THH2          : in     std_logic_vector(11 downto 0);
    THL1          : in     std_logic_vector(11 downto 0);
    THL2          : in     std_logic_vector(11 downto 0));
end entity DISCRIMINATORS;

--------------------------------------------------------------------------------
-- Object        : Architecture design.DISCRIMINATORS.a0
-- Last modified : Wed Jun 02 14:57:00 2010.
--------------------------------------------------------------------------------


architecture a0 of DISCRIMINATORS is

signal ML1_PRE: std_logic ; -- Time Over Threshold channel1 low
signal ML2_PRE: std_logic ; -- Time Over Threshold channel2 low
signal MH1_PRE: std_logic ; -- Time Over Threshold channel1 high
signal MH2_PRE: std_logic ; -- Time Over Threshold channel2 high
signal ML1_PRE_DEL: std_logic ; -- Time Over Threshold channel1 low after one 200MHz period
signal ML2_PRE_DEL: std_logic ; -- Time Over Threshold channel2 low after one 200MHz period
signal MH1_PRE_DEL: std_logic ; -- Time Over Threshold channel1 high after one 200MHz period
signal MH2_PRE_DEL: std_logic ; -- Time Over Threshold channel2 high after one 200MHz period
signal ML1: std_logic ; -- Coincidence window ML1_PRE
signal ML1_CNT: integer range 1000 downto 0 ; -- Coincidence window counter ML1_PRE
signal ML2: std_logic ; -- Coincidence window ML2_PRE
signal ML2_CNT: integer range 1000 downto 0 ; -- Coincidence window counter ML2_PRE
signal MH1: std_logic ; -- Coincidence window MH1_PRE
signal MH1_CNT: integer range 1000 downto 0 ; -- Coincidence window counter MH1_PRE
signal MH2: std_logic ; -- Coincidence window MH2_PRE
signal MH2_CNT: integer range 1000 downto 0 ; -- Coincidence window counter MH2_PRE
signal EXT_TR_IN_DEL1: std_logic ; -- External trigger after one 200MHz period
signal EXT_TR_IN_DEL2: std_logic ; -- External trigger after two 200MHz periods; Two, because the external trigger is asynchronious
signal EXT_TR: std_logic ; -- Coincidence window EXT_TR
signal EXT_TR_CNT: integer range 1000 downto 0 ; -- Coincidence window counter EXT_TR

-- De comparator windows worden tot en met posttime plus nog 200ns verlengd
-- Om er zeker van te zijn dat ze op het eind van posttime in het volgenede blok ingeklokt worden.
-- Dit is om het verschil in looptijd op te vangen tussen een signaal uit de ADC's, ongeveer 20 klokperiodes latency
-- en de vertraging van een hardware comparator.
signal COMPL1_IN_DEL1: std_logic ;
signal COMPL1_IN_DEL2: std_logic ;
signal COMPL1_IN_WIN: std_logic ;
signal COMPL1_IN_CNT: integer range 2640 downto 0 ;
signal COMPH1_IN_DEL1: std_logic ;
signal COMPH1_IN_DEL2: std_logic ;
signal COMPH1_IN_WIN: std_logic ;
signal COMPH1_IN_CNT: integer range 2640 downto 0 ;
signal COMPL2_IN_DEL1: std_logic ;
signal COMPL2_IN_DEL2: std_logic ;
signal COMPL2_IN_WIN: std_logic ;
signal COMPL2_IN_CNT: integer range 2640 downto 0 ;
signal COMPH2_IN_DEL1: std_logic ;
signal COMPH2_IN_DEL2: std_logic ;
signal COMPH2_IN_WIN: std_logic ;
signal COMPH2_IN_CNT: integer range 2640 downto 0 ;

signal COMP_WIN_LENGTH: integer range 2640 downto 0 ;

signal ML1_DEL1: std_logic ; -- Compensates the delay from slave to master
signal ML1_DEL2: std_logic ;
signal ML1_DEL3: std_logic ;
signal ML1_DEL4: std_logic ;
signal MH1_DEL1: std_logic ;
signal MH1_DEL2: std_logic ;
signal MH1_DEL3: std_logic ;
signal MH1_DEL4: std_logic ;
signal ML2_DEL1: std_logic ;
signal ML2_DEL2: std_logic ;
signal ML2_DEL3: std_logic ;
signal ML2_DEL4: std_logic ;
signal MH2_DEL1: std_logic ;
signal MH2_DEL2: std_logic ;
signal MH2_DEL3: std_logic ;
signal MH2_DEL4: std_logic ;

begin

  --ML1_PRE <= '1' when (DATA_ADC1_POS > THL1 or DATA_ADC1_NEG > THL1) else '0'; -- Discriminator for ML1
  --ML2_PRE <= '1' when (DATA_ADC2_POS > THL2 or DATA_ADC2_NEG > THL2) else '0'; -- Discriminator for ML2
  --MH1_PRE <= '1' when (DATA_ADC1_POS > THH1 or DATA_ADC1_NEG > THH1) else '0'; -- Discriminator for MH1
  --MH2_PRE <= '1' when (DATA_ADC2_POS > THH2 or DATA_ADC2_NEG > THH2) else '0'; -- Discriminator for MH2

  -- Als een slave zijn block_coinc naar een master door wil geven, dan doet hij dat door de threshold signalen
  -- op een normaal niet bestaande / mogelijke waarde te zetten, namelijk: wel hoge threshold waarden, zonder lage waarden.

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_OUT <= '0';
      ML2_OUT <= '0';
      MH1_OUT <= '0';
      MH2_OUT <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MASTER = '0' then
        if BLOCK_COINC = '1' then
          ML1_OUT <= '0';
          ML2_OUT <= '0';
          MH1_OUT <= '1';
          MH2_OUT <= '1';
        else
          ML1_OUT <= ML1;
          ML2_OUT <= ML2;
          MH1_OUT <= MH1;
          MH2_OUT <= MH2;
        end if;
      else
        ML1_OUT <= ML1_DEL4;
        ML2_OUT <= ML2_DEL4;
        MH1_OUT <= MH1_DEL4;
        MH2_OUT <= MH2_DEL4;
      end if;
    end if;
  end process;

  --ML1_OUT <= ML1 when MASTER = '0' else ML1_DEL4;
  --MH1_OUT <= MH1 when MASTER = '0' else MH1_DEL4;
  --ML2_OUT <= ML2 when MASTER = '0' else ML2_DEL4;
  --MH2_OUT <= MH2 when MASTER = '0' else MH2_DEL4;

  EXT_TR_OUT <= EXT_TR;
  COMPL1 <= COMPL1_IN_WIN;
  COMPL2 <= COMPL2_IN_WIN;
  COMPH1 <= COMPH1_IN_WIN;
  COMPH2 <= COMPH2_IN_WIN;

  COMP_WIN_LENGTH <= COINC_TIME + POST_TIME + 40;

  process(CLK200MHz,SYSRST)
  begin
    if (CLK200MHz'event and CLK200MHz = '1') then
      if (DATA_ADC1_POS > THL1 or DATA_ADC1_NEG > THL1) then -- Discriminator for ML1
        ML1_PRE <= '1';
      else
        ML1_PRE <= '0';
      end if;
      if (DATA_ADC2_POS > THL2 or DATA_ADC2_NEG > THL2) then -- Discriminator for ML2
        ML2_PRE <= '1';
      else
        ML2_PRE <= '0';
      end if;
      if (DATA_ADC1_POS > THH1 or DATA_ADC1_NEG > THH1) then -- Discriminator for MH1
        MH1_PRE <= '1';
      else
        MH1_PRE <= '0';
      end if;
      if (DATA_ADC2_POS > THH2 or DATA_ADC2_NEG > THH2) then -- Discriminator for MH2
        MH2_PRE <= '1';
      else
        MH2_PRE <= '0';
      end if;
    end if;
  end process;

  -- Delays
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_PRE_DEL <= '0';
      ML2_PRE_DEL <= '0';
      MH1_PRE_DEL <= '0';
      MH2_PRE_DEL <= '0';
      EXT_TR_IN_DEL1 <= '0';
      EXT_TR_IN_DEL2 <= '0';
      COMPL1_IN_DEL1 <= '0';
      COMPL1_IN_DEL2 <= '0';
      COMPH1_IN_DEL1 <= '0';
      COMPH1_IN_DEL2 <= '0';
      COMPL2_IN_DEL1 <= '0';
      COMPL2_IN_DEL2 <= '0';
      COMPH2_IN_DEL1 <= '0';
      COMPH2_IN_DEL2 <= '0';
      ML1_DEL1 <= '0';
      ML1_DEL2 <= '0';
      ML1_DEL3 <= '0';
      ML1_DEL4 <= '0';
      MH1_DEL1 <= '0';
      MH1_DEL2 <= '0';
      MH1_DEL3 <= '0';
      MH1_DEL4 <= '0';
      ML2_DEL1 <= '0';
      ML2_DEL2 <= '0';
      ML2_DEL3 <= '0';
      ML2_DEL4 <= '0';
      MH2_DEL1 <= '0';
      MH2_DEL2 <= '0';
      MH2_DEL3 <= '0';
      MH2_DEL4 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      ML1_PRE_DEL <= ML1_PRE;
      ML2_PRE_DEL <= ML2_PRE;
      MH1_PRE_DEL <= MH1_PRE;
      MH2_PRE_DEL <= MH2_PRE;
      EXT_TR_IN_DEL1 <= EXT_TR_IN;
      EXT_TR_IN_DEL2 <= EXT_TR_IN_DEL1;
      COMPL1_IN_DEL1 <= COMPL1_IN;
      COMPL1_IN_DEL2 <= COMPL1_IN_DEL1;
      COMPH1_IN_DEL1 <= COMPH1_IN;
      COMPH1_IN_DEL2 <= COMPH1_IN_DEL1;
      COMPL2_IN_DEL1 <= COMPL2_IN;
      COMPL2_IN_DEL2 <= COMPL2_IN_DEL1;
      COMPH2_IN_DEL1 <= COMPH2_IN;
      COMPH2_IN_DEL2 <= COMPH2_IN_DEL1;
      ML1_DEL1 <= ML1;
      ML1_DEL2 <= ML1_DEL1;
      ML1_DEL3 <= ML1_DEL2;
      ML1_DEL4 <= ML1_DEL3;
      MH1_DEL1 <= MH1;
      MH1_DEL2 <= MH1_DEL1;
      MH1_DEL3 <= MH1_DEL2;
      MH1_DEL4 <= MH1_DEL3;
      ML2_DEL1 <= ML2;
      ML2_DEL2 <= ML2_DEL1;
      ML2_DEL3 <= ML2_DEL2;
      ML2_DEL4 <= ML2_DEL3;
      MH2_DEL1 <= MH2;
      MH2_DEL2 <= MH2_DEL1;
      MH2_DEL3 <= MH2_DEL2;
      MH2_DEL4 <= MH2_DEL3;
    end if;
  end process;

  -- Coincidence window for ML1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML1_PRE = '1' and ML1_PRE_DEL = '0' then  -- On an upgoing egde of ML1_PRE
        ML1 <= '1';
      elsif ML1_CNT = COINC_TIME - 1 then
        ML1 <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML1 = '0' then -- ML1 = '0' makes end of coinc window
        ML1_CNT <= 0;
      else
        ML1_CNT <= ML1_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for ML2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML2_PRE = '1' and ML2_PRE_DEL = '0' then -- On an upgoing egde of ML2_PRE
        ML2 <= '1';
      elsif ML2_CNT = COINC_TIME - 1 then
        ML2 <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML2_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML2 = '0' then -- ML2 = '0' makes end of coinc window
        ML2_CNT <= 0;
      else
        ML2_CNT <= ML2_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for MH1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH1_PRE = '1' and MH1_PRE_DEL = '0' then  -- On an upgoing egde of MH1_PRE
        MH1 <= '1';
      elsif MH1_CNT = COINC_TIME - 1 then
        MH1 <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH1_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH1 = '0' then -- MH1 = '0' makes end of coinc window
        MH1_CNT <= 0;
      else
        MH1_CNT <= MH1_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for MH2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH2_PRE = '1' and MH2_PRE_DEL = '0' then -- On an upgoing egde of MH2_PRE
        MH2 <= '1';
      elsif MH2_CNT = COINC_TIME - 1 then
        MH2 <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH2_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH2 = '0' then -- MH2 = '0' makes end of coinc window
        MH2_CNT <= 0;
      else
        MH2_CNT <= MH2_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for EXT_TR
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      EXT_TR <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if EXT_TR_IN_DEL1 = '1' and EXT_TR_IN_DEL2 = '0' then -- On an upgoing egde of EXT_TR_IN 
        EXT_TR <= '1';
      elsif EXT_TR_CNT = COINC_TIME - 1 then
        EXT_TR <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      EXT_TR_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if EXT_TR = '0' then -- EXT_TR = '0' makes end of coinc window
        EXT_TR_CNT <= 0;
      else
        EXT_TR_CNT <= EXT_TR_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for COMPL1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL1_IN_DEL1 = '1' and COMPL1_IN_DEL2 = '0' then
        COMPL1_IN_WIN <= '1';
      elsif COMPL1_IN_CNT = COMP_WIN_LENGTH - 1 then
        COMPL1_IN_WIN <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL1_IN_WIN = '0' then
        COMPL1_IN_CNT <= 0;
      else
        COMPL1_IN_CNT <= COMPL1_IN_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for COMPH1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH1_IN_DEL1 = '1' and COMPH1_IN_DEL2 = '0' then
        COMPH1_IN_WIN <= '1';
      elsif COMPH1_IN_CNT = COMP_WIN_LENGTH - 1 then
        COMPH1_IN_WIN <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH1_IN_WIN = '0' then
        COMPH1_IN_CNT <= 0;
      else
        COMPH1_IN_CNT <= COMPH1_IN_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for COMPL2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL2_IN_DEL1 = '1' and COMPL2_IN_DEL2 = '0' then
        COMPL2_IN_WIN <= '1';
      elsif COMPL2_IN_CNT = COMP_WIN_LENGTH - 1 then
        COMPL2_IN_WIN <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL2_IN_WIN = '0' then
        COMPL2_IN_CNT <= 0;
      else
        COMPL2_IN_CNT <= COMPL2_IN_CNT + 1;
      end if;
    end if;
  end process;

  -- Coincidence window for COMPH2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH2_IN_DEL1 = '1' and COMPH2_IN_DEL2 = '0' then
        COMPH2_IN_WIN <= '1';
      elsif COMPH2_IN_CNT = COMP_WIN_LENGTH - 1 then
        COMPH2_IN_WIN <= '0';
      end if;
    end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH2_IN_WIN = '0' then
        COMPH2_IN_CNT <= 0;
      else
        COMPH2_IN_CNT <= COMPH2_IN_CNT + 1;
      end if;
    end if;
  end process;

end architecture a0 ; -- of DISCRIMINATORS

--------------------------------------------------------------------------------
-- Object        : Entity design.SLAVE_DETECTOR
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity SLAVE_DETECTOR is
  port(
    CLK10MHz      : in     std_logic;
    CLK200MHz     : in     std_logic;
    SH1           : in     std_logic;
    SH1_SYNCHR    : out    std_logic;
    SH2           : in     std_logic;
    SH2_SYNCHR    : out    std_logic;
    SL1           : in     std_logic;
    SL1_SYNCHR    : out    std_logic;
    SL2           : in     std_logic;
    SL2_SYNCHR    : out    std_logic;
    SLAVE_PRESENT : out    std_logic;
    SYSRST        : in     std_logic);
end entity SLAVE_DETECTOR;

--------------------------------------------------------------------------------
-- Object        : Architecture design.SLAVE_DETECTOR.a0
-- Last modified : Wed Apr 28 14:38:19 2010.
--------------------------------------------------------------------------------


architecture a0 of SLAVE_DETECTOR is

signal SH1_DEL1: std_logic; -- SH1 after one 200MHz period
signal SH2_DEL1: std_logic; -- SH2 after one 200MHz period
signal SL1_DEL1: std_logic; -- SL1 after one 200MHz period
signal SL2_DEL1: std_logic; -- SL2 after one 200MHz period
signal SH1_DEL2: std_logic; -- SH1 after two 200MHz periods
signal SH2_DEL2: std_logic; -- SH2 after two 200MHz periods
signal SL1_DEL2: std_logic; -- SL1 after two 200MHz periods
signal SL2_DEL2: std_logic; -- SL2 after two 200MHz periods
signal HIT_ON_SH1: std_logic; -- Look within a SAMPLE period if SH1 went low
signal HIT_ON_SH2: std_logic; -- Look within a SAMPLE period if SH2 went low
signal HIT_ON_SL1: std_logic; -- Look within a SAMPLE period if SL1 went low
signal HIT_ON_SL2: std_logic; -- Look within a SAMPLE period if SL2 went low
signal HIT_ON_SH1_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.
signal HIT_ON_SH2_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.
signal HIT_ON_SL1_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.
signal HIT_ON_SL2_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.

begin

  SLAVE_PRESENT <= '1' when (SL1 = '0' or SL2 = '0' or SH1 = '0' or SH2 = '0' or HIT_ON_SL1 = '1' or HIT_ON_SL2 = '1' or HIT_ON_SH1 = '1' or HIT_ON_SH2 = '1') else '0';
  SL1_SYNCHR <= SL1_DEL1;
  SH1_SYNCHR <= SH1_DEL1;
  SL2_SYNCHR <= SL2_DEL1;
  SH2_SYNCHR <= SH2_DEL1;

  -- Delays
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      SH1_DEL1 <= '1';
      SH2_DEL1 <= '1';
      SL1_DEL1 <= '1';
      SL2_DEL1 <= '1';
      SH1_DEL2 <= '1';
      SH2_DEL2 <= '1';
      SL1_DEL2 <= '1';
      SL2_DEL2 <= '1';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      SH1_DEL1 <= SH1;
      SH2_DEL1 <= SH2;
      SL1_DEL1 <= SL1;
      SL2_DEL1 <= SL2;
      SH1_DEL2 <= SH1_DEL1;
      SH2_DEL2 <= SH2_DEL1;
      SL1_DEL2 <= SL1_DEL1;
      SL2_DEL2 <= SL2_DEL1;
    end if;
  end process;

  -- 25.6us stretcher for HIT_ON_SL1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if SL1_DEL1 = '1' and SL1_DEL2 = '0' then  -- On an upgoing egde of SL1
        HIT_ON_SL1 <= '1';
      elsif HIT_ON_SL1_COUNTER = "11111111" then
        HIT_ON_SL1 <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL1_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SL1 = '0' then -- HIT_ON_SL1 = '0' makes end of stretcher window
        HIT_ON_SL1_COUNTER <= "00000000";
      else
        HIT_ON_SL1_COUNTER <= HIT_ON_SL1_COUNTER + 1;
      end if;
    end if;
  end process;

  -- 25.6us stretcher for HIT_ON_SL2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if SL2_DEL1 = '1' and SL2_DEL2 = '0' then  -- On an upgoing egde of SL2
        HIT_ON_SL2 <= '1';
      elsif HIT_ON_SL2_COUNTER = "11111111" then
        HIT_ON_SL2 <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL2_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SL2 = '0' then -- HIT_ON_SL2 = '0' makes end of stretcher window
        HIT_ON_SL2_COUNTER <= "00000000";
      else
        HIT_ON_SL2_COUNTER <= HIT_ON_SL2_COUNTER + 1;
      end if;
    end if;
  end process;

  -- 25.6us stretcher for HIT_ON_SH1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if SH1_DEL1 = '1' and SH1_DEL2 = '0' then  -- On an upgoing egde of SH1
        HIT_ON_SH1 <= '1';
      elsif HIT_ON_SH1_COUNTER = "11111111" then
        HIT_ON_SH1 <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH1_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SH1 = '0' then -- HIT_ON_SH1 = '0' makes end of stretcher window
        HIT_ON_SH1_COUNTER <= "00000000";
      else
        HIT_ON_SH1_COUNTER <= HIT_ON_SH1_COUNTER + 1;
      end if;
    end if;
  end process;

  -- 25.6us stretcher for HIT_ON_SH2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if SH2_DEL1 = '1' and SH2_DEL2 = '0' then  -- On an upgoing egde of SH2
        HIT_ON_SH2 <= '1';
      elsif HIT_ON_SH2_COUNTER = "11111111" then
        HIT_ON_SH2 <= '0';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH2_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SH2 = '0' then -- HIT_ON_SH2 = '0' makes end of stretcher window
        HIT_ON_SH2_COUNTER <= "00000000";
      else
        HIT_ON_SH2_COUNTER <= HIT_ON_SH2_COUNTER + 1;
      end if;
    end if;
  end process;

end architecture a0 ; -- of SLAVE_DETECTOR

--------------------------------------------------------------------------------
-- Object        : Entity design.TRIGGER_STUFF
-- Last modified : Wed Apr 28 11:04:30 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity TRIGGER_STUFF is
  port(
    BLOCK_COINC     : in     std_logic;
    CLK10MHz        : in     std_logic;
    CLK200MHz       : in     std_logic;
    COINC           : out    std_logic;
    COINC_TIME      : in     integer range 1000 downto 0;
    COMPH1          : in     std_logic;
    COMPH2          : in     std_logic;
    COMPL1          : in     std_logic;
    COMPL2          : in     std_logic;
    DATA_ADC1_NEG   : in     std_logic_vector(11 downto 0);
    DATA_ADC1_POS   : in     std_logic_vector(11 downto 0);
    DATA_ADC2_NEG   : in     std_logic_vector(11 downto 0);
    DATA_ADC2_POS   : in     std_logic_vector(11 downto 0);
    EXT_TR_IN       : in     std_logic;
    GPS_DATA_MASTER : in     std_logic;
    GPS_DATA_OUT    : out    std_logic;
    LVDS_IN1        : in     std_logic;
    LVDS_IN2        : in     std_logic;
    LVDS_IN3        : in     std_logic;
    LVDS_IN4        : in     std_logic;
    LVDS_OUT1       : out    std_logic;
    LVDS_OUT2       : out    std_logic;
    LVDS_OUT3       : out    std_logic;
    LVDS_OUT4       : out    std_logic;
    MASTER          : in     std_logic;
    ML1             : out    std_logic;
    ML2             : out    std_logic;
    ONE_PPS_MASTER  : in     std_logic;
    ONE_PPS_OUT     : out    std_logic;
    POST_TIME       : in     integer range 1600 downto 0;
    SLAVE_PRESENT   : out    std_logic;
    STARTUP_BLOCK   : out    std_logic;
    SYSRST          : in     std_logic;
    THH1            : in     std_logic_vector(11 downto 0);
    THH2            : in     std_logic_vector(11 downto 0);
    THL1            : in     std_logic_vector(11 downto 0);
    THL2            : in     std_logic_vector(11 downto 0);
    TH_COUNTERS_OUT : out    std_logic_vector(63 downto 0);
    TRIGGER_PATTERN : out    std_logic_vector(15 downto 0);
    TR_CONDITION    : in     std_logic_vector(7 downto 0));
end entity TRIGGER_STUFF;

--------------------------------------------------------------------------------
-- Object        : Architecture design.TRIGGER_STUFF.a0
-- Last modified : Wed Apr 28 11:04:30 2010.
--------------------------------------------------------------------------------

architecture a0 of TRIGGER_STUFF is

  signal SLAVE_PRESENT_net :  std_logic;
  signal MH2_net           :  std_logic;
  signal COMPL1_net        :  std_logic;
  signal COMPH1_net        :  std_logic;
  signal COMPL2_net        :  std_logic;
  signal COMPH2_net        :  std_logic;
  signal SH2_SYNCHR        :  std_logic;
  signal SL2_SYNCHR        :  std_logic;
  signal SH1_SYNCHR        :  std_logic;
  signal SL1_SYNCHR1       :  std_logic;
  signal ML2_net           :  std_logic;
  signal ML1_net           :  std_logic;
  signal EXT_TR_OUT_net    :  std_logic;
  signal MH1_net           :  std_logic;
  signal SL1               :  std_logic;
  signal SH1               :  std_logic;
  signal SL2               :  std_logic;
  signal SH2               :  std_logic;
  signal ONE_PPS_OUT_net0  :  std_logic;
  signal COINC_MASTER      :  std_logic;

  component SLAVE_DETECTOR
    port(
      CLK10MHz      : in     std_logic;
      CLK200MHz     : in     std_logic;
      SH1           : in     std_logic;
      SH1_SYNCHR    : out    std_logic;
      SH2           : in     std_logic;
      SH2_SYNCHR    : out    std_logic;
      SL1           : in     std_logic;
      SL1_SYNCHR    : out    std_logic;
      SL2           : in     std_logic;
      SL2_SYNCHR    : out    std_logic;
      SLAVE_PRESENT : out    std_logic;
      SYSRST        : in     std_logic);
  end component SLAVE_DETECTOR;

  component DISCRIMINATORS
    port(
      BLOCK_COINC   : in     std_logic;
      CLK200MHz     : in     std_logic;
      COINC_TIME    : in     integer range 1000 downto 0;
      COMPH1        : out    std_logic;
      COMPH1_IN     : in     std_logic;
      COMPH2        : out    std_logic;
      COMPH2_IN     : in     std_logic;
      COMPL1        : out    std_logic;
      COMPL1_IN     : in     std_logic;
      COMPL2        : out    std_logic;
      COMPL2_IN     : in     std_logic;
      DATA_ADC1_NEG : in     std_logic_vector(11 downto 0);
      DATA_ADC1_POS : in     std_logic_vector(11 downto 0);
      DATA_ADC2_NEG : in     std_logic_vector(11 downto 0);
      DATA_ADC2_POS : in     std_logic_vector(11 downto 0);
      EXT_TR_IN     : in     std_logic;
      EXT_TR_OUT    : out    std_logic;
      MASTER        : in     std_logic;
      MH1_OUT       : out    std_logic;
      MH2_OUT       : out    std_logic;
      ML1_OUT       : out    std_logic;
      ML2_OUT       : out    std_logic;
      POST_TIME     : in     integer range 1600 downto 0;
      SYSRST        : in     std_logic;
      THH1          : in     std_logic_vector(11 downto 0);
      THH2          : in     std_logic_vector(11 downto 0);
      THL1          : in     std_logic_vector(11 downto 0);
      THL2          : in     std_logic_vector(11 downto 0));
  end component DISCRIMINATORS;

  component TRIGGER_MATRIX
    port(
      BLOCK_COINC       : in     std_logic;
      CLK10MHz          : in     std_logic;
      CLK200MHz         : in     std_logic;
      COINC_TO_END_TIME : out    std_logic;
      COMPH1            : in     std_logic;
      COMPH2            : in     std_logic;
      COMPL1            : in     std_logic;
      COMPL2            : in     std_logic;
      EXT_TR            : in     std_logic;
      MASTER            : in     std_logic;
      MH1               : in     std_logic;
      MH2               : in     std_logic;
      ML1               : in     std_logic;
      ML2               : in     std_logic;
      ONE_PPS           : in     std_logic;
      POST_TIME         : in     integer range 1600 downto 0;
      SH1_IN            : in     std_logic;
      SH2_IN            : in     std_logic;
      SL1_IN            : in     std_logic;
      SL2_IN            : in     std_logic;
      SLAVE_PRESENT     : in     std_logic;
      STARTUP_BLOCK_OUT : out    std_logic;
      SYSRST            : in     std_logic;
      TRIGGER_PATTERN   : out    std_logic_vector(15 downto 0);
      TR_CONDITION      : in     std_logic_vector(7 downto 0));
  end component TRIGGER_MATRIX;

  component THRESHOLD_COUNTERS
    port(
      CLK200MHz       : in     std_logic;
      MH1             : in     std_logic;
      MH2             : in     std_logic;
      ML1             : in     std_logic;
      ML2             : in     std_logic;
      ONE_PPS         : in     std_logic;
      SYSRST          : in     std_logic;
      TH_COUNTERS_OUT : out    std_logic_vector(63 downto 0));
  end component THRESHOLD_COUNTERS;

  component LVDS_MUX
    port(
      CLK10MHz        : in     std_logic;
      CLK200MHz       : in     std_logic;
      COINC           : out    std_logic;
      COINC_MASTER    : in     std_logic;
      GPS_DATA_MASTER : in     std_logic;
      GPS_DATA_OUT    : out    std_logic;
      LVDS_IN1        : in     std_logic;
      LVDS_IN2        : in     std_logic;
      LVDS_IN3        : in     std_logic;
      LVDS_IN4        : in     std_logic;
      LVDS_OUT1       : out    std_logic;
      LVDS_OUT2       : out    std_logic;
      LVDS_OUT3       : out    std_logic;
      LVDS_OUT4       : out    std_logic;
      MASTER          : in     std_logic;
      MH1             : in     std_logic;
      MH2             : in     std_logic;
      ML1             : in     std_logic;
      ML2             : in     std_logic;
      ONE_PPS_MASTER  : in     std_logic;
      ONE_PPS_OUT     : out    std_logic;
      SH1             : out    std_logic;
      SH2             : out    std_logic;
      SL1             : out    std_logic;
      SL2             : out    std_logic;
      SYSRST          : in     std_logic);
  end component LVDS_MUX;

begin
  SLAVE_PRESENT <= SLAVE_PRESENT_net;
  ML2 <= ML2_net;
  ML1 <= ML1_net;
  ONE_PPS_OUT <= ONE_PPS_OUT_net0;
  u5: SLAVE_DETECTOR
    port map(
      CLK10MHz      => CLK10MHz,
      CLK200MHz     => CLK200MHz,
      SH1           => SH1,
      SH1_SYNCHR    => SH1_SYNCHR,
      SH2           => SH2,
      SH2_SYNCHR    => SH2_SYNCHR,
      SL1           => SL1,
      SL1_SYNCHR    => SL1_SYNCHR1,
      SL2           => SL2,
      SL2_SYNCHR    => SL2_SYNCHR,
      SLAVE_PRESENT => SLAVE_PRESENT_net,
      SYSRST        => SYSRST);

  u1: DISCRIMINATORS
    port map(
      BLOCK_COINC   => BLOCK_COINC,
      CLK200MHz     => CLK200MHz,
      COINC_TIME    => COINC_TIME,
      COMPH1        => COMPH1_net,
      COMPH1_IN     => COMPH1,
      COMPH2        => COMPH2_net,
      COMPH2_IN     => COMPH2,
      COMPL1        => COMPL1_net,
      COMPL1_IN     => COMPL1,
      COMPL2        => COMPL2_net,
      COMPL2_IN     => COMPL2,
      DATA_ADC1_NEG => DATA_ADC1_NEG,
      DATA_ADC1_POS => DATA_ADC1_POS,
      DATA_ADC2_NEG => DATA_ADC2_NEG,
      DATA_ADC2_POS => DATA_ADC2_POS,
      EXT_TR_IN     => EXT_TR_IN,
      EXT_TR_OUT    => EXT_TR_OUT_net,
      MASTER        => MASTER,
      MH1_OUT       => MH1_net,
      MH2_OUT       => MH2_net,
      ML1_OUT       => ML1_net,
      ML2_OUT       => ML2_net,
      POST_TIME     => POST_TIME,
      SYSRST        => SYSRST,
      THH1          => THH1,
      THH2          => THH2,
      THL1          => THL1,
      THL2          => THL2);

  u2: TRIGGER_MATRIX
    port map(
      BLOCK_COINC       => BLOCK_COINC,
      CLK10MHz          => CLK10MHz,
      CLK200MHz         => CLK200MHz,
      COINC_TO_END_TIME => COINC_MASTER,
      COMPH1            => COMPH1_net,
      COMPH2            => COMPH2_net,
      COMPL1            => COMPL1_net,
      COMPL2            => COMPL2_net,
      EXT_TR            => EXT_TR_OUT_net,
      MASTER            => MASTER,
      MH1               => MH1_net,
      MH2               => MH2_net,
      ML1               => ML1_net,
      ML2               => ML2_net,
      ONE_PPS           => ONE_PPS_OUT_net0,
      POST_TIME         => POST_TIME,
      SH1_IN            => SH1_SYNCHR,
      SH2_IN            => SH2_SYNCHR,
      SL1_IN            => SL1_SYNCHR1,
      SL2_IN            => SL2_SYNCHR,
      SLAVE_PRESENT     => SLAVE_PRESENT_net,
      STARTUP_BLOCK_OUT => STARTUP_BLOCK,
      SYSRST            => SYSRST,
      TRIGGER_PATTERN   => TRIGGER_PATTERN,
      TR_CONDITION      => TR_CONDITION);

  u3: THRESHOLD_COUNTERS
    port map(
      CLK200MHz       => CLK200MHz,
      MH1             => MH1_net,
      MH2             => MH2_net,
      ML1             => ML1_net,
      ML2             => ML2_net,
      ONE_PPS         => ONE_PPS_OUT_net0,
      SYSRST          => SYSRST,
      TH_COUNTERS_OUT => TH_COUNTERS_OUT);

  u4: LVDS_MUX
    port map(
      CLK10MHz        => CLK10MHz,
      CLK200MHz       => CLK200MHz,
      COINC           => COINC,
      COINC_MASTER    => COINC_MASTER,
      GPS_DATA_MASTER => GPS_DATA_MASTER,
      GPS_DATA_OUT    => GPS_DATA_OUT,
      LVDS_IN1        => LVDS_IN1,
      LVDS_IN2        => LVDS_IN2,
      LVDS_IN3        => LVDS_IN3,
      LVDS_IN4        => LVDS_IN4,
      LVDS_OUT1       => LVDS_OUT1,
      LVDS_OUT2       => LVDS_OUT2,
      LVDS_OUT3       => LVDS_OUT3,
      LVDS_OUT4       => LVDS_OUT4,
      MASTER          => MASTER,
      MH1             => MH1_net,
      MH2             => MH2_net,
      ML1             => ML1_net,
      ML2             => ML2_net,
      ONE_PPS_MASTER  => ONE_PPS_MASTER,
      ONE_PPS_OUT     => ONE_PPS_OUT_net0,
      SH1             => SH1,
      SH2             => SH2,
      SL1             => SL1,
      SL2             => SL2,
      SYSRST          => SYSRST);

end architecture a0 ; -- of TRIGGER_STUFF

--------------------------------------------------------------------------------
-- Object        : Entity design.SYNCHRONISATION
-- Last modified : Fri Jun 04 13:16:55 2010.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity SYNCHRONISATION is
  port(
    CLK200MHz     : in     std_logic;
    DATA_NEG_ADC  : in     std_logic_vector(11 downto 0);
    DATA_POS_ADC  : in     std_logic_vector(11 downto 0);
    DCO_NEG_ADC   : in     std_logic;
    DCO_POS_ADC   : in     std_logic;
    DOUT_NEG      : out    std_logic_vector(11 downto 0);
    DOUT_POS      : out    std_logic_vector(11 downto 0);
    FAKE_DATA     : in     std_logic;
    FAKE_DATA_NEG : in     std_logic_vector(11 downto 0);
    FAKE_DATA_POS : in     std_logic_vector(11 downto 0);
    LOCKED        : in     std_logic;
    SYSRST        : in     std_logic);
end entity SYNCHRONISATION;

--------------------------------------------------------------------------------
-- Object        : Architecture design.SYNCHRONISATION.a0
-- Last modified : Fri Jun 04 13:16:55 2010.
--------------------------------------------------------------------------------


architecture a0 of SYNCHRONISATION is

signal RST: std_logic;

signal DATA_POS_ADC_TMP1: std_logic_vector(11 downto 0);
signal DATA_POS_ADC_TMP2: std_logic_vector(11 downto 0);
signal DATA_NEG_ADC_TMP1: std_logic_vector(11 downto 0);
signal DATA_NEG_ADC_TMP2: std_logic_vector(11 downto 0);

begin

  RST <= SYSRST or not LOCKED;

-- SYNCHRONISATION ADC signals
-- Latch positive ADC signals on ADC clock
  process(DCO_POS_ADC,RST)
  begin
    if RST = '1' then
      DATA_POS_ADC_TMP1 <= (others => '0');
    elsif (DCO_POS_ADC'event and DCO_POS_ADC = '1') then
      DATA_POS_ADC_TMP1 <= DATA_POS_ADC;
    end if;
  end process;

-- Synchronize DATA_POS_ADC_TMP1 with CLK200MHz or latch fake data
  process(CLK200MHz,RST)
  begin
    if RST = '1' then
      DATA_POS_ADC_TMP2 <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if FAKE_DATA = '0' then
        DATA_POS_ADC_TMP2 <= DATA_POS_ADC_TMP1;
      else
        DATA_POS_ADC_TMP2 <= FAKE_DATA_POS;
      end if;
    end if;
  end process;

  process(CLK200MHz,RST)
  begin
    if RST = '1' then
      Dout_POS <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      Dout_POS <= DATA_POS_ADC_TMP2;
    end if;
  end process;

-- Latch negative ADC signals on ADC clock
  process(DCO_NEG_ADC,RST)
  begin
    if RST = '1' then
      DATA_NEG_ADC_TMP1 <= (others => '0');
    elsif (DCO_NEG_ADC'event and DCO_NEG_ADC = '1') then
      DATA_NEG_ADC_TMP1 <= DATA_NEG_ADC;
    end if;
  end process;

-- Synchronize DATA_NEG_ADC_TMP1 with CLK200MHz or latch fake data
  process(CLK200MHz,RST)
  begin
    if RST = '1' then
      DATA_NEG_ADC_TMP2 <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '0') then -- negative edge
      if FAKE_DATA = '0' then
        DATA_NEG_ADC_TMP2 <= DATA_NEG_ADC_TMP1;
      else
        DATA_NEG_ADC_TMP2 <= FAKE_DATA_NEG;
      end if;
    end if;
  end process;

  process(CLK200MHz,RST)
  begin
    if RST = '1' then
      Dout_NEG <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      Dout_NEG <= DATA_NEG_ADC_TMP2;
    end if;
  end process;

end architecture a0 ; -- of SYNCHRONISATION

--------------------------------------------------------------------------------
-- Object        : Entity design.PLL
-- Last modified : Mon Jan 24 11:45:58 2011.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity PLL is
  port(
    CLK200MHz : out    std_logic;
    inclk0    : in     std_logic;
    locked    : out    std_logic);
end entity PLL;

--------------------------------------------------------------------------------
-- Object        : Architecture design.PLL.a0
-- Last modified : Mon Jan 24 11:45:58 2011.
--------------------------------------------------------------------------------


-- megafunction wizard: %ALTPLL%
-- GENERATION: STANDARD
-- VERSION: WM1.0
-- MODULE: altpll 

-- ============================================================
-- File Name: PLL.vhd
-- Megafunction Name(s):
-- 			altpll
--
-- Simulation Library Files(s):
-- 			altera_mf
-- ============================================================
-- ************************************************************
-- THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
--
-- 9.0 Build 235 06/17/2009 SP 2 SJ Full Version
-- ************************************************************


--Copyright (C) 1991-2009 Altera Corporation
--Your use of Altera Corporation's design tools, logic functions 
--and other software and tools, and its AMPP partner logic 
--functions, and any output files from any of the foregoing 
--(including device programming or simulation files), and any 
--associated documentation or information are expressly subject 
--to the terms and conditions of the Altera Program License 
--Subscription Agreement, Altera MegaCore Function License 
--Agreement, or other applicable license agreement, including, 
--without limitation, that your use is for the sole purpose of 
--programming logic devices manufactured by Altera and sold by 
--Altera or its authorized distributors.  Please refer to the 
--applicable agreement for further details.


LIBRARY ieee;
USE ieee.std_logic_1164.all;

LIBRARY altera_mf;
USE altera_mf.all;

--ENTITY PLL IS
--	PORT
--	(
--		inclk0		: IN STD_LOGIC  := '0';
--		c0		: OUT STD_LOGIC ;
--		locked		: OUT STD_LOGIC 
--	);
--END PLL;


architecture a0 of PLL is

	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (4 DOWNTO 0);
	SIGNAL sub_wire1	: STD_LOGIC ;
	SIGNAL sub_wire2	: STD_LOGIC ;
	SIGNAL sub_wire3	: STD_LOGIC ;
	SIGNAL sub_wire4	: STD_LOGIC_VECTOR (1 DOWNTO 0);
	SIGNAL sub_wire5_bv	: BIT_VECTOR (0 DOWNTO 0);
	SIGNAL sub_wire5	: STD_LOGIC_VECTOR (0 DOWNTO 0);



	COMPONENT altpll
	GENERIC (
		bandwidth_type		: STRING;
		clk0_divide_by		: NATURAL;
		clk0_duty_cycle		: NATURAL;
		clk0_multiply_by		: NATURAL;
		clk0_phase_shift		: STRING;
		compensate_clock		: STRING;
		inclk0_input_frequency		: NATURAL;
		intended_device_family		: STRING;
		lpm_hint		: STRING;
		lpm_type		: STRING;
		operation_mode		: STRING;
		pll_type		: STRING;
		port_activeclock		: STRING;
		port_areset		: STRING;
		port_clkbad0		: STRING;
		port_clkbad1		: STRING;
		port_clkloss		: STRING;
		port_clkswitch		: STRING;
		port_configupdate		: STRING;
		port_fbin		: STRING;
		port_inclk0		: STRING;
		port_inclk1		: STRING;
		port_locked		: STRING;
		port_pfdena		: STRING;
		port_phasecounterselect		: STRING;
		port_phasedone		: STRING;
		port_phasestep		: STRING;
		port_phaseupdown		: STRING;
		port_pllena		: STRING;
		port_scanaclr		: STRING;
		port_scanclk		: STRING;
		port_scanclkena		: STRING;
		port_scandata		: STRING;
		port_scandataout		: STRING;
		port_scandone		: STRING;
		port_scanread		: STRING;
		port_scanwrite		: STRING;
		port_clk0		: STRING;
		port_clk1		: STRING;
		port_clk2		: STRING;
		port_clk3		: STRING;
		port_clk4		: STRING;
		port_clk5		: STRING;
		port_clkena0		: STRING;
		port_clkena1		: STRING;
		port_clkena2		: STRING;
		port_clkena3		: STRING;
		port_clkena4		: STRING;
		port_clkena5		: STRING;
		port_extclk0		: STRING;
		port_extclk1		: STRING;
		port_extclk2		: STRING;
		port_extclk3		: STRING;
		self_reset_on_loss_lock		: STRING;
		width_clock		: NATURAL
	);
	PORT (
			inclk	: IN STD_LOGIC_VECTOR (1 DOWNTO 0);
			locked	: OUT STD_LOGIC ;
			clk	: OUT STD_LOGIC_VECTOR (4 DOWNTO 0)
	);
	END COMPONENT;

BEGIN
	sub_wire5_bv(0 DOWNTO 0) <= "0";
	sub_wire5    <= To_stdlogicvector(sub_wire5_bv);
	sub_wire1    <= sub_wire0(0);
--	c0    <= sub_wire1;
	CLK200MHz    <= sub_wire1;
	locked    <= sub_wire2;
	sub_wire3    <= inclk0;
	sub_wire4    <= sub_wire5(0 DOWNTO 0) & sub_wire3;

	altpll_component : altpll
	GENERIC MAP (
		bandwidth_type => "AUTO",
		clk0_divide_by => 1,
		clk0_duty_cycle => 50,
		clk0_multiply_by => 1,
--		clk0_phase_shift => "3750",
		clk0_phase_shift => "0",
		compensate_clock => "CLK0",
		inclk0_input_frequency => 5000,
		intended_device_family => "Cyclone III",
		lpm_hint => "CBX_MODULE_PREFIX=PLL",
		lpm_type => "altpll",
		operation_mode => "NORMAL",
		pll_type => "AUTO",
		port_activeclock => "PORT_UNUSED",
		port_areset => "PORT_UNUSED",
		port_clkbad0 => "PORT_UNUSED",
		port_clkbad1 => "PORT_UNUSED",
		port_clkloss => "PORT_UNUSED",
		port_clkswitch => "PORT_UNUSED",
		port_configupdate => "PORT_UNUSED",
		port_fbin => "PORT_UNUSED",
		port_inclk0 => "PORT_USED",
		port_inclk1 => "PORT_UNUSED",
		port_locked => "PORT_USED",
		port_pfdena => "PORT_UNUSED",
		port_phasecounterselect => "PORT_UNUSED",
		port_phasedone => "PORT_UNUSED",
		port_phasestep => "PORT_UNUSED",
		port_phaseupdown => "PORT_UNUSED",
		port_pllena => "PORT_UNUSED",
		port_scanaclr => "PORT_UNUSED",
		port_scanclk => "PORT_UNUSED",
		port_scanclkena => "PORT_UNUSED",
		port_scandata => "PORT_UNUSED",
		port_scandataout => "PORT_UNUSED",
		port_scandone => "PORT_UNUSED",
		port_scanread => "PORT_UNUSED",
		port_scanwrite => "PORT_UNUSED",
		port_clk0 => "PORT_USED",
		port_clk1 => "PORT_UNUSED",
		port_clk2 => "PORT_UNUSED",
		port_clk3 => "PORT_UNUSED",
		port_clk4 => "PORT_UNUSED",
		port_clk5 => "PORT_UNUSED",
		port_clkena0 => "PORT_UNUSED",
		port_clkena1 => "PORT_UNUSED",
		port_clkena2 => "PORT_UNUSED",
		port_clkena3 => "PORT_UNUSED",
		port_clkena4 => "PORT_UNUSED",
		port_clkena5 => "PORT_UNUSED",
		port_extclk0 => "PORT_UNUSED",
		port_extclk1 => "PORT_UNUSED",
		port_extclk2 => "PORT_UNUSED",
		port_extclk3 => "PORT_UNUSED",
		self_reset_on_loss_lock => "OFF",
		width_clock => 5
	)
	PORT MAP (
		inclk => sub_wire4,
		clk => sub_wire0,
		locked => sub_wire2
	);



end architecture a0 ; -- of PLL

-- ============================================================
-- CNX file retrieval info
-- ============================================================
-- Retrieval info: PRIVATE: ACTIVECLK_CHECK STRING "0"
-- Retrieval info: PRIVATE: BANDWIDTH STRING "1.000"
-- Retrieval info: PRIVATE: BANDWIDTH_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: BANDWIDTH_FREQ_UNIT STRING "MHz"
-- Retrieval info: PRIVATE: BANDWIDTH_PRESET STRING "Low"
-- Retrieval info: PRIVATE: BANDWIDTH_USE_AUTO STRING "1"
-- Retrieval info: PRIVATE: BANDWIDTH_USE_PRESET STRING "0"
-- Retrieval info: PRIVATE: CLKBAD_SWITCHOVER_CHECK STRING "0"
-- Retrieval info: PRIVATE: CLKLOSS_CHECK STRING "0"
-- Retrieval info: PRIVATE: CLKSWITCH_CHECK STRING "0"
-- Retrieval info: PRIVATE: CNX_NO_COMPENSATE_RADIO STRING "0"
-- Retrieval info: PRIVATE: CREATE_CLKBAD_CHECK STRING "0"
-- Retrieval info: PRIVATE: CREATE_INCLK1_CHECK STRING "0"
-- Retrieval info: PRIVATE: CUR_DEDICATED_CLK STRING "c0"
-- Retrieval info: PRIVATE: CUR_FBIN_CLK STRING "e0"
-- Retrieval info: PRIVATE: DEVICE_SPEED_GRADE STRING "Any"
-- Retrieval info: PRIVATE: DIV_FACTOR0 NUMERIC "1"
-- Retrieval info: PRIVATE: DUTY_CYCLE0 STRING "50.00000000"
-- Retrieval info: PRIVATE: EFF_OUTPUT_FREQ_VALUE0 STRING "200.000000"
-- Retrieval info: PRIVATE: EXPLICIT_SWITCHOVER_COUNTER STRING "0"
-- Retrieval info: PRIVATE: EXT_FEEDBACK_RADIO STRING "0"
-- Retrieval info: PRIVATE: GLOCKED_COUNTER_EDIT_CHANGED STRING "1"
-- Retrieval info: PRIVATE: GLOCKED_FEATURE_ENABLED STRING "0"
-- Retrieval info: PRIVATE: GLOCKED_MODE_CHECK STRING "0"
-- Retrieval info: PRIVATE: GLOCK_COUNTER_EDIT NUMERIC "1048575"
-- Retrieval info: PRIVATE: HAS_MANUAL_SWITCHOVER STRING "1"
-- Retrieval info: PRIVATE: INCLK0_FREQ_EDIT STRING "200.000"
-- Retrieval info: PRIVATE: INCLK0_FREQ_UNIT_COMBO STRING "MHz"
-- Retrieval info: PRIVATE: INCLK1_FREQ_EDIT STRING "100.000"
-- Retrieval info: PRIVATE: INCLK1_FREQ_EDIT_CHANGED STRING "1"
-- Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_CHANGED STRING "1"
-- Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_COMBO STRING "MHz"
-- Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone III"
-- Retrieval info: PRIVATE: INT_FEEDBACK__MODE_RADIO STRING "1"
-- Retrieval info: PRIVATE: LOCKED_OUTPUT_CHECK STRING "1"
-- Retrieval info: PRIVATE: LONG_SCAN_RADIO STRING "1"
-- Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE STRING "300.000"
-- Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE_DIRTY NUMERIC "0"
-- Retrieval info: PRIVATE: LVDS_PHASE_SHIFT_UNIT0 STRING "deg"
-- Retrieval info: PRIVATE: MIG_DEVICE_SPEED_GRADE STRING "Any"
-- Retrieval info: PRIVATE: MIRROR_CLK0 STRING "0"
-- Retrieval info: PRIVATE: MULT_FACTOR0 NUMERIC "1"
-- Retrieval info: PRIVATE: NORMAL_MODE_RADIO STRING "1"
-- Retrieval info: PRIVATE: OUTPUT_FREQ0 STRING "100.00000000"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_MODE0 STRING "0"
-- Retrieval info: PRIVATE: OUTPUT_FREQ_UNIT0 STRING "MHz"
-- Retrieval info: PRIVATE: PHASE_RECONFIG_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: PHASE_RECONFIG_INPUTS_CHECK STRING "0"
-- Retrieval info: PRIVATE: PHASE_SHIFT0 STRING "0.00000000"
-- Retrieval info: PRIVATE: PHASE_SHIFT_STEP_ENABLED_CHECK STRING "0"
-- Retrieval info: PRIVATE: PHASE_SHIFT_UNIT0 STRING "deg"
-- Retrieval info: PRIVATE: PLL_ADVANCED_PARAM_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_ARESET_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_AUTOPLL_CHECK NUMERIC "1"
-- Retrieval info: PRIVATE: PLL_ENHPLL_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PLL_FASTPLL_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PLL_FBMIMIC_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_LVDS_PLL_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PLL_PFDENA_CHECK STRING "0"
-- Retrieval info: PRIVATE: PLL_TARGET_HARCOPY_CHECK NUMERIC "0"
-- Retrieval info: PRIVATE: PRIMARY_CLK_COMBO STRING "inclk0"
-- Retrieval info: PRIVATE: RECONFIG_FILE STRING "PLL.mif"
-- Retrieval info: PRIVATE: SACN_INPUTS_CHECK STRING "0"
-- Retrieval info: PRIVATE: SCAN_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: SELF_RESET_LOCK_LOSS STRING "0"
-- Retrieval info: PRIVATE: SHORT_SCAN_RADIO STRING "0"
-- Retrieval info: PRIVATE: SPREAD_FEATURE_ENABLED STRING "0"
-- Retrieval info: PRIVATE: SPREAD_FREQ STRING "50.000"
-- Retrieval info: PRIVATE: SPREAD_FREQ_UNIT STRING "KHz"
-- Retrieval info: PRIVATE: SPREAD_PERCENT STRING "0.500"
-- Retrieval info: PRIVATE: SPREAD_USE STRING "0"
-- Retrieval info: PRIVATE: SRC_SYNCH_COMP_RADIO STRING "0"
-- Retrieval info: PRIVATE: STICKY_CLK0 STRING "1"
-- Retrieval info: PRIVATE: SWITCHOVER_COUNT_EDIT NUMERIC "1"
-- Retrieval info: PRIVATE: SWITCHOVER_FEATURE_ENABLED STRING "1"
-- Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
-- Retrieval info: PRIVATE: USE_CLK0 STRING "1"
-- Retrieval info: PRIVATE: USE_CLKENA0 STRING "0"
-- Retrieval info: PRIVATE: USE_MIL_SPEED_GRADE NUMERIC "0"
-- Retrieval info: PRIVATE: ZERO_DELAY_RADIO STRING "0"
-- Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
-- Retrieval info: CONSTANT: BANDWIDTH_TYPE STRING "AUTO"
-- Retrieval info: CONSTANT: CLK0_DIVIDE_BY NUMERIC "1"
-- Retrieval info: CONSTANT: CLK0_DUTY_CYCLE NUMERIC "50"
-- Retrieval info: CONSTANT: CLK0_MULTIPLY_BY NUMERIC "1"
-- Retrieval info: CONSTANT: CLK0_PHASE_SHIFT STRING "0"
-- Retrieval info: CONSTANT: COMPENSATE_CLOCK STRING "CLK0"
-- Retrieval info: CONSTANT: INCLK0_INPUT_FREQUENCY NUMERIC "5000"
-- Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Cyclone III"
-- Retrieval info: CONSTANT: LPM_TYPE STRING "altpll"
-- Retrieval info: CONSTANT: OPERATION_MODE STRING "NORMAL"
-- Retrieval info: CONSTANT: PLL_TYPE STRING "AUTO"
-- Retrieval info: CONSTANT: PORT_ACTIVECLOCK STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_ARESET STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKBAD0 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKBAD1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKLOSS STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CLKSWITCH STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_CONFIGUPDATE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_FBIN STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_INCLK0 STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_INCLK1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_LOCKED STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_PFDENA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASECOUNTERSELECT STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASEDONE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASESTEP STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PHASEUPDOWN STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_PLLENA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANACLR STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANCLK STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANCLKENA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANDATA STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANDATAOUT STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANDONE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANREAD STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_SCANWRITE STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk0 STRING "PORT_USED"
-- Retrieval info: CONSTANT: PORT_clk1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk2 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk3 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk4 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clk5 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena0 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena2 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena3 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena4 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_clkena5 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk0 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk1 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk2 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: PORT_extclk3 STRING "PORT_UNUSED"
-- Retrieval info: CONSTANT: SELF_RESET_ON_LOSS_LOCK STRING "OFF"
-- Retrieval info: CONSTANT: WIDTH_CLOCK NUMERIC "5"
-- Retrieval info: USED_PORT: @clk 0 0 5 0 OUTPUT_CLK_EXT VCC "@clk[4..0]"
-- Retrieval info: USED_PORT: @inclk 0 0 2 0 INPUT_CLK_EXT VCC "@inclk[1..0]"
-- Retrieval info: USED_PORT: c0 0 0 0 0 OUTPUT_CLK_EXT VCC "c0"
-- Retrieval info: USED_PORT: inclk0 0 0 0 0 INPUT_CLK_EXT GND "inclk0"
-- Retrieval info: USED_PORT: locked 0 0 0 0 OUTPUT GND "locked"
-- Retrieval info: CONNECT: locked 0 0 0 0 @locked 0 0 0 0
-- Retrieval info: CONNECT: @inclk 0 0 1 0 inclk0 0 0 0 0
-- Retrieval info: CONNECT: c0 0 0 0 0 @clk 0 0 1 0
-- Retrieval info: CONNECT: @inclk 0 0 1 1 GND 0 0 0 0
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL.vhd TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL.ppf TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL.inc FALSE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL.cmp TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL.bsf FALSE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_inst.vhd FALSE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_waveforms.html TRUE
-- Retrieval info: GEN_FILE: TYPE_NORMAL PLL_wave*.jpg FALSE
-- Retrieval info: LIB_FILE: altera_mf
-- Retrieval info: CBX_MODULE_PREFIX: ON
--------------------------------------------------------------------------------
-- Object        : Entity design.FPGA
-- Last modified : Mon Feb 27 11:44:57 2012.
--------------------------------------------------------------------------------



library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity FPGA is
  port(
    ADC_A0           : out    std_logic;
    ADC_A1           : out    std_logic;
    ADC_DATA         : in     std_logic_vector(7 downto 0);
    ADC_MODE         : out    std_logic;
    ADC_nCS          : out    std_logic;
    ADC_nINT         : in     std_logic;
    ADC_nRD          : out    std_logic;
    ADC_nWR_RDY      : in     std_logic;
    CLK200MHz_LVDS   : in     std_logic;
    CLK40MHz_CMOS    : in     std_logic;
    COINC_LED        : out    std_logic;
    COMPH1           : in     std_logic;
    COMPH2           : in     std_logic;
    COMPL1           : in     std_logic;
    COMPL2           : in     std_logic;
    DAC_A0           : out    std_logic;
    DAC_A1           : out    std_logic;
    DAC_A2           : out    std_logic;
    DAC_DATA_0       : out    std_logic;
    DAC_DATA_1       : out    std_logic;
    DAC_DATA_2       : out    std_logic;
    DAC_DATA_3       : out    std_logic;
    DAC_DATA_4       : out    std_logic;
    DAC_DATA_5       : out    std_logic;
    DAC_DATA_6       : out    std_logic;
    DAC_DATA_7       : out    std_logic;
    DAC_nCLR         : out    std_logic;
    DAC_nCS_GAIN     : out    std_logic;
    DAC_nCS_OFFSET   : out    std_logic;
    DAC_nLDAC        : out    std_logic;
    DAC_nRD          : out    std_logic;
    DAC_nWR          : out    std_logic;
    DATA_NEG_ADC_CH1 : in     std_logic_vector(11 downto 0);
    DATA_NEG_ADC_CH2 : in     std_logic_vector(11 downto 0);
    DATA_POS_ADC_CH1 : in     std_logic_vector(11 downto 0);
    DATA_POS_ADC_CH2 : in     std_logic_vector(11 downto 0);
    DCO_NEG_ADC_CH1  : in     std_logic;
    DCO_NEG_ADC_CH2  : in     std_logic;
    DCO_POS_ADC_CH1  : in     std_logic;
    DCO_POS_ADC_CH2  : in     std_logic;
    EXT_TR_IN_n      : in     std_logic;
    FT232_CON        : in     std_logic;
    FT232_RXD        : out    std_logic;
    FT232_TXD        : in     std_logic;
    GPS_1PPS         : in     std_logic;
    GPS_RXD          : out    std_logic;
    GPS_TXD          : in     std_logic;
    HITLED_CH1       : out    std_logic;
    HITLED_CH2       : out    std_logic;
    INTF1_IO         : out    std_logic_vector(2 downto 0);
    INTF2_IO         : in     std_logic_vector(7 downto 0);
    LED0             : out    std_logic;
    LED1             : out    std_logic;
    LED2             : out    std_logic;
    LED3             : out    std_logic;
    LED4             : out    std_logic;
    LED5             : out    std_logic;
    LED6             : out    std_logic;
    LED7             : out    std_logic;
    LVDS_IN1         : in     std_logic;
    LVDS_IN2         : in     std_logic;
    LVDS_IN3         : in     std_logic;
    LVDS_IN4         : in     std_logic;
    LVDS_OUT1        : out    std_logic;
    LVDS_OUT2        : out    std_logic;
    LVDS_OUT3        : out    std_logic;
    LVDS_OUT4        : out    std_logic;
    SERIAL_NUMBER    : in     std_logic_vector(9 downto 0);
    USB_DATA         : inout  std_logic_vector(7 downto 0);
    USB_RD           : out    std_logic;
    USB_RXF          : in     std_logic;
    USB_TXE          : in     std_logic;
    USB_WR           : out    std_logic;
    USB_nPWREN       : in     std_logic;
    nSYSRST          : in     std_logic);
end entity FPGA;

--------------------------------------------------------------------------------
-- Object        : Architecture design.FPGA.a0
-- Last modified : Mon Feb 27 11:44:57 2012.
--------------------------------------------------------------------------------

architecture a0 of FPGA is

  signal SYSRST                  :  std_logic;
  signal CLK200MHz               :  std_logic;
  signal CLKRD                   :  std_logic;
  signal DOUT_POS0               :  std_logic_vector(11 downto 0);
  signal DOUT_NEG0               :  std_logic_vector(11 downto 0);
  signal DOUT_POS                :  std_logic_vector(11 downto 0);
  signal DOUT_NEG                :  std_logic_vector(11 downto 0);
  signal CLK10MHz                :  std_logic;
  signal THL1                    :  std_logic_vector(11 downto 0);
  signal THH1                    :  std_logic_vector(11 downto 0);
  signal TOTAL_TIME              :  integer range 2000 downto 0;
  signal TOTAL_TIME_3X           :  integer range 6000 downto 0;
  signal POST_TIME               :  integer range 1600 downto 0;
  signal COINC_TIME              :  integer range 1000 downto 0;
  signal THH2                    :  std_logic_vector(11 downto 0);
  signal THL2                    :  std_logic_vector(11 downto 0);
  signal TH_COUNTERS_OUT0        :  std_logic_vector(63 downto 0);
  signal GPS_TS_ONE_PPS_OUT      :  std_logic_vector(55 downto 0);
  signal CTP_TS_ONE_PPS_OUT      :  std_logic_vector(31 downto 0);
  signal CTD_TS_ONE_PPS_OUT      :  std_logic_vector(31 downto 0);
  signal TS_ONE_PPS_READOUT_DONE :  std_logic;
  signal SOFT_RESET0             :  std_logic;
  signal GPS_DATA_OUT0           :  std_logic;
  signal TR_CONDITION            :  std_logic_vector(7 downto 0);
  signal TRIGGER_PATTERN1        :  std_logic_vector(15 downto 0);
  signal GPS_TS_OUT0             :  std_logic_vector(55 downto 0);
  signal SLAVE_PRESENT0          :  std_logic;
  signal TEMP_OUT                :  std_logic_vector(31 downto 0);
  signal CTD_OUT0                :  std_logic_vector(31 downto 0);
  signal SAT_INFO_OUT            :  std_logic_vector(487 downto 0);
  signal LATITUDE_OUT            :  std_logic_vector(63 downto 0);
  signal LONGITUDE_OUT           :  std_logic_vector(63 downto 0);
  signal ALTITUDE_OUT            :  std_logic_vector(63 downto 0);
  signal COMPDATA_OUT            :  std_logic_vector(127 downto 0);
  signal COMPDATA_VALID_OUT0     :  std_logic;
  signal COMPDATA_READOUT_DONE   :  std_logic;
  signal GPS_PROG_ENABLE0        :  std_logic;
  signal FORCE_MASTER0           :  std_logic;
  signal COINC                   :  std_logic;
  signal RDEN2_CH2               :  std_logic;
  signal RDEN1_CH1               :  std_logic;
  signal RDEN2_CH1               :  std_logic;
  signal TIME_OUT_RESET          :  std_logic;
  signal RDEN1_CH2               :  std_logic;
  signal STARTUP_BLOCK           :  std_logic;
  signal BLOCK_COINC0            :  std_logic;
  signal UTXE                    :  std_logic;
  signal URXF                    :  std_logic;
  signal UWR                     :  std_logic;
  signal URD                     :  std_logic;
  signal DOUT_VALID              :  std_logic;
  signal EVENT_DATA_READY        :  std_logic;
  signal RDEN                    :  std_logic;
  signal DATA_OUT                :  std_logic_vector(7 downto 0);
  signal TRIGGER_PATTERN0        :  std_logic_vector(15 downto 0);
  signal GPS_TS_OUT              :  std_logic_vector(55 downto 0);
  signal CTD_OUT                 :  std_logic_vector(31 downto 0);
  signal DATA_OUT1_CH1           :  std_logic_vector(11 downto 0);
  signal DATA_OUT2_CH1           :  std_logic_vector(11 downto 0);
  signal DATA_READY1_CH1         :  std_logic;
  signal DATA_READY2_CH1         :  std_logic;
  signal READOUT_BUSY1_CH1       :  std_logic;
  signal READOUT_BUSY2_CH1       :  std_logic;
  signal DATA_OUT1_CH2           :  std_logic_vector(11 downto 0);
  signal DATA_OUT2_CH2           :  std_logic_vector(11 downto 0);
  signal DATA_READY1_CH2         :  std_logic;
  signal DATA_READY2_CH2         :  std_logic;
  signal READOUT_BUSY1_CH2       :  std_logic;
  signal READOUT_BUSY2_CH2       :  std_logic;
  signal ML1                     :  std_logic;
  signal ML2                     :  std_logic;
  signal MASTER                  :  std_logic;
  signal COINC_TO_END_TIME_FIFO1 :  std_logic;
  signal COINC_TO_END_TIME_FIFO2 :  std_logic;
  signal FAKE_DATA               :  std_logic;
  signal OUTP                    :  std_logic;
  signal locked0                 :  std_logic;
  signal FAKE_DATA_POS0          :  std_logic_vector(11 downto 0);
  signal FAKE_DATA_NEG0          :  std_logic_vector(11 downto 0);
  signal TS_ONE_PPS_VALID_OUT    :  std_logic;
  signal ONE_PPS_OUT             :  std_logic;
  signal GPS_FLAGS               :  std_logic_vector(7 downto 0);

  component PLL
    port(
      CLK200MHz : out    std_logic;
      inclk0    : in     std_logic;
      locked    : out    std_logic);
  end component PLL;

  component SYNCHRONISATION
    port(
      CLK200MHz     : in     std_logic;
      DATA_NEG_ADC  : in     std_logic_vector(11 downto 0);
      DATA_POS_ADC  : in     std_logic_vector(11 downto 0);
      DCO_NEG_ADC   : in     std_logic;
      DCO_POS_ADC   : in     std_logic;
      DOUT_NEG      : out    std_logic_vector(11 downto 0);
      DOUT_POS      : out    std_logic_vector(11 downto 0);
      FAKE_DATA     : in     std_logic;
      FAKE_DATA_NEG : in     std_logic_vector(11 downto 0);
      FAKE_DATA_POS : in     std_logic_vector(11 downto 0);
      LOCKED        : in     std_logic;
      SYSRST        : in     std_logic);
  end component SYNCHRONISATION;

  component TRIGGER_STUFF
    port(
      BLOCK_COINC     : in     std_logic;
      CLK10MHz        : in     std_logic;
      CLK200MHz       : in     std_logic;
      COINC           : out    std_logic;
      COINC_TIME      : in     integer range 1000 downto 0;
      COMPH1          : in     std_logic;
      COMPH2          : in     std_logic;
      COMPL1          : in     std_logic;
      COMPL2          : in     std_logic;
      DATA_ADC1_NEG   : in     std_logic_vector(11 downto 0);
      DATA_ADC1_POS   : in     std_logic_vector(11 downto 0);
      DATA_ADC2_NEG   : in     std_logic_vector(11 downto 0);
      DATA_ADC2_POS   : in     std_logic_vector(11 downto 0);
      EXT_TR_IN       : in     std_logic;
      GPS_DATA_MASTER : in     std_logic;
      GPS_DATA_OUT    : out    std_logic;
      LVDS_IN1        : in     std_logic;
      LVDS_IN2        : in     std_logic;
      LVDS_IN3        : in     std_logic;
      LVDS_IN4        : in     std_logic;
      LVDS_OUT1       : out    std_logic;
      LVDS_OUT2       : out    std_logic;
      LVDS_OUT3       : out    std_logic;
      LVDS_OUT4       : out    std_logic;
      MASTER          : in     std_logic;
      ML1             : out    std_logic;
      ML2             : out    std_logic;
      ONE_PPS_MASTER  : in     std_logic;
      ONE_PPS_OUT     : out    std_logic;
      POST_TIME       : in     integer range 1600 downto 0;
      SLAVE_PRESENT   : out    std_logic;
      STARTUP_BLOCK   : out    std_logic;
      SYSRST          : in     std_logic;
      THH1            : in     std_logic_vector(11 downto 0);
      THH2            : in     std_logic_vector(11 downto 0);
      THL1            : in     std_logic_vector(11 downto 0);
      THL2            : in     std_logic_vector(11 downto 0);
      TH_COUNTERS_OUT : out    std_logic_vector(63 downto 0);
      TRIGGER_PATTERN : out    std_logic_vector(15 downto 0);
      TR_CONDITION    : in     std_logic_vector(7 downto 0));
  end component TRIGGER_STUFF;

  component CLK_DIV
    port(
      CLK10MHz : in     std_logic;
      CLKRD    : out    std_logic;
      nSYSRST  : in     std_logic);
  end component CLK_DIV;

  component DATA_CONTROLLER
    port(
      ADC_A0                  : out    std_logic;
      ADC_A1                  : out    std_logic;
      ADC_DATA                : in     std_logic_vector(7 downto 0);
      ADC_MODE                : out    std_logic;
      ADC_nCS                 : out    std_logic;
      ADC_nINT                : in     std_logic;
      ADC_nRD                 : out    std_logic;
      ADC_nWR_RDY             : in     std_logic;
      ALTITUDE                : in     std_logic_vector(63 downto 0);
      CLK10MHz                : in     std_logic;
      CLKRD                   : in     std_logic;
      COINC_TIME              : out    integer range 1000 downto 0;
      COMPDATA                : in     std_logic_vector(127 downto 0);
      COMPDATA_READOUT_DONE   : out    std_logic;
      COMPDATA_VALID          : in     std_logic;
      CTD_IN                  : in     std_logic_vector(31 downto 0);
      CTD_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
      CTP_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
      DAC_A0                  : out    std_logic;
      DAC_A1                  : out    std_logic;
      DAC_A2                  : out    std_logic;
      DAC_DATA_0              : out    std_logic;
      DAC_DATA_1              : out    std_logic;
      DAC_DATA_2              : out    std_logic;
      DAC_DATA_3              : out    std_logic;
      DAC_DATA_4              : out    std_logic;
      DAC_DATA_5              : out    std_logic;
      DAC_DATA_6              : out    std_logic;
      DAC_DATA_7              : out    std_logic;
      DAC_nCLR                : out    std_logic;
      DAC_nCS_GAIN            : out    std_logic;
      DAC_nCS_OFFSET          : out    std_logic;
      DAC_nLDAC               : out    std_logic;
      DAC_nRD                 : out    std_logic;
      DAC_nWR                 : out    std_logic;
      DATA_IN                 : in     std_logic_vector(7 downto 0);
      DATA_READY_FIFO         : in     std_logic;
      DIN_VALID               : in     std_logic;
      ERROR_READ_OUT          : out    std_logic;
      FAKE_DATA               : out    std_logic;
      FORCE_MASTER            : out    std_logic;
      GPS_FLAGS               : in     std_logic_vector(7 downto 0);
      GPS_PROG_ENABLE         : out    std_logic;
      GPS_TS_IN               : in     std_logic_vector(55 downto 0);
      GPS_TS_ONE_PPS          : in     std_logic_vector(55 downto 0);
      LATITUDE                : in     std_logic_vector(63 downto 0);
      LONGITUDE               : in     std_logic_vector(63 downto 0);
      MASTER                  : in     std_logic;
      NEW_DATA_WHILE_READOUT  : out    std_logic;
      ONE_PPS                 : in     std_logic;
      POST_TIME               : out    integer range 1600 downto 0;
      RDEN                    : out    std_logic;
      READ_BUSY_OUT           : out    std_logic;
      SAT_INFO                : in     std_logic_vector(487 downto 0);
      SERIAL_NUMBER           : in     std_logic_vector(9 downto 0);
      SLAVE_PRESENT           : in     std_logic;
      SOFT_RESET              : out    std_logic;
      STOP_READ_OUT           : out    std_logic;
      SYSRST                  : in     std_logic;
      TEMP                    : in     std_logic_vector(31 downto 0);
      THH1                    : out    std_logic_vector(11 downto 0);
      THH2                    : out    std_logic_vector(11 downto 0);
      THL1                    : out    std_logic_vector(11 downto 0);
      THL2                    : out    std_logic_vector(11 downto 0);
      TH_COUNTERS_IN          : in     std_logic_vector(63 downto 0);
      TIME_OUT_RESET          : out    std_logic;
      TOTAL_TIME              : out    integer range 2000 downto 0;
      TOTAL_TIME_3X           : out    integer range 6000 downto 0;
      TRIGGER_PATTERN         : in     std_logic_vector(15 downto 0);
      TR_CONDITION            : out    std_logic_vector(7 downto 0);
      TS_ONE_PPS_READOUT_DONE : out    std_logic;
      TS_ONE_PPS_VALID_IN     : in     std_logic;
      USB_DATA                : inout  std_logic_vector(7 downto 0);
      USB_RD                  : out    std_logic;
      USB_RXF                 : in     std_logic;
      USB_TXE                 : in     std_logic;
      USB_WR                  : out    std_logic;
      USB_WRITE_ENABLE        : out    std_logic;
      nSYSRST                 : in     std_logic);
  end component DATA_CONTROLLER;

  component GPS_STUFF
    port(
      ALTITUDE_OUT            : out    std_logic_vector(63 downto 0);
      CLK10MHz                : in     std_logic;
      CLK200MHz               : in     std_logic;
      COINC                   : in     std_logic;
      COMPDATA_OUT            : out    std_logic_vector(127 downto 0);
      COMPDATA_READOUT_DONE   : in     std_logic;
      COMPDATA_VALID_OUT      : out    std_logic;
      COMPH1_IN               : in     std_logic;
      COMPH2_IN               : in     std_logic;
      COMPL1_IN               : in     std_logic;
      COMPL2_IN               : in     std_logic;
      CTD_OUT                 : out    std_logic_vector(31 downto 0);
      CTD_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
      CTP_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
      GPS_FLAGS               : out    std_logic_vector(7 downto 0);
      GPS_PROG_ENABLE         : in     std_logic;
      GPS_SDI                 : out    std_logic;
      GPS_SDO                 : in     std_logic;
      GPS_TS_ONE_PPS_OUT      : out    std_logic_vector(55 downto 0);
      GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
      LATITUDE_OUT            : out    std_logic_vector(63 downto 0);
      LONGITUDE_OUT           : out    std_logic_vector(63 downto 0);
      MASTER                  : out    std_logic;
      ONE_PPS                 : in     std_logic;
      RXD                     : in     std_logic;
      SAT_INFO_OUT            : out    std_logic_vector(487 downto 0);
      SPY_CON                 : in     std_logic;
      SPY_SDI                 : out    std_logic;
      SPY_SDO                 : in     std_logic;
      STARTUP_BLOCK           : in     std_logic;
      SYSRST                  : in     std_logic;
      TEMP_OUT                : out    std_logic_vector(31 downto 0);
      TS_ONE_PPS_READOUT_DONE : in     std_logic;
      TS_ONE_PPS_VALID_OUT    : out    std_logic);
  end component GPS_STUFF;

  component DUMMIES
    port(
      INTF1_IO   : out    std_logic_vector(2 downto 0);
      INTF2_IO   : in     std_logic_vector(7 downto 0);
      LED4       : out    std_logic;
      LED5       : out    std_logic;
      LED6       : out    std_logic;
      LED7       : out    std_logic;
      USB_nPWREN : in     std_logic);
  end component DUMMIES;

  component SOFT_RESET
    port(
      CLKRD   : in     std_logic;
      RESOUT  : out    std_logic;
      SRESET  : in     std_logic;
      TORESET : in     std_logic;
      nHRESET : in     std_logic);
  end component SOFT_RESET;

  component STORAGE_CHANNELS
    port(
      CLK200MHz               : in     std_logic;
      CLKRD                   : in     std_logic;
      COINC_TO_END_TIME_FIFO1 : in     std_logic;
      COINC_TO_END_TIME_FIFO2 : in     std_logic;
      DATA_ADC_NEG_CH1        : in     std_logic_vector(11 downto 0);
      DATA_ADC_NEG_CH2        : in     std_logic_vector(11 downto 0);
      DATA_ADC_POS_CH1        : in     std_logic_vector(11 downto 0);
      DATA_ADC_POS_CH2        : in     std_logic_vector(11 downto 0);
      DATA_OUT1_CH1           : out    std_logic_vector(11 downto 0);
      DATA_OUT1_CH2           : out    std_logic_vector(11 downto 0);
      DATA_OUT2_CH1           : out    std_logic_vector(11 downto 0);
      DATA_OUT2_CH2           : out    std_logic_vector(11 downto 0);
      DATA_READY1_CH1         : out    std_logic;
      DATA_READY1_CH2         : out    std_logic;
      DATA_READY2_CH1         : out    std_logic;
      DATA_READY2_CH2         : out    std_logic;
      MASTER                  : in     std_logic;
      RDEN1_CH1               : in     std_logic;
      RDEN1_CH2               : in     std_logic;
      RDEN2_CH1               : in     std_logic;
      RDEN2_CH2               : in     std_logic;
      READOUT_BUSY1_CH1       : out    std_logic;
      READOUT_BUSY1_CH2       : out    std_logic;
      READOUT_BUSY2_CH1       : out    std_logic;
      READOUT_BUSY2_CH2       : out    std_logic;
      SYSRST                  : in     std_logic;
      TOTAL_TIME              : in     integer range 2000 downto 0;
      WE                      : out    std_logic);
  end component STORAGE_CHANNELS;

  component LEDS
    port(
      BLOCK_COINC   : in     std_logic;
      CLK10MHz      : in     std_logic;
      COINC         : in     std_logic;
      COINC_LED     : out    std_logic;
      HIT1          : in     std_logic;
      HIT2          : in     std_logic;
      LED0          : out    std_logic;
      LED1          : out    std_logic;
      LED2          : out    std_logic;
      LED3          : out    std_logic;
      LED4          : out    std_logic;
      LEDH1         : out    std_logic;
      LEDH2         : out    std_logic;
      MASTER        : in     std_logic;
      ONE_PPS       : in     std_logic;
      SLAVE_PRESENT : in     std_logic;
      STARTUP       : in     std_logic;
      SYSRST        : in     std_logic;
      USB_RD        : in     std_logic);
  end component LEDS;

  component DataMux
    port(
      BLOCK_COINC             : out    std_logic;
      CLK10MHz                : in     std_logic;
      CLK200MHz               : in     std_logic;
      CLKRD                   : in     std_logic;
      COINC_TO_END_TIME       : in     std_logic;
      COINC_TO_END_TIME_FIFO1 : out    std_logic;
      COINC_TO_END_TIME_FIFO2 : out    std_logic;
      CTD_IN                  : in     std_logic_vector(31 downto 0);
      CTD_OUT                 : out    std_logic_vector(31 downto 0);
      DATA_OUT                : out    std_logic_vector(7 downto 0);
      DATA_OUT1_CH1           : in     std_logic_vector(11 downto 0);
      DATA_OUT1_CH2           : in     std_logic_vector(11 downto 0);
      DATA_OUT2_CH1           : in     std_logic_vector(11 downto 0);
      DATA_OUT2_CH2           : in     std_logic_vector(11 downto 0);
      DATA_READY1_CH1         : in     std_logic;
      DATA_READY1_CH2         : in     std_logic;
      DATA_READY2_CH1         : in     std_logic;
      DATA_READY2_CH2         : in     std_logic;
      DOUT_VALID              : out    std_logic;
      EVENT_DATA_READY        : out    std_logic;
      GPS_TS_IN               : in     std_logic_vector(55 downto 0);
      GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
      RDEN                    : in     std_logic;
      RDEN1_CH1               : out    std_logic;
      RDEN1_CH2               : out    std_logic;
      RDEN2_CH1               : out    std_logic;
      RDEN2_CH2               : out    std_logic;
      READOUT_BUSY1_CH1       : in     std_logic;
      READOUT_BUSY1_CH2       : in     std_logic;
      READOUT_BUSY2_CH1       : in     std_logic;
      READOUT_BUSY2_CH2       : in     std_logic;
      SYSRST                  : in     std_logic;
      TOTAL_TIME_3X           : in     integer range 6000 downto 0;
      TRIGGER_PATTERN         : out    std_logic_vector(15 downto 0);
      TRIGGER_PATTERN_IN      : in     std_logic_vector(15 downto 0));
  end component DataMux;

  component PLL_DIV
    port(
      CLK10MHz : out    std_logic;
      CLK20MHz : out    std_logic;
      CLK40MHz : out    std_logic;
      inclk0   : in     std_logic;
      locked   : out    std_logic);
  end component PLL_DIV;

  component INVERTER
    port(
      INP  : in     std_logic;
      OUTP : out    std_logic);
  end component INVERTER;

  component FAKE_DATA_GEN
    port(
      CLK200MHz     : in     std_logic;
      FAKE_DATA_NEG : out    std_logic_vector(11 downto 0);
      FAKE_DATA_POS : out    std_logic_vector(11 downto 0);
      SYSRST        : in     std_logic);
  end component FAKE_DATA_GEN;

begin
  UTXE <= USB_TXE;
  URXF <= USB_RXF;
  USB_WR <= UWR;
  USB_RD <= URD;
  u4: PLL
    port map(
      CLK200MHz => CLK200MHz,
      inclk0    => CLK200MHz_LVDS,
      locked    => locked0);

  u5: SYNCHRONISATION
    port map(
      CLK200MHz     => CLK200MHz,
      DATA_NEG_ADC  => DATA_NEG_ADC_CH1,
      DATA_POS_ADC  => DATA_POS_ADC_CH1,
      DCO_NEG_ADC   => DCO_NEG_ADC_CH1,
      DCO_POS_ADC   => DCO_POS_ADC_CH1,
      DOUT_NEG      => DOUT_NEG0,
      DOUT_POS      => DOUT_POS0,
      FAKE_DATA     => FAKE_DATA,
      FAKE_DATA_NEG => FAKE_DATA_NEG0,
      FAKE_DATA_POS => FAKE_DATA_POS0,
      LOCKED        => locked0,
      SYSRST        => SYSRST);

  u9: SYNCHRONISATION
    port map(
      CLK200MHz     => CLK200MHz,
      DATA_NEG_ADC  => DATA_NEG_ADC_CH2,
      DATA_POS_ADC  => DATA_POS_ADC_CH2,
      DCO_NEG_ADC   => DCO_NEG_ADC_CH2,
      DCO_POS_ADC   => DCO_POS_ADC_CH2,
      DOUT_NEG      => DOUT_NEG,
      DOUT_POS      => DOUT_POS,
      FAKE_DATA     => FAKE_DATA,
      FAKE_DATA_NEG => FAKE_DATA_NEG0,
      FAKE_DATA_POS => FAKE_DATA_POS0,
      LOCKED        => locked0,
      SYSRST        => SYSRST);

  u12: TRIGGER_STUFF
    port map(
      BLOCK_COINC     => BLOCK_COINC0,
      CLK10MHz        => CLK10MHz,
      CLK200MHz       => CLK200MHz,
      COINC           => COINC,
      COINC_TIME      => COINC_TIME,
      COMPH1          => COMPH1,
      COMPH2          => COMPH2,
      COMPL1          => COMPL1,
      COMPL2          => COMPL2,
      DATA_ADC1_NEG   => DOUT_NEG0,
      DATA_ADC1_POS   => DOUT_POS0,
      DATA_ADC2_NEG   => DOUT_NEG,
      DATA_ADC2_POS   => DOUT_POS,
      EXT_TR_IN       => OUTP,
      GPS_DATA_MASTER => GPS_TXD,
      GPS_DATA_OUT    => GPS_DATA_OUT0,
      LVDS_IN1        => LVDS_IN1,
      LVDS_IN2        => LVDS_IN2,
      LVDS_IN3        => LVDS_IN3,
      LVDS_IN4        => LVDS_IN4,
      LVDS_OUT1       => LVDS_OUT1,
      LVDS_OUT2       => LVDS_OUT2,
      LVDS_OUT3       => LVDS_OUT3,
      LVDS_OUT4       => LVDS_OUT4,
      MASTER          => FORCE_MASTER0,
      ML1             => ML1,
      ML2             => ML2,
      ONE_PPS_MASTER  => GPS_1PPS,
      ONE_PPS_OUT     => ONE_PPS_OUT,
      POST_TIME       => POST_TIME,
      SLAVE_PRESENT   => SLAVE_PRESENT0,
      STARTUP_BLOCK   => STARTUP_BLOCK,
      SYSRST          => SYSRST,
      THH1            => THH1,
      THH2            => THH2,
      THL1            => THL1,
      THL2            => THL2,
      TH_COUNTERS_OUT => TH_COUNTERS_OUT0,
      TRIGGER_PATTERN => TRIGGER_PATTERN1,
      TR_CONDITION    => TR_CONDITION);

  u15: CLK_DIV
    port map(
      CLK10MHz => CLK10MHz,
      CLKRD    => CLKRD,
      nSYSRST  => nSYSRST);

  u11: DATA_CONTROLLER
    port map(
      ADC_A0                  => ADC_A0,
      ADC_A1                  => ADC_A1,
      ADC_DATA                => ADC_DATA,
      ADC_MODE                => ADC_MODE,
      ADC_nCS                 => ADC_nCS,
      ADC_nINT                => ADC_nINT,
      ADC_nRD                 => ADC_nRD,
      ADC_nWR_RDY             => ADC_nWR_RDY,
      ALTITUDE                => ALTITUDE_OUT,
      CLK10MHz                => CLK10MHz,
      CLKRD                   => CLKRD,
      COINC_TIME              => COINC_TIME,
      COMPDATA                => COMPDATA_OUT,
      COMPDATA_READOUT_DONE   => COMPDATA_READOUT_DONE,
      COMPDATA_VALID          => COMPDATA_VALID_OUT0,
      CTD_IN                  => CTD_OUT,
      CTD_TS_ONE_PPS          => CTD_TS_ONE_PPS_OUT,
      CTP_TS_ONE_PPS          => CTP_TS_ONE_PPS_OUT,
      DAC_A0                  => DAC_A0,
      DAC_A1                  => DAC_A1,
      DAC_A2                  => DAC_A2,
      DAC_DATA_0              => DAC_DATA_0,
      DAC_DATA_1              => DAC_DATA_1,
      DAC_DATA_2              => DAC_DATA_2,
      DAC_DATA_3              => DAC_DATA_3,
      DAC_DATA_4              => DAC_DATA_4,
      DAC_DATA_5              => DAC_DATA_5,
      DAC_DATA_6              => DAC_DATA_6,
      DAC_DATA_7              => DAC_DATA_7,
      DAC_nCLR                => DAC_nCLR,
      DAC_nCS_GAIN            => DAC_nCS_GAIN,
      DAC_nCS_OFFSET          => DAC_nCS_OFFSET,
      DAC_nLDAC               => DAC_nLDAC,
      DAC_nRD                 => DAC_nRD,
      DAC_nWR                 => DAC_nWR,
      DATA_IN                 => DATA_OUT,
      DATA_READY_FIFO         => EVENT_DATA_READY,
      DIN_VALID               => DOUT_VALID,
      ERROR_READ_OUT          => open,
      FAKE_DATA               => FAKE_DATA,
      FORCE_MASTER            => FORCE_MASTER0,
      GPS_FLAGS               => GPS_FLAGS,
      GPS_PROG_ENABLE         => GPS_PROG_ENABLE0,
      GPS_TS_IN               => GPS_TS_OUT,
      GPS_TS_ONE_PPS          => GPS_TS_ONE_PPS_OUT,
      LATITUDE                => LATITUDE_OUT,
      LONGITUDE               => LONGITUDE_OUT,
      MASTER                  => MASTER,
      NEW_DATA_WHILE_READOUT  => open,
      ONE_PPS                 => ONE_PPS_OUT,
      POST_TIME               => POST_TIME,
      RDEN                    => RDEN,
      READ_BUSY_OUT           => open,
      SAT_INFO                => SAT_INFO_OUT,
      SERIAL_NUMBER           => SERIAL_NUMBER,
      SLAVE_PRESENT           => SLAVE_PRESENT0,
      SOFT_RESET              => SOFT_RESET0,
      STOP_READ_OUT           => open,
      SYSRST                  => SYSRST,
      TEMP                    => TEMP_OUT,
      THH1                    => THH1,
      THH2                    => THH2,
      THL1                    => THL1,
      THL2                    => THL2,
      TH_COUNTERS_IN          => TH_COUNTERS_OUT0,
      TIME_OUT_RESET          => TIME_OUT_RESET,
      TOTAL_TIME              => TOTAL_TIME,
      TOTAL_TIME_3X           => TOTAL_TIME_3X,
      TRIGGER_PATTERN         => TRIGGER_PATTERN0,
      TR_CONDITION            => TR_CONDITION,
      TS_ONE_PPS_READOUT_DONE => TS_ONE_PPS_READOUT_DONE,
      TS_ONE_PPS_VALID_IN     => TS_ONE_PPS_VALID_OUT,
      USB_DATA                => USB_DATA,
      USB_RD                  => URD,
      USB_RXF                 => URXF,
      USB_TXE                 => UTXE,
      USB_WR                  => UWR,
      USB_WRITE_ENABLE        => open,
      nSYSRST                 => nSYSRST);

  u14: GPS_STUFF
    port map(
      ALTITUDE_OUT            => ALTITUDE_OUT,
      CLK10MHz                => CLK10MHz,
      CLK200MHz               => CLK200MHz,
      COINC                   => COINC,
      COMPDATA_OUT            => COMPDATA_OUT,
      COMPDATA_READOUT_DONE   => COMPDATA_READOUT_DONE,
      COMPDATA_VALID_OUT      => COMPDATA_VALID_OUT0,
      COMPH1_IN               => COMPH1,
      COMPH2_IN               => COMPH2,
      COMPL1_IN               => COMPL1,
      COMPL2_IN               => COMPL2,
      CTD_OUT                 => CTD_OUT0,
      CTD_TS_ONE_PPS_OUT      => CTD_TS_ONE_PPS_OUT,
      CTP_TS_ONE_PPS_OUT      => CTP_TS_ONE_PPS_OUT,
      GPS_FLAGS               => GPS_FLAGS,
      GPS_PROG_ENABLE         => GPS_PROG_ENABLE0,
      GPS_SDI                 => GPS_RXD,
      GPS_SDO                 => GPS_TXD,
      GPS_TS_ONE_PPS_OUT      => GPS_TS_ONE_PPS_OUT,
      GPS_TS_OUT              => GPS_TS_OUT0,
      LATITUDE_OUT            => LATITUDE_OUT,
      LONGITUDE_OUT           => LONGITUDE_OUT,
      MASTER                  => MASTER,
      ONE_PPS                 => ONE_PPS_OUT,
      RXD                     => GPS_DATA_OUT0,
      SAT_INFO_OUT            => SAT_INFO_OUT,
      SPY_CON                 => FT232_CON,
      SPY_SDI                 => FT232_RXD,
      SPY_SDO                 => FT232_TXD,
      STARTUP_BLOCK           => STARTUP_BLOCK,
      SYSRST                  => SYSRST,
      TEMP_OUT                => TEMP_OUT,
      TS_ONE_PPS_READOUT_DONE => TS_ONE_PPS_READOUT_DONE,
      TS_ONE_PPS_VALID_OUT    => TS_ONE_PPS_VALID_OUT);

  u20: DUMMIES
    port map(
      INTF1_IO   => INTF1_IO,
      INTF2_IO   => INTF2_IO,
      LED4       => open,
      LED5       => LED5,
      LED6       => LED6,
      LED7       => LED7,
      USB_nPWREN => USB_nPWREN);

  u16: SOFT_RESET
    port map(
      CLKRD   => CLKRD,
      RESOUT  => SYSRST,
      SRESET  => SOFT_RESET0,
      TORESET => TIME_OUT_RESET,
      nHRESET => nSYSRST);

  u2: STORAGE_CHANNELS
    port map(
      CLK200MHz               => CLK200MHz,
      CLKRD                   => CLKRD,
      COINC_TO_END_TIME_FIFO1 => COINC_TO_END_TIME_FIFO1,
      COINC_TO_END_TIME_FIFO2 => COINC_TO_END_TIME_FIFO2,
      DATA_ADC_NEG_CH1        => DOUT_NEG0,
      DATA_ADC_NEG_CH2        => DOUT_NEG,
      DATA_ADC_POS_CH1        => DOUT_POS0,
      DATA_ADC_POS_CH2        => DOUT_POS,
      DATA_OUT1_CH1           => DATA_OUT1_CH1,
      DATA_OUT1_CH2           => DATA_OUT1_CH2,
      DATA_OUT2_CH1           => DATA_OUT2_CH1,
      DATA_OUT2_CH2           => DATA_OUT2_CH2,
      DATA_READY1_CH1         => DATA_READY1_CH1,
      DATA_READY1_CH2         => DATA_READY1_CH2,
      DATA_READY2_CH1         => DATA_READY2_CH1,
      DATA_READY2_CH2         => DATA_READY2_CH2,
      MASTER                  => FORCE_MASTER0,
      RDEN1_CH1               => RDEN1_CH1,
      RDEN1_CH2               => RDEN1_CH2,
      RDEN2_CH1               => RDEN2_CH1,
      RDEN2_CH2               => RDEN2_CH2,
      READOUT_BUSY1_CH1       => READOUT_BUSY1_CH1,
      READOUT_BUSY1_CH2       => READOUT_BUSY1_CH2,
      READOUT_BUSY2_CH1       => READOUT_BUSY2_CH1,
      READOUT_BUSY2_CH2       => READOUT_BUSY2_CH2,
      SYSRST                  => SYSRST,
      TOTAL_TIME              => TOTAL_TIME,
      WE                      => open);

  u3: LEDS
    port map(
      BLOCK_COINC   => BLOCK_COINC0,
      CLK10MHz      => CLK10MHz,
      COINC         => COINC,
      COINC_LED     => COINC_LED,
      HIT1          => ML1,
      HIT2          => ML2,
      LED0          => LED0,
      LED1          => LED1,
      LED2          => LED2,
      LED3          => LED3,
      LED4          => LED4,
      LEDH1         => HITLED_CH1,
      LEDH2         => HITLED_CH2,
      MASTER        => FORCE_MASTER0,
      ONE_PPS       => ONE_PPS_OUT,
      SLAVE_PRESENT => SLAVE_PRESENT0,
      STARTUP       => STARTUP_BLOCK,
      SYSRST        => SYSRST,
      USB_RD        => URD);

  u22: DataMux
    port map(
      BLOCK_COINC             => BLOCK_COINC0,
      CLK10MHz                => CLK10MHz,
      CLK200MHz               => CLK200MHz,
      CLKRD                   => CLKRD,
      COINC_TO_END_TIME       => COINC,
      COINC_TO_END_TIME_FIFO1 => COINC_TO_END_TIME_FIFO1,
      COINC_TO_END_TIME_FIFO2 => COINC_TO_END_TIME_FIFO2,
      CTD_IN                  => CTD_OUT0,
      CTD_OUT                 => CTD_OUT,
      DATA_OUT                => DATA_OUT,
      DATA_OUT1_CH1           => DATA_OUT1_CH1,
      DATA_OUT1_CH2           => DATA_OUT1_CH2,
      DATA_OUT2_CH1           => DATA_OUT2_CH1,
      DATA_OUT2_CH2           => DATA_OUT2_CH2,
      DATA_READY1_CH1         => DATA_READY1_CH1,
      DATA_READY1_CH2         => DATA_READY1_CH2,
      DATA_READY2_CH1         => DATA_READY2_CH1,
      DATA_READY2_CH2         => DATA_READY2_CH2,
      DOUT_VALID              => DOUT_VALID,
      EVENT_DATA_READY        => EVENT_DATA_READY,
      GPS_TS_IN               => GPS_TS_OUT0,
      GPS_TS_OUT              => GPS_TS_OUT,
      RDEN                    => RDEN,
      RDEN1_CH1               => RDEN1_CH1,
      RDEN1_CH2               => RDEN1_CH2,
      RDEN2_CH1               => RDEN2_CH1,
      RDEN2_CH2               => RDEN2_CH2,
      READOUT_BUSY1_CH1       => READOUT_BUSY1_CH1,
      READOUT_BUSY1_CH2       => READOUT_BUSY1_CH2,
      READOUT_BUSY2_CH1       => READOUT_BUSY2_CH1,
      READOUT_BUSY2_CH2       => READOUT_BUSY2_CH2,
      SYSRST                  => SYSRST,
      TOTAL_TIME_3X           => TOTAL_TIME_3X,
      TRIGGER_PATTERN         => TRIGGER_PATTERN0,
      TRIGGER_PATTERN_IN      => TRIGGER_PATTERN1);

  u0: PLL_DIV
    port map(
      CLK10MHz => CLK10MHz,
      CLK20MHz => open,
      CLK40MHz => open,
      inclk0   => CLK40MHz_CMOS,
      locked   => open);

  u23: INVERTER
    port map(
      INP  => EXT_TR_IN_n,
      OUTP => OUTP);

  u1: FAKE_DATA_GEN
    port map(
      CLK200MHz     => CLK200MHz,
      FAKE_DATA_NEG => FAKE_DATA_NEG0,
      FAKE_DATA_POS => FAKE_DATA_POS0,
      SYSRST        => SYSRST);

end architecture a0 ; -- of FPGA

