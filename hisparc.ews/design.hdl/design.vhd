--------------------------------------------------------------------------------
-- This VHDL file is generated by EASE/HDL from HDL Works B.V.,
-- the 'Graphical Systems Design Tool'.
--
-- Ease 5.2 Revision 13.
-- Design library : design.
-- Host name      : ricinus.
-- User name      : hansvk.
-- Time stamp     : Wed Aug 29 15:06:39 2007.
--
-- Designed by    : 
-- Company        : Translogic.
-- Design info    : 
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Entity declaration of 'WINDOW_MAKER'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity WINDOW_MAKER is
  port(
    CLK200MHz         : in     std_logic;
    COINC_TO_END_TIME : out    std_logic;
    END_OF_COINC      : in     std_logic;
    POST_TIME         : in     integer range 1600 downto 0;
    SYSRST            : in     std_logic);
end WINDOW_MAKER ;

--------------------------------------------------------------------------------
-- Architecture 'a0' of 'WINDOW_MAKER'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture a0 of WINDOW_MAKER is

signal COINC_DEL1: std_logic ; -- COINC after one clockcycle  
signal COINC_TO_END_TIME_TMP: std_logic ; -- Time from negative edge of COINC to end of POST_TIME  
signal COINC_TO_END_TIME_CNT: integer range 1600 downto 0 ; -- Counter from COINC to end of POST_TIME

begin
  
  COINC_TO_END_TIME <= COINC_TO_END_TIME_TMP;
  
  -- COINC delay
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_DEL1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COINC_DEL1 <= END_OF_COINC;
    end if;
  end process;  

  -- COINC_TO_END_TIME_TMP starts at a negative edge of COINC and stops when COINC_TO_END_TIME_CNT reaches POST_TIME
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_TMP <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if END_OF_COINC = '1' and COINC_DEL1 = '0' then -- on a positive edge of END_OF_COINC
        COINC_TO_END_TIME_TMP <= '1'; 
      elsif COINC_TO_END_TIME_CNT > POST_TIME then
        COINC_TO_END_TIME_TMP <= '0';
      end if;
    end if;
  end process;  

  -- COINC_TO_END_TIME_CNT starts when COINC_TO_END_TIME_TMP = '1'
  -- and counts as long COINC_TO_END_TIME_TMP is valid 
  -- and resets when COINC_TO_END_TIME_TMP = '0'
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME_TMP = '1' then 
        COINC_TO_END_TIME_CNT <= COINC_TO_END_TIME_CNT + 1;
      else
        COINC_TO_END_TIME_CNT <= 0;
      end if;
    end if;
  end process;  
 
end a0 ; -- of WINDOW_MAKER

--------------------------------------------------------------------------------
-- Entity declaration of 'DUAL_PORT_RAM'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity DUAL_PORT_RAM is
  port(
    DATA_IN    : in     std_logic_vector(11 downto 0);
    DATA_OUT   : out    std_logic_vector(11 downto 0);
    RDCLOCK    : in     std_logic;
    RD_ADDRESS : in     integer range 2020 downto 0;
    WE         : in     std_logic;
    WRCLOCK    : in     std_logic;
    WR_ADDRESS : in     integer range 2020 downto 0);
end DUAL_PORT_RAM ;

--------------------------------------------------------------------------------
-- Architecture 'a0' of 'DUAL_PORT_RAM'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture a0 of DUAL_PORT_RAM is

	type MEM is array(0 to 2020) of std_logic_vector(11 downto 0);
	signal RAM_BLOCK : MEM;
	signal RD_ADDRESS_REG : integer range 0 to 2020;

begin
	process (WRCLOCK)
	begin
		if (WRCLOCK'event and WRCLOCK = '1') then
			if (WE = '1') then
				RAM_BLOCK(WR_ADDRESS) <= DATA_IN;
			end if;

		end if;
	end process;

	process (RDCLOCK)
	BEGIN
		if (RDCLOCK'event and RDCLOCK = '1') then
			DATA_OUT <= RAM_BLOCK(RD_ADDRESS_REG);
			RD_ADDRESS_REG <= RD_ADDRESS;
		end if;
	end process;

end a0 ; -- of DUAL_PORT_RAM

--------------------------------------------------------------------------------
-- Entity declaration of 'ADDRESS_COUNTERS'.
-- Last modified : Fri May 04 10:12:29 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity ADDRESS_COUNTERS is
  port(
    CLK200MHz         : in     std_logic;
    CLKRD             : in     std_logic;
    COINC_TO_END_TIME : in     std_logic;
    DATA_OUT          : out    std_logic_vector(11 downto 0);
    DATA_OUT_NEG      : in     std_logic_vector(11 downto 0);
    DATA_OUT_POS      : in     std_logic_vector(11 downto 0);
    DATA_READY        : out    std_logic;
    RDEN              : in     std_logic;
    RD_ADDRESS        : out    integer range 2020 downto 0;
    READOUT_BUSY      : out    std_logic;
    SYSRST            : in     std_logic;
    TOTAL_TIME        : in     integer range 2000 downto 0;
    WE                : out    std_logic;
    WR_ADDRESS        : out    integer range 2020 downto 0);
end ADDRESS_COUNTERS ;

--------------------------------------------------------------------------------
-- Architecture 'a0' of 'ADDRESS_COUNTERS'
-- Last modified : Fri May 04 10:12:29 2007.
--------------------------------------------------------------------------------

architecture a0 of ADDRESS_COUNTERS is

signal TAKE_DATA: std_logic ; -- RAMs are in write mode when true
signal BEGIN_PRE_TIME: integer range 2020 downto 0 ; -- write address at begin of PRE_TIME 
signal END_POST_TIME: integer range 2020 downto 0 ; -- write address at end of POST_TIME 
signal WR_ADDRESS_TMP: integer range 2020 downto 0 ;  
signal RD_ADDRESS_TMP: integer range 2020 downto 0 ;  
signal POS_NEG_PHASE: std_logic ; -- help signal to determine the positive or negative RAM; high means positive
signal COINC_TO_END_TIME_DEL: std_logic ;
signal READOUT_BUSY_DEL1: std_logic ;
signal READOUT_BUSY_DEL2: std_logic ;
signal READOUT_BUSY_TMP: std_logic ;
signal DATA_READY_PRE: std_logic ;
signal DATA_READY_TMP: std_logic ;
signal DATA_OUT_TMP: std_logic_vector(11 downto 0);



begin
  -- Distract BEGIN_PRE_TIME with 10 (50ns) to adjust COINC with the stored event in the FIFO
  BEGIN_PRE_TIME <= END_POST_TIME - TOTAL_TIME - 10 when (END_POST_TIME >= TOTAL_TIME + 10) else (2010 - TOTAL_TIME + END_POST_TIME);
--  BEGIN_PRE_TIME <= END_POST_TIME - TOTAL_TIME when (END_POST_TIME >= TOTAL_TIME) else (2020 - TOTAL_TIME + END_POST_TIME);
  WR_ADDRESS <= WR_ADDRESS_TMP;
  RD_ADDRESS <= RD_ADDRESS_TMP;
  DATA_READY <= DATA_READY_TMP;
  
  
  -- delays
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_TO_END_TIME_DEL <= '0';
      READOUT_BUSY_DEL1 <= '0';
      READOUT_BUSY_DEL2 <= '0';
      WE <= '1';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COINC_TO_END_TIME_DEL <= COINC_TO_END_TIME;
      READOUT_BUSY_DEL1 <= READOUT_BUSY_TMP;
      READOUT_BUSY_DEL2 <= READOUT_BUSY_DEL1;
      WE <= TAKE_DATA;
    end if;
  end process;  
    
  -- Data taking TAKE_DATA stops at end of COINC_TO_END_TIME and starts again after the FIFO has been readout
  -- and determine END_POST_TIME
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TAKE_DATA <= '1';
      END_POST_TIME <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME = '0' and COINC_TO_END_TIME_DEL = '1' then -- on a negative edge of COINC_TO_END_TIME
        TAKE_DATA <= '0';
        END_POST_TIME <= WR_ADDRESS_TMP;
      elsif READOUT_BUSY_DEL1 = '0' and READOUT_BUSY_DEL2 = '1' then -- on a negative edge of READOUT_BUSY
        TAKE_DATA <= '1';
      end if;
    end if;
  end process;  

  -- WR_ADDRESS_TMP
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_ADDRESS_TMP <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if TAKE_DATA = '1' then
        if WR_ADDRESS_TMP = 2020 then
          WR_ADDRESS_TMP <= 0;
        else
          WR_ADDRESS_TMP <= WR_ADDRESS_TMP + 1;
        end if;
      else
        WR_ADDRESS_TMP <= WR_ADDRESS_TMP; 
      end if;  
    end if;
  end process;  

  -- DATA_READY is valid when the FIFOs are not taking data
  -- not TAKE_DATA is synchronized with the readoutclock
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_READY_TMP <= '0';
      DATA_READY_PRE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      DATA_READY_PRE <= not TAKE_DATA;
      DATA_READY_TMP <= DATA_READY_PRE;
      READOUT_BUSY <= READOUT_BUSY_TMP;
    end if;
  end process;  

  -- RD_ADDRESS and toggle outputbus
  process(CLKRD)
  begin
    if (CLKRD'event and CLKRD = '1') then
      if RDEN = '1' then
        if POS_NEG_PHASE = '1' then
          RD_ADDRESS_TMP <= RD_ADDRESS_TMP;
        else
          if RD_ADDRESS_TMP = 2020 then
            RD_ADDRESS_TMP <= 0;
          else
            RD_ADDRESS_TMP <= RD_ADDRESS_TMP + 1;
          end if;
        end if;
        POS_NEG_PHASE <= not POS_NEG_PHASE;
        READOUT_BUSY_TMP <= '1';          
      else
        RD_ADDRESS_TMP <= BEGIN_PRE_TIME;
        POS_NEG_PHASE <= '1'; 
        READOUT_BUSY_TMP <= '0';
      end if;  
    end if;
  end process;  
  
  DATA_OUT_TMP <= DATA_OUT_POS  when POS_NEG_PHASE = '1' else DATA_OUT_NEG;
  DATA_OUT <= DATA_OUT_TMP when READOUT_BUSY_TMP = '1' else "000000000000";

end a0 ; -- of ADDRESS_COUNTERS

--------------------------------------------------------------------------------
-- Entity declaration of 'PLL'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity PLL is
  port(
    CLK200MHz : out    std_logic;
    inclk0    : in     std_logic;
    locked    : out    std_logic);
end PLL ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'PLL'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
LIBRARY altera_mf;
USE altera_mf.altera_mf_components.all;

architecture rtl of PLL is

	SIGNAL sub_wire0	: STD_LOGIC_VECTOR (5 DOWNTO 0);
	SIGNAL sub_wire1	: STD_LOGIC ;
	SIGNAL sub_wire2	: STD_LOGIC ;
	SIGNAL sub_wire3	: STD_LOGIC ;
	SIGNAL sub_wire4	: STD_LOGIC_VECTOR (1 DOWNTO 0);
	SIGNAL sub_wire5_bv	: BIT_VECTOR (0 DOWNTO 0);
	SIGNAL sub_wire5	: STD_LOGIC_VECTOR (0 DOWNTO 0);

	COMPONENT altpll
	GENERIC (
		clk0_duty_cycle		: NATURAL;
		lpm_type		: STRING;
		clk0_multiply_by		: NATURAL;
		invalid_lock_multiplier		: NATURAL;
		inclk0_input_frequency		: NATURAL;
		gate_lock_signal		: STRING;
		clk0_divide_by		: NATURAL;
		pll_type		: STRING;
		valid_lock_multiplier		: NATURAL;
		intended_device_family		: STRING;
		operation_mode		: STRING;
		compensate_clock		: STRING;
		clk0_phase_shift		: STRING
	);
	PORT (
			inclk	: IN STD_LOGIC_VECTOR (1 DOWNTO 0);
			locked	: OUT STD_LOGIC ;
			clk	: OUT STD_LOGIC_VECTOR (5 DOWNTO 0)
	);
	END COMPONENT;

begin

	sub_wire5_bv(0 DOWNTO 0) <= "0";
	sub_wire5    <= To_stdlogicvector(sub_wire5_bv);
	sub_wire1    <= sub_wire0(0);
	CLK200MHz    <= sub_wire1;
	locked    <= sub_wire2;
	sub_wire3    <= inclk0;
	sub_wire4    <= sub_wire5(0 DOWNTO 0) & sub_wire3;

	altpll_component : altpll
	GENERIC MAP (
		clk0_duty_cycle => 50,
		lpm_type => "altpll",
		clk0_multiply_by => 1,
		invalid_lock_multiplier => 5,
		inclk0_input_frequency => 5000,
		gate_lock_signal => "NO",
		clk0_divide_by => 1,
		pll_type => "FAST",
		valid_lock_multiplier => 1,
		intended_device_family => "Cyclone II",
		operation_mode => "NORMAL",
		compensate_clock => "CLK0",
--		clk0_phase_shift => "2000"
		clk0_phase_shift => "0000"
	)
	PORT MAP (
		inclk => sub_wire4,
		clk => sub_wire0,
		locked => sub_wire2
	);
 
end rtl ; -- of PLL

--------------------------------------------------------------------------------
-- Entity declaration of 'SYNCHRONISATION'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity SYNCHRONISATION is
  port(
    CLK200MHz    : in     std_logic;
    DATA_NEG_ADC : in     std_logic_vector(11 downto 0);
    DATA_POS_ADC : in     std_logic_vector(11 downto 0);
    DCO_NEG_ADC  : in     std_logic;
    DCO_POS_ADC  : in     std_logic;
    DOUT_NEG     : out    std_logic_vector(11 downto 0);
    DOUT_POS     : out    std_logic_vector(11 downto 0);
    LOCKED       : in     std_logic;
    SYSRST       : in     std_logic);
end SYNCHRONISATION ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'SYNCHRONISATION'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of SYNCHRONISATION is

signal RST: std_logic; 
signal DATA_POS_ADC_TMP1: std_logic_vector(11 downto 0);
signal DATA_POS_ADC_TMP2: std_logic_vector(11 downto 0);
signal DATA_NEG_ADC_TMP1: std_logic_vector(11 downto 0);
-- signal DATA_NEG_ADC_TMP2: std_logic_vector(11 downto 0);

begin
  
  RST <= SYSRST or not LOCKED;
  
  process(DCO_POS_ADC,RST)
  begin
    if RST = '1' then
      DATA_POS_ADC_TMP1 <= (others => '0');
    elsif (DCO_POS_ADC'event and DCO_POS_ADC = '1') then
      DATA_POS_ADC_TMP1 <= DATA_POS_ADC;
    end if;
  end process;  

  process(CLK200MHz,RST)
  begin
    if RST = '1' then
      DATA_POS_ADC_TMP2 <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '0') then -- negative edge
      DATA_POS_ADC_TMP2 <= DATA_POS_ADC_TMP1;
    end if;
  end process;  

  process(CLK200MHz,RST)
  begin
    if RST = '1' then
      Dout_POS <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      Dout_POS <= DATA_POS_ADC_TMP2;
    end if;
  end process;  

  process(DCO_NEG_ADC,RST)
  begin
    if RST = '1' then
      DATA_NEG_ADC_TMP1 <= (others => '0');
    elsif (DCO_NEG_ADC'event and DCO_NEG_ADC = '1') then
      DATA_NEG_ADC_TMP1 <= DATA_NEG_ADC;
    end if;
  end process;  

--  process(CLK200MHz,RST)
--  begin
--    if RST = '1' then
--      DATA_NEG_ADC_TMP2 <= (others => '0');
--    elsif (CLK200MHz'event and CLK200MHz = '0') then
--      DATA_NEG_ADC_TMP2 <= DATA_NEG_ADC_TMP1;
--    end if;
--  end process;  

  process(CLK200MHz,RST)
  begin
    if RST = '1' then
      Dout_NEG <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      Dout_NEG <= DATA_NEG_ADC_TMP1;
    end if;
  end process;  

end rtl ; -- of SYNCHRONISATION

--------------------------------------------------------------------------------
-- Entity declaration of 'CONVERSION_12_TO_8_BIT'.
-- Last modified : Mon Dec 18 10:53:51 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity CONVERSION_12_TO_8_BIT is
  port(
    CLKRD              : in     std_logic;
    CONVERSION_CLK     : in     std_logic;
    CONV_DATA_READY    : out    std_logic;
    CTD_IN             : in     std_logic_vector(31 downto 0);
    CTD_OUT            : out    std_logic_vector(31 downto 0);
    DATA_OUT           : out    std_logic_vector(7 downto 0);
    DATA_OUT_CH1       : in     std_logic_vector(11 downto 0);
    DATA_OUT_CH2       : in     std_logic_vector(11 downto 0);
    DATA_READY_CH1     : in     std_logic;
    DATA_READY_CH2     : in     std_logic;
    DATA_VALID_CH1     : in     std_logic;
    DATA_VALID_CH2     : in     std_logic;
    FIFO_EMPTY         : in     std_logic;
    GPS_TS_IN          : in     std_logic_vector(55 downto 0);
    GPS_TS_OUT         : out    std_logic_vector(55 downto 0);
    RDEN_CH1           : out    std_logic;
    RDEN_CH2           : out    std_logic;
    SYSRST             : in     std_logic;
    TOTAL_TIME_3X      : in     integer range 6000 downto 0;
    TOTAL_TIME_6X      : out    integer range 12000 downto 0;
    TRIGGER_PATTERN    : out    std_logic_vector(15 downto 0);
    TRIGGER_PATTERN_IN : in     std_logic_vector(15 downto 0);
    WE                 : out    std_logic;
    WR_ADDRESS         : out    integer range 12020 downto 0);
end CONVERSION_12_TO_8_BIT ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'CONVERSION_12_TO_8_BIT'
-- Last modified : Mon Dec 18 10:53:51 2006.
--------------------------------------------------------------------------------

architecture rtl of CONVERSION_12_TO_8_BIT is

signal PHASE1: std_logic;
signal PHASE2: std_logic;
signal PHASE: std_logic_vector(1 downto 0);  
signal WR_ADDRESS_CNT: integer range 12020 downto 0;  
signal DATA_OUT_TMP: std_logic_vector(3 downto 0);  
signal WE_TMP: std_logic;
signal WE_DEL: std_logic;
signal FIFO_EMPTY_DEL: std_logic;
signal CHANNEL_SELECT: std_logic;
signal CHANNEL_SELECT_PRE1: std_logic;
signal CHANNEL_SELECT_PRE2: std_logic;
signal RDEN_SELECT: std_logic;
signal DATA_SELECT: std_logic_vector(11 downto 0);  
signal WR_ADDRESS_SELECT_BEGIN: integer range 12020 downto 0;  
signal WR_ADDRESS_SELECT_END: integer range 12020 downto 0;  
signal TOTAL_TIME_6X_TMP: integer range 12000 downto 0;  
signal DATA_VALID_SELECT: std_logic;

begin
-- PHASE1 and PHASE2 are made to divide two periods of CLKRD in four parts
-- each part has the lenght of CONVERSION_CLK
  PHASE(0) <= PHASE1;
  PHASE(1) <= PHASE2;
  
  WR_ADDRESS <= WR_ADDRESS_CNT;
  WE <= WE_TMP;
  TOTAL_TIME_6X <= TOTAL_TIME_6X_TMP;


  process(CLKRD,DATA_VALID_SELECT)
  begin
    if DATA_VALID_SELECT = '0' then
      PHASE1 <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      PHASE1 <= not PHASE1;
    end if;
  end process;  

  process(CLKRD,DATA_VALID_SELECT)
  begin
    if DATA_VALID_SELECT = '0' then
      PHASE2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then
      PHASE2 <= PHASE1;
    end if;
  end process;  

  process(CONVERSION_CLK,DATA_SELECT,WR_ADDRESS_CNT)
  begin
    if (CONVERSION_CLK'event and CONVERSION_CLK = '1') then
      if DATA_VALID_SELECT = '1' then
        if WR_ADDRESS_CNT < WR_ADDRESS_SELECT_END - 1 then
    	  case PHASE is
    	    -- In the first part the most significant 8 data bits from the ADCs
    	    -- go to the output (input for FIFO) and the other 4 bits to a temporary register
      	    when "10" => DATA_OUT <= DATA_SELECT(11 downto 4);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT +1;
                       
      	    -- The write address counter for the FIFO will not change
      	    -- The counter only increments in the other 3 parts
      	    when "00" => DATA_OUT <= DATA_SELECT(11 downto 4);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT; 
                       
    	    -- In this part the data from the temporary register (this are the least
    	    -- significant bits of the former data) go to the most significant bits
    	    -- of the FIFO data and the least significant bits of the FIFO will be
    	    -- the most significant bits of the new input data.
      	    when "01" => DATA_OUT(7 downto 4) <= DATA_OUT_TMP;
                         DATA_OUT(3 downto 0) <= DATA_SELECT(11 downto 8);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT + 1;
                       
            -- In the last part the least significant bits of the new input data 
            -- go to the FIFO              
      	    when "11" => DATA_OUT <= DATA_SELECT(7 downto 0);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT + 1;
      	    when others => DATA_OUT <= DATA_SELECT(11 downto 4);
                         DATA_OUT_TMP <= DATA_SELECT(3 downto 0);
                         WR_ADDRESS_CNT <= WR_ADDRESS_CNT;
   		  end case;
   	      WE_TMP <= '1';
   	    else
   	  	  WR_ADDRESS_CNT <= WR_ADDRESS_CNT;
   	  	  DATA_OUT <= "00000000";
   	  	  DATA_OUT_TMP <= "0000";
   	      WE_TMP <= '0';
   	    end if;
   	  else
   	    WR_ADDRESS_CNT <= WR_ADDRESS_SELECT_BEGIN;
   	  end if;     	    
    end if;
  end process; 

  -- Delays
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WE_DEL <= '0';
      FIFO_EMPTY_DEL <= '1';
    elsif (CLKRD'event and CLKRD = '1') then
      WE_DEL <= WE_TMP;
      FIFO_EMPTY_DEL <= FIFO_EMPTY;
    end if;
  end process;  

  -- Read enable must go false at the end of writing the FIFO and true when readout has finished 
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      RDEN_SELECT <= '1';
    elsif (CLKRD'event and CLKRD = '1') then
      if WE_TMP = '0' and WE_DEL = '1' and CHANNEL_SELECT = '1' then
        RDEN_SELECT <= '0';
      elsif FIFO_EMPTY = '1' and FIFO_EMPTY_DEL = '0' then
        RDEN_SELECT <= '1';
      end if;  
    end if;
  end process;  

  -- Data conversion (CONV_DATA_READY) must go true at the end of writing the FIFO and false when readout starts 
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      CONV_DATA_READY <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WE_TMP = '0' and WE_DEL = '1' and CHANNEL_SELECT = '1' then
        CONV_DATA_READY <= '1';
      elsif FIFO_EMPTY = '0' and FIFO_EMPTY_DEL = '1' then
        CONV_DATA_READY <= '0';
      end if;  
    end if;
  end process;  

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      CHANNEL_SELECT <= '0';
      CHANNEL_SELECT_PRE1 <= '0';
      CHANNEL_SELECT_PRE2 <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      CHANNEL_SELECT_PRE2 <= CHANNEL_SELECT_PRE1;
      CHANNEL_SELECT <= CHANNEL_SELECT_PRE2;
      if WR_ADDRESS_CNT >= TOTAL_TIME_3X - 1 and WR_ADDRESS_CNT < TOTAL_TIME_6X_TMP - 1 then 
        CHANNEL_SELECT_PRE1 <= '1';
      else
        CHANNEL_SELECT_PRE1 <= '0';
      end if;  
    end if;
  end process;  

  -- Read enable select. If CHANNEL_SELECT = channel 1 then RDEN_CH1 has to be selected and RDEN_CH2 has to be zero
  -- If CHANNEL_SELECT = channel 2 then RDEN_CH2 has to be selected and RDEN_CH1 has to be zero
  RDEN_CH1 <= RDEN_SELECT when CHANNEL_SELECT = '0' else '0';
  RDEN_CH2 <= RDEN_SELECT when CHANNEL_SELECT = '1' else '0';
  
  -- The input data is from channel 1 when CHANNEL_SELECT = 0 or from channel 2 when CHANNEL_SELECT = 1  
  DATA_SELECT <= DATA_OUT_CH1 when CHANNEL_SELECT = '0' else DATA_OUT_CH2;
  
  -- Data valid is from channel 1 when CHANNEL_SELECT = 0 or from channel 2 when CHANNEL_SELECT = 1  
  DATA_VALID_SELECT <= DATA_VALID_CH1 when CHANNEL_SELECT = '0' else DATA_VALID_CH2;

  -- FIFO write address has to begin at zero and has to stop at 3 times the total time when doing channel 1
  -- FIFO write address has to begin at 3 times the total time and has to stop at 6 times the total time when doing channel 2
  TOTAL_TIME_6X_TMP <= TOTAL_TIME_3X + TOTAL_TIME_3X;
  WR_ADDRESS_SELECT_BEGIN <= 0 when CHANNEL_SELECT = '0' else TOTAL_TIME_3X;
  WR_ADDRESS_SELECT_END <= TOTAL_TIME_3X when CHANNEL_SELECT = '0' else TOTAL_TIME_6X_TMP;

  -- Take over TRIGGER_PATTERN, GPS_TS and CTD 
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN <= "0000000000000000";
      GPS_TS_OUT <= "00000000000000000000000000000000000000000000000000000000";
      CTD_OUT <= "00000000000000000000000000000000";
    elsif (CLKRD'event and CLKRD = '1') then
      if WE_TMP = '0' and WE_DEL = '1' and CHANNEL_SELECT = '1' then
        TRIGGER_PATTERN <= TRIGGER_PATTERN_IN;
        GPS_TS_OUT <= GPS_TS_IN;
        CTD_OUT <= CTD_IN;
      end if;  
    end if;
  end process;  

  
end rtl ; -- of CONVERSION_12_TO_8_BIT

--------------------------------------------------------------------------------
-- Entity declaration of 'EVENT_FIFO'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity EVENT_FIFO is
  port(
    DATA_IN    : in     std_logic_vector(7 downto 0);
    DATA_OUT   : out    std_logic_vector(7 downto 0);
    RDCLOCK    : in     std_logic;
    RD_ADDRESS : in     integer range 12020 downto 0;
    WE         : in     std_logic;
    WRCLOCK    : in     std_logic;
    WR_ADDRESS : in     integer range 12020 downto 0);
end EVENT_FIFO ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'EVENT_FIFO'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of EVENT_FIFO is

	type MEM is array(0 to 12020) of std_logic_vector(7 downto 0);
	signal RAM_BLOCK : MEM;
	signal RD_ADDRESS_REG : integer range 0 to 12020;

begin
	process (WRCLOCK)
	begin
		if (WRCLOCK'event and WRCLOCK = '1') then
			if (WE = '1') then
				RAM_BLOCK(WR_ADDRESS) <= DATA_IN;
			end if;

		end if;
	end process;

	process (RDCLOCK)
	BEGIN
		if (RDCLOCK'event and RDCLOCK = '1') then
			DATA_OUT <= RAM_BLOCK(RD_ADDRESS_REG);
			RD_ADDRESS_REG <= RD_ADDRESS;
		end if;
	end process;

end rtl ; -- of EVENT_FIFO

--------------------------------------------------------------------------------
-- Entity declaration of 'EVENT_FIFO_CONTROL'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity EVENT_FIFO_CONTROL is
  port(
    CLKRD            : in     std_logic;
    DATA_READY_CONV  : in     std_logic;
    DOUT_VALID       : out    std_logic;
    EVENT_DATA_READY : out    std_logic;
    FIFO_EMPTY       : out    std_logic;
    RDCLOCK          : out    std_logic;
    RDEN             : in     std_logic;
    RD_ADDRESS       : out    integer range 12020 downto 0;
    SYSRST           : in     std_logic;
    TOTAL_TIME_6X    : in     integer range 12000 downto 0);
end EVENT_FIFO_CONTROL ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'EVENT_FIFO_CONTROL'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of EVENT_FIFO_CONTROL is

signal DATA_READY_CONV_DEL: std_logic;
signal DATA_VALID_TMP: std_logic;
signal DATA_VALID_TMP2: std_logic;
signal EVENT_DATA_READY_TMP: std_logic;
signal EVENT_DATA_READY_TMP2: std_logic;
signal RDEN_TMP: std_logic; -- needed to synchronize read enable
signal RD_ADDRESS_TMP: integer range 12020 downto 0;


begin

  RD_ADDRESS <= RD_ADDRESS_TMP;
  RDCLOCK <= CLKRD;
  DOUT_VALID <= DATA_VALID_TMP2 and EVENT_DATA_READY_TMP2;
  EVENT_DATA_READY <= EVENT_DATA_READY_TMP;
  FIFO_EMPTY <= not EVENT_DATA_READY_TMP;
  
  -- Delay's
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_READY_CONV_DEL <= '0';
      DATA_VALID_TMP2 <= '0';
      EVENT_DATA_READY_TMP2 <= '0';
      RDEN_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      DATA_READY_CONV_DEL <= DATA_READY_CONV;
      DATA_VALID_TMP2 <= DATA_VALID_TMP;
      EVENT_DATA_READY_TMP2 <= EVENT_DATA_READY_TMP;
      RDEN_TMP <= RDEN;
    end if;
  end process;  
  

  -- EVENT_DATA_READY must be valid if DATA_READY_CONV goes true.
  -- in other words: the USB device gets the signal that there is data in the FIFO to readout.
  -- EVENT_DATA_READY must go low at the end of readout.
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      EVENT_DATA_READY_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      -- on a positive edge of DATA_READY_CONV
      if DATA_READY_CONV = '1' and DATA_READY_CONV_DEL = '0' then
        EVENT_DATA_READY_TMP <= '1';
      elsif RD_ADDRESS_TMP > TOTAL_TIME_6X - 1 then
        EVENT_DATA_READY_TMP <= '0';
      else
        EVENT_DATA_READY_TMP <= EVENT_DATA_READY_TMP;
      end if;  
    end if;
  end process;  

  -- This signal is true when the data from the FIFO is valid.
  -- DATA_VALID must be valid if DATA_READY_CONV goes true and USB asks for readout.
  -- DATA_VALID must go low at the end of readout.
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      DATA_VALID_TMP <= '0';
      RD_ADDRESS_TMP <= 0;
    elsif (CLKRD'event and CLKRD = '1') then
      if EVENT_DATA_READY_TMP = '1' then
        if RDEN_TMP = '1' then
          DATA_VALID_TMP <= '1';
          RD_ADDRESS_TMP <= RD_ADDRESS_TMP + 1;
        else
          DATA_VALID_TMP <= '0';
          RD_ADDRESS_TMP <= RD_ADDRESS_TMP;
        end if;
      else    
        RD_ADDRESS_TMP <= 0;        
        DATA_VALID_TMP <= '0';
      end if;  
    end if;
  end process;  



end rtl ; -- of EVENT_FIFO_CONTROL

--------------------------------------------------------------------------------
-- Entity declaration of 'SLAVE_DETECTOR'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity SLAVE_DETECTOR is
  port(
    CLK10MHz      : in     std_logic;
    CLK200MHz     : in     std_logic;
    SH1           : in     std_logic;
    SH1_SYNCHR    : out    std_logic;
    SH2           : in     std_logic;
    SH2_SYNCHR    : out    std_logic;
    SL1           : in     std_logic;
    SL1_SYNCHR    : out    std_logic;
    SL2           : in     std_logic;
    SL2_SYNCHR    : out    std_logic;
    SLAVE_PRESENT : out    std_logic;
    SYSRST        : in     std_logic);
end SLAVE_DETECTOR ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'SLAVE_DETECTOR'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of SLAVE_DETECTOR is

signal SH1_DEL1: std_logic; -- SH1 after one 200MHz period
signal SH2_DEL1: std_logic; -- SH2 after one 200MHz period
signal SL1_DEL1: std_logic; -- SL1 after one 200MHz period
signal SL2_DEL1: std_logic; -- SL2 after one 200MHz period
signal SH1_DEL2: std_logic; -- SH1 after two 200MHz periods
signal SH2_DEL2: std_logic; -- SH2 after two 200MHz periods
signal SL1_DEL2: std_logic; -- SL1 after two 200MHz periods
signal SL2_DEL2: std_logic; -- SL2 after two 200MHz periods
signal HIT_ON_SH1: std_logic; -- Look within a SAMPLE period if SH1 went low
signal HIT_ON_SH2: std_logic; -- Look within a SAMPLE period if SH2 went low
signal HIT_ON_SL1: std_logic; -- Look within a SAMPLE period if SL1 went low
signal HIT_ON_SL2: std_logic; -- Look within a SAMPLE period if SL2 went low
signal HIT_ON_SH1_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.
signal HIT_ON_SH2_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.
signal HIT_ON_SL1_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.
signal HIT_ON_SL2_COUNTER: std_logic_vector(7 downto 0); -- The period is 25.6us. This covers at least 2 coincidence windows.

begin

  SLAVE_PRESENT <= '1' when (SL1 = '0' or SL2 = '0' or SH1 = '0' or SH2 = '0' or HIT_ON_SL1 = '1' or HIT_ON_SL2 = '1' or HIT_ON_SH1 = '1' or HIT_ON_SH2 = '1') else '0';
  SL1_SYNCHR <= SL1_DEL1;
  SH1_SYNCHR <= SH1_DEL1;
  SL2_SYNCHR <= SL2_DEL1;
  SH2_SYNCHR <= SH2_DEL1;
  
  -- Delays
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      SH1_DEL1 <= '1';
      SH2_DEL1 <= '1';
      SL1_DEL1 <= '1';
      SL2_DEL1 <= '1';
      SH1_DEL2 <= '1';
      SH2_DEL2 <= '1';
      SL1_DEL2 <= '1';
      SL2_DEL2 <= '1';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      SH1_DEL1 <= SH1; 
      SH2_DEL1 <= SH2; 
      SL1_DEL1 <= SL1; 
      SL2_DEL1 <= SL2; 
      SH1_DEL2 <= SH1_DEL1; 
      SH2_DEL2 <= SH2_DEL1; 
      SL1_DEL2 <= SL1_DEL1; 
      SL2_DEL2 <= SL2_DEL1; 
    end if;
  end process;  
      
  -- 25.6us stretcher for HIT_ON_SL1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then 
      if SL1_DEL1 = '1' and SL1_DEL2 = '0' then  -- On an upgoing egde of SL1
        HIT_ON_SL1 <= '1'; 
      elsif HIT_ON_SL1_COUNTER = "11111111" then
        HIT_ON_SL1 <= '0';
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL1_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SL1 = '0' then -- HIT_ON_SL1 = '0' makes end of stretcher window
        HIT_ON_SL1_COUNTER <= "00000000";
      else
        HIT_ON_SL1_COUNTER <= HIT_ON_SL1_COUNTER + 1;
      end if;
    end if;
  end process;  
  
  -- 25.6us stretcher for HIT_ON_SL2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then 
      if SL2_DEL1 = '1' and SL2_DEL2 = '0' then  -- On an upgoing egde of SL2
        HIT_ON_SL2 <= '1'; 
      elsif HIT_ON_SL2_COUNTER = "11111111" then
        HIT_ON_SL2 <= '0';
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SL2_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SL2 = '0' then -- HIT_ON_SL2 = '0' makes end of stretcher window
        HIT_ON_SL2_COUNTER <= "00000000";
      else
        HIT_ON_SL2_COUNTER <= HIT_ON_SL2_COUNTER + 1;
      end if;
    end if;
  end process;  

  -- 25.6us stretcher for HIT_ON_SH1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then 
      if SH1_DEL1 = '1' and SH1_DEL2 = '0' then  -- On an upgoing egde of SH1
        HIT_ON_SH1 <= '1'; 
      elsif HIT_ON_SH1_COUNTER = "11111111" then
        HIT_ON_SH1 <= '0';
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH1_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SH1 = '0' then -- HIT_ON_SH1 = '0' makes end of stretcher window
        HIT_ON_SH1_COUNTER <= "00000000";
      else
        HIT_ON_SH1_COUNTER <= HIT_ON_SH1_COUNTER + 1;
      end if;
    end if;
  end process;  

  -- 25.6us stretcher for HIT_ON_SH2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then 
      if SH2_DEL1 = '1' and SH2_DEL2 = '0' then  -- On an upgoing egde of SH2
        HIT_ON_SH2 <= '1'; 
      elsif HIT_ON_SH2_COUNTER = "11111111" then
        HIT_ON_SH2 <= '0';
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      HIT_ON_SH2_COUNTER <= "00000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if HIT_ON_SH2 = '0' then -- HIT_ON_SH2 = '0' makes end of stretcher window
        HIT_ON_SH2_COUNTER <= "00000000";
      else
        HIT_ON_SH2_COUNTER <= HIT_ON_SH2_COUNTER + 1;
      end if;
    end if;
  end process;  

end rtl ; -- of SLAVE_DETECTOR

--------------------------------------------------------------------------------
-- Entity declaration of 'DISCRIMINATORS'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity DISCRIMINATORS is
  port(
    CLK200MHz     : in     std_logic;
    COINC_TIME    : in     integer range 1000 downto 0;
    COMPH1        : out    std_logic;
    COMPH1_IN     : in     std_logic;
    COMPH2        : out    std_logic;
    COMPH2_IN     : in     std_logic;
    COMPL1        : out    std_logic;
    COMPL1_IN     : in     std_logic;
    COMPL2        : out    std_logic;
    COMPL2_IN     : in     std_logic;
    DATA_ADC1_NEG : in     std_logic_vector(11 downto 0);
    DATA_ADC1_POS : in     std_logic_vector(11 downto 0);
    DATA_ADC2_NEG : in     std_logic_vector(11 downto 0);
    DATA_ADC2_POS : in     std_logic_vector(11 downto 0);
    EXT_TR_IN     : in     std_logic;
    EXT_TR_OUT    : out    std_logic;
    MH1_OUT       : out    std_logic;
    MH2_OUT       : out    std_logic;
    ML1_OUT       : out    std_logic;
    ML2_OUT       : out    std_logic;
    SYSRST        : in     std_logic;
    THH1          : in     std_logic_vector(11 downto 0);
    THH2          : in     std_logic_vector(11 downto 0);
    THL1          : in     std_logic_vector(11 downto 0);
    THL2          : in     std_logic_vector(11 downto 0));
end DISCRIMINATORS ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'DISCRIMINATORS'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of DISCRIMINATORS is

signal ML1_PRE: std_logic ; -- Time Over Threshold channel1 low
signal ML2_PRE: std_logic ; -- Time Over Threshold channel2 low
signal MH1_PRE: std_logic ; -- Time Over Threshold channel1 high
signal MH2_PRE: std_logic ; -- Time Over Threshold channel2 high
signal ML1_PRE_DEL: std_logic ; -- Time Over Threshold channel1 low after one 200MHz period
signal ML2_PRE_DEL: std_logic ; -- Time Over Threshold channel2 low after one 200MHz period
signal MH1_PRE_DEL: std_logic ; -- Time Over Threshold channel1 high after one 200MHz period
signal MH2_PRE_DEL: std_logic ; -- Time Over Threshold channel2 high after one 200MHz period
signal ML1: std_logic ; -- Coincidence window ML1_PRE
signal ML1_CNT: integer range 1000 downto 0 ; -- Coincidence window counter ML1_PRE
signal ML2: std_logic ; -- Coincidence window ML2_PRE
signal ML2_CNT: integer range 1000 downto 0 ; -- Coincidence window counter ML2_PRE
signal MH1: std_logic ; -- Coincidence window MH1_PRE
signal MH1_CNT: integer range 1000 downto 0 ; -- Coincidence window counter MH1_PRE
signal MH2: std_logic ; -- Coincidence window MH2_PRE
signal MH2_CNT: integer range 1000 downto 0 ; -- Coincidence window counter MH2_PRE
signal EXT_TR_IN_DEL1: std_logic ; -- External trigger after one 200MHz period
signal EXT_TR_IN_DEL2: std_logic ; -- External trigger after two 200MHz periods; Two, because the external trigger is asynchronious
signal EXT_TR: std_logic ; -- Coincidence window EXT_TR
signal EXT_TR_CNT: integer range 1000 downto 0 ; -- Coincidence window counter EXT_TR
signal COMPL1_IN_DEL1: std_logic ; 
signal COMPL1_IN_DEL2: std_logic ; 
signal COMPL1_IN_WIN: std_logic ; 
signal COMPL1_IN_CNT: integer range 1000 downto 0 ; 
signal COMPH1_IN_DEL1: std_logic ; 
signal COMPH1_IN_DEL2: std_logic ; 
signal COMPH1_IN_WIN: std_logic ; 
signal COMPH1_IN_CNT: integer range 1000 downto 0 ; 
signal COMPL2_IN_DEL1: std_logic ; 
signal COMPL2_IN_DEL2: std_logic ; 
signal COMPL2_IN_WIN: std_logic ; 
signal COMPL2_IN_CNT: integer range 1000 downto 0 ; 
signal COMPH2_IN_DEL1: std_logic ; 
signal COMPH2_IN_DEL2: std_logic ; 
signal COMPH2_IN_WIN: std_logic ; 
signal COMPH2_IN_CNT: integer range 1000 downto 0 ; 

begin

--ML1_PRE <= '1' when (DATA_ADC1_POS > THL1 or DATA_ADC1_NEG > THL1) else '0'; -- Discriminator for ML1
--ML2_PRE <= '1' when (DATA_ADC2_POS > THL2 or DATA_ADC2_NEG > THL2) else '0'; -- Discriminator for ML2
--MH1_PRE <= '1' when (DATA_ADC1_POS > THH1 or DATA_ADC1_NEG > THH1) else '0'; -- Discriminator for MH1
--MH2_PRE <= '1' when (DATA_ADC2_POS > THH2 or DATA_ADC2_NEG > THH2) else '0'; -- Discriminator for MH2

ML1_OUT <= ML1;
MH1_OUT <= MH1;
ML2_OUT <= ML2;
MH2_OUT <= MH2;
EXT_TR_OUT <= EXT_TR;
COMPL1 <= COMPL1_IN_WIN;
COMPL2 <= COMPL2_IN_WIN;
COMPH1 <= COMPH1_IN_WIN;
COMPH2 <= COMPH2_IN_WIN;

  process(CLK200MHz,SYSRST)
  begin
    if (CLK200MHz'event and CLK200MHz = '1') then
      if (DATA_ADC1_POS > THL1 or DATA_ADC1_NEG > THL1) then -- Discriminator for ML1
        ML1_PRE <= '1';
      else
        ML1_PRE <= '0';
      end if;
      if (DATA_ADC2_POS > THL2 or DATA_ADC2_NEG > THL2) then -- Discriminator for ML2
        ML2_PRE <= '1';
      else
        ML2_PRE <= '0';
      end if;
      if (DATA_ADC1_POS > THH1 or DATA_ADC1_NEG > THH1) then -- Discriminator for MH1
        MH1_PRE <= '1';
      else
        MH1_PRE <= '0';
      end if;
      if (DATA_ADC2_POS > THH2 or DATA_ADC2_NEG > THH2) then -- Discriminator for MH2
        MH2_PRE <= '1';
      else
        MH2_PRE <= '0';
      end if;
    end if;
  end process;  


  -- Delays
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_PRE_DEL <= '0';
      ML2_PRE_DEL <= '0';
      MH1_PRE_DEL <= '0';
      MH2_PRE_DEL <= '0';
      EXT_TR_IN_DEL1 <= '0';
      EXT_TR_IN_DEL2 <= '0';
      COMPL1_IN_DEL1 <= '0';
      COMPL1_IN_DEL2 <= '0';
      COMPH1_IN_DEL1 <= '0';
      COMPH1_IN_DEL2 <= '0';
      COMPL2_IN_DEL1 <= '0';
      COMPL2_IN_DEL2 <= '0';
      COMPH2_IN_DEL1 <= '0';
      COMPH2_IN_DEL2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      ML1_PRE_DEL <= ML1_PRE; 
      ML2_PRE_DEL <= ML2_PRE; 
      MH1_PRE_DEL <= MH1_PRE; 
      MH2_PRE_DEL <= MH2_PRE; 
      EXT_TR_IN_DEL1 <= EXT_TR_IN; 
      EXT_TR_IN_DEL2 <= EXT_TR_IN_DEL1; 
      COMPL1_IN_DEL1 <= COMPL1_IN; 
      COMPL1_IN_DEL2 <= COMPL1_IN_DEL1; 
      COMPH1_IN_DEL1 <= COMPH1_IN; 
      COMPH1_IN_DEL2 <= COMPH1_IN_DEL1; 
      COMPL2_IN_DEL1 <= COMPL2_IN; 
      COMPL2_IN_DEL2 <= COMPL2_IN_DEL1; 
      COMPH2_IN_DEL1 <= COMPH2_IN; 
      COMPH2_IN_DEL2 <= COMPH2_IN_DEL1; 
    end if;
  end process;  
      
  -- Coincidence window for ML1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML1_PRE = '1' and ML1_PRE_DEL = '0' then  -- On an upgoing egde of ML1_PRE
        ML1 <= '1'; 
      elsif ML1_CNT = COINC_TIME - 1 then
        ML1 <= '0';
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML1 = '0' then -- ML1 = '0' makes end of coinc window
        ML1_CNT <= 0;
      else
        ML1_CNT <= ML1_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for ML2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML2_PRE = '1' and ML2_PRE_DEL = '0' then -- On an upgoing egde of ML2_PRE
        ML2 <= '1'; 
      elsif ML2_CNT = COINC_TIME - 1 then
        ML2 <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML2_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ML2 = '0' then -- ML2 = '0' makes end of coinc window
        ML2_CNT <= 0;
      else
        ML2_CNT <= ML2_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for MH1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH1_PRE = '1' and MH1_PRE_DEL = '0' then  -- On an upgoing egde of MH1_PRE
        MH1 <= '1'; 
      elsif MH1_CNT = COINC_TIME - 1 then
        MH1 <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH1_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH1 = '0' then -- MH1 = '0' makes end of coinc window
        MH1_CNT <= 0;
      else
        MH1_CNT <= MH1_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for MH2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH2_PRE = '1' and MH2_PRE_DEL = '0' then -- On an upgoing egde of MH2_PRE
        MH2 <= '1'; 
      elsif MH2_CNT = COINC_TIME - 1 then
        MH2 <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH2_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if MH2 = '0' then -- MH2 = '0' makes end of coinc window
        MH2_CNT <= 0;
      else
        MH2_CNT <= MH2_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for EXT_TR
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      EXT_TR <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if EXT_TR_IN_DEL1 = '1' and EXT_TR_IN_DEL2 = '0' then -- On an upgoing egde of EXT_TR_IN
        EXT_TR <= '1'; 
      elsif EXT_TR_CNT = COINC_TIME - 1 then
        EXT_TR <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      EXT_TR_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if EXT_TR = '0' then -- EXT_TR = '0' makes end of coinc window
        EXT_TR_CNT <= 0;
      else
        EXT_TR_CNT <= EXT_TR_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for COMPL1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL1_IN_DEL1 = '1' and COMPL1_IN_DEL2 = '0' then 
        COMPL1_IN_WIN <= '1'; 
      elsif COMPL1_IN_CNT = COINC_TIME - 1 then
        COMPL1_IN_WIN <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL1_IN_WIN = '0' then 
        COMPL1_IN_CNT <= 0;
      else
        COMPL1_IN_CNT <= COMPL1_IN_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for COMPH1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH1_IN_DEL1 = '1' and COMPH1_IN_DEL2 = '0' then 
        COMPH1_IN_WIN <= '1'; 
      elsif COMPH1_IN_CNT = COINC_TIME - 1 then
        COMPH1_IN_WIN <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH1_IN_WIN = '0' then 
        COMPH1_IN_CNT <= 0;
      else
        COMPH1_IN_CNT <= COMPH1_IN_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for COMPL2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL2_IN_DEL1 = '1' and COMPL2_IN_DEL2 = '0' then 
        COMPL2_IN_WIN <= '1'; 
      elsif COMPL2_IN_CNT = COINC_TIME - 1 then
        COMPL2_IN_WIN <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL2_IN_WIN = '0' then 
        COMPL2_IN_CNT <= 0;
      else
        COMPL2_IN_CNT <= COMPL2_IN_CNT + 1;
      end if;
    end if;
  end process;  

  -- Coincidence window for COMPH2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_IN_WIN <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH2_IN_DEL1 = '1' and COMPH2_IN_DEL2 = '0' then 
        COMPH2_IN_WIN <= '1'; 
      elsif COMPH2_IN_CNT = COINC_TIME - 1 then
        COMPH2_IN_WIN <= '0';
      end if;
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_IN_CNT <= 0;
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH2_IN_WIN = '0' then 
        COMPH2_IN_CNT <= 0;
      else
        COMPH2_IN_CNT <= COMPH2_IN_CNT + 1;
      end if;
    end if;
  end process;  

end rtl ; -- of DISCRIMINATORS

--------------------------------------------------------------------------------
-- Entity declaration of 'TRIGGER_MATRIX'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity TRIGGER_MATRIX is
  port(
    BLOCK_COINC     : in     std_logic;
    CLK10MHz        : in     std_logic;
    CLK200MHz       : in     std_logic;
    COMPH1          : in     std_logic;
    COMPH2          : in     std_logic;
    COMPL1          : in     std_logic;
    COMPL2          : in     std_logic;
    END_OF_COINC    : out    std_logic;
    EXT_TR          : in     std_logic;
    MASTER          : in     std_logic;
    MH1             : in     std_logic;
    MH2             : in     std_logic;
    ML1             : in     std_logic;
    ML2             : in     std_logic;
    SH1_IN          : in     std_logic;
    SH2_IN          : in     std_logic;
    SL1_IN          : in     std_logic;
    SL2_IN          : in     std_logic;
    SLAVE_PRESENT   : in     std_logic;
    SYSRST          : in     std_logic;
    TRIGGER_PATTERN : out    std_logic_vector(15 downto 0);
    TR_CONDITION    : in     std_logic_vector(7 downto 0));
end TRIGGER_MATRIX ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'TRIGGER_MATRIX'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of TRIGGER_MATRIX is

signal SL1: std_logic ;
signal SL2: std_logic ;
signal SH1: std_logic ;
signal SH2: std_logic ;
signal TR_CONDITION1: std_logic ;
signal TR_CONDITION2: std_logic ;
signal TR_CONDITION3: std_logic ;
signal TR_CONDITION4: std_logic ;
signal TR_CONDITION5: std_logic ;
signal TR_CONDITION6: std_logic ;
signal TR_CONDITION7: std_logic ;
signal TR_CONDITION8: std_logic ;
signal TR_CONDITION9: std_logic ;
signal TR_CONDITION10: std_logic ;
signal TR_CONDITION11: std_logic ;
signal TR_CONDITION12: std_logic ;
signal TR_CONDITION13: std_logic ;
signal TR_CONDITION14: std_logic ;
signal SCINT_PATTERN: std_logic_vector(5 downto 0); -- The 6 LSB bits of TR_CONDITION selects a SCINT_PATTERN; TR_CONDITION(6) selects the ext. trigger
signal CAL_EXTTRIG_PATTERN: std_logic_vector(1 downto 0); -- TR_CONDITION(7) selects a calibration; TR_CONDITION(6) selects the ext. trigger
signal SCINT_COINC: std_logic ; -- Selected scintillator trigger
signal COINC_TMP: std_logic ;
signal COINC_DEL: std_logic ;
signal BLOCK_COINC_SYNCHR: std_logic ;
signal COINC_STRETCH: std_logic_vector(4 downto 0); -- Stretch COINC 32 x 5ns, because it has to go to the slave module via a cable
signal CAL_COUNT: std_logic_vector(22 downto 0); -- Calibration counter Full scale is about 2^23 times 100ns is 0.84 seconds


begin

  SCINT_PATTERN <= TR_CONDITION(5 downto 0);
  CAL_EXTTRIG_PATTERN <= TR_CONDITION(7 downto 6);
  
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      SL1 <= '0';
      SL2 <= '0';
      SH1 <= '0';
      SH2 <= '0';  
      COINC_DEL <= '0';        
      BLOCK_COINC_SYNCHR <= '0';        
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COINC_DEL <= COINC_TMP;        
      BLOCK_COINC_SYNCHR <= BLOCK_COINC;        
      if SLAVE_PRESENT = '1' then
        SL1 <= SL1_IN; 
        SL2 <= SL2_IN; 
        SH1 <= SH1_IN; 
        SH2 <= SH2_IN; 
      else
        SL1 <= '0';
        SL2 <= '0';
        SH1 <= '0';
        SH2 <= '0';
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      CAL_COUNT <= "00000000000000000000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      CAL_COUNT <= CAL_COUNT + "00000000000000000000001";
    end if;
  end process;  
      
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_STRETCH <= "00000";
      END_OF_COINC <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TMP = '0' and COINC_DEL = '1' and BLOCK_COINC_SYNCHR = '0' then -- at falling edge of coinc
        COINC_STRETCH <= "00000";
        END_OF_COINC <= '1';
      elsif COINC_STRETCH /= "11111" then
        COINC_STRETCH <= COINC_STRETCH + "00001";
        END_OF_COINC <= '1';
      else
        COINC_STRETCH <= COINC_STRETCH;
        END_OF_COINC <= '0';
      end if;
    end if;
  end process;  

-- TR_CONDITION1
-- 0H, 1L, at least one low signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION1 <= (ML1 or ML2 or SL1 or SL2);
    end if;
  end process;  

-- TR_CONDITION2
-- 0H, 2L, at least two low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION2 <= (ML1 and ML2) or (ML1 and SL1) or (ML1 and SL2) or 
                       (ML2 and SL1) or (ML2 and SL2) or 
                       (SL1 and SL2);
    end if;
  end process;  

-- TR_CONDITION3
-- 0H, 3L, at least three low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION3 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION3 <= (ML1 and ML2 and SL1) or (ML1 and ML2 and SL2) or (ML1 and SL1 and SL2) or 
                       (ML2 and SL1 and SL2);
    end if;
  end process;  

-- TR_CONDITION4
-- 0H, 4L, all four low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION4 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION4 <= (ML1 and ML2 and SL1 and SL2);
    end if;
  end process;  

-- TR_CONDITION5
-- 1H, 0L,  at least one high signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION5 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION5 <= (MH1 or MH2 or SH1 or SH2);
    end if;
  end process;  

-- TR_CONDITION6
-- 1H, 1L,  at least one high signal and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION6 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION6 <= TR_CONDITION5 and TR_CONDITION2;
    end if;
  end process;  

-- TR_CONDITION7
-- 1H, 2L,  at least one high signal and at least two other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION7 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION7 <= TR_CONDITION5 and TR_CONDITION3;
    end if;
  end process;  

-- TR_CONDITION8
-- 1H, 3L,  at least one high signal and at least three other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION8 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION8 <= TR_CONDITION5 and TR_CONDITION4;
    end if;
  end process;  

-- TR_CONDITION9
-- 2H, 0L, at least two high signals. 
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION9 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION9 <= (MH1 and MH2) or (MH1 and SH1) or (MH1 and SH2) or 
                 (MH2 and SH1) or (MH2 and SH2) or  
                 (SH1 and SH2); 
    end if;
  end process;  

-- TR_CONDITION10
-- 2H, 1L,  at least two high signals and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION10 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION10 <= TR_CONDITION9 and TR_CONDITION3;
    end if;
  end process;  

-- TR_CONDITION11
-- 2H, 2L,  at least two high signals and at least two other low signals
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION11 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION11 <= TR_CONDITION9 and TR_CONDITION4;
    end if;
  end process;  

-- TR_CONDITION12
-- 3H, 0L,  at least two high signals and at least three other low signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION12 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION12 <= (MH1 and MH2 and SH1) or (MH1 and MH2 and SH2) or (MH1 and SH1 and SH2) or 
                        (MH2 and SH1 and SH2);
    end if;
  end process;  

-- TR_CONDITION13
-- 3H, 1L,  at least three high signals and at least one other low signal
-- Assuming that when the high signal is present, the low signal of that channel is also present.
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION13 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION13 <= TR_CONDITION12 and TR_CONDITION4;
    end if;
  end process;  

-- TR_CONDITION14
-- 4H, 0L, all four high signals
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TR_CONDITION14 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      TR_CONDITION14 <= (MH1 and MH2 and SH1 and SH2);
    end if;
  end process;  

  process (CLK200MHz,SCINT_PATTERN,TR_CONDITION1,TR_CONDITION2,TR_CONDITION3,TR_CONDITION4,TR_CONDITION5,TR_CONDITION6,TR_CONDITION7,TR_CONDITION8,TR_CONDITION9,TR_CONDITION10,TR_CONDITION11,TR_CONDITION12,TR_CONDITION13,TR_CONDITION14)
  begin
    if (CLK200MHz'event and CLK200MHz='1') then
      case SCINT_PATTERN is
        when "000001" => SCINT_COINC <= TR_CONDITION1;
        when "000010" => SCINT_COINC <= TR_CONDITION2;
        when "000011" => SCINT_COINC <= TR_CONDITION3;
        when "000100" => SCINT_COINC <= TR_CONDITION4;
        when "001000" => SCINT_COINC <= TR_CONDITION5;
        when "001001" => SCINT_COINC <= TR_CONDITION6;
        when "001010" => SCINT_COINC <= TR_CONDITION7;
        when "001011" => SCINT_COINC <= TR_CONDITION8;
        when "010000" => SCINT_COINC <= TR_CONDITION9;
        when "010001" => SCINT_COINC <= TR_CONDITION10;
        when "010010" => SCINT_COINC <= TR_CONDITION11;
        when "011000" => SCINT_COINC <= TR_CONDITION12;
        when "011001" => SCINT_COINC <= TR_CONDITION13;
        when "100000" => SCINT_COINC <= TR_CONDITION14;
        when others => SCINT_COINC <= '0';
      end case;  
    end if;
  end process;

  process(CLK200MHz,SCINT_COINC)
  begin
    if (CLK200MHz'event and CLK200MHz='1') then
      case CAL_EXTTRIG_PATTERN is
        when "00" => COINC_TMP <= SCINT_COINC; -- No External trigger, only triggers from scintillators
        when "01" => COINC_TMP <= SCINT_COINC or EXT_TR; -- External trigger and triggers from scintillators selected; TR_CONDITION15 if SCINT_COINC = '0'; TR_CONDITION16  if SCINT_COINC = TR_CONDITION1 to 14
        when "10" => COINC_TMP <= CAL_COUNT(22); -- Calibration selected
        when "11" => COINC_TMP <= CAL_COUNT(22); -- Calibration selected
        when others => COINC_TMP <= '0';
      end case;  
    end if;
  end process;


--  process(CLK200MHz,SYSRST)
--  begin
--    if SYSRST = '1' then
--      COINC_TMP <= '0';
--    elsif (CLK200MHz'event and CLK200MHz = '1') then
--      if TR_CONDITION(6) = '1' then -- External trigger selected
--        COINC_TMP <= SCINT_COINC or EXT_TR; -- TR_CONDITION15 if SCINT_COINC = '0'; TR_CONDITION16  if SCINT_COINC = TR_CONDITION1 to 14
--      else
--        COINC_TMP <= SCINT_COINC; 
--      end if;
--    end if;
--  end process;  

  -- Latch TRIGGER_PATTERN on positive edge of COINC
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TMP = '1' and COINC_DEL = '0' then
        TRIGGER_PATTERN(0) <= ML1;
        TRIGGER_PATTERN(1) <= MH1;
        TRIGGER_PATTERN(2) <= ML2;
        TRIGGER_PATTERN(3) <= MH2;
        TRIGGER_PATTERN(4) <= SL1;
        TRIGGER_PATTERN(5) <= SH1;
        TRIGGER_PATTERN(6) <= SL2;
        TRIGGER_PATTERN(7) <= SH2;
        TRIGGER_PATTERN(8) <= EXT_TR;
        TRIGGER_PATTERN(9) <= MASTER;
        TRIGGER_PATTERN(10) <= SLAVE_PRESENT;
        TRIGGER_PATTERN(11) <= COMPL1;
        TRIGGER_PATTERN(12) <= COMPH1;
        TRIGGER_PATTERN(13) <= COMPL2;
        TRIGGER_PATTERN(14) <= COMPH2;
        TRIGGER_PATTERN(15) <= '0';
	  end if;        
    end if;
  end process;  


end rtl ; -- of TRIGGER_MATRIX

--------------------------------------------------------------------------------
-- Entity declaration of 'LED_DRIVER'.
-- Last modified : Mon Apr 23 09:04:31 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity LED_DRIVER is
  port(
    CLK10MHz : in     std_logic;
    INP      : in     std_logic;
    SYSRST   : in     std_logic;
    nOUTP    : out    std_logic);
end LED_DRIVER ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'LED_DRIVER'
-- Last modified : Mon Apr 23 09:04:31 2007.
--------------------------------------------------------------------------------

architecture rtl of LED_DRIVER is

signal LEDSHINE_COUNTER: std_logic_vector(20 downto 0); -- Full is about 0.2 seconds

begin
    
  process(CLK10MHz,SYSRST,INP)
  begin
    if SYSRST = '1' or INP = '1' then
      LEDSHINE_COUNTER <= "000000000000000000000";
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if LEDSHINE_COUNTER /= "111111111111111111111" then
        LEDSHINE_COUNTER <= LEDSHINE_COUNTER + "000000000000000000001";
      else   
        LEDSHINE_COUNTER <= LEDSHINE_COUNTER; -- locks at full
      end if;
    end if;
  end process;  

  nOUTP <= '0' when LEDSHINE_COUNTER /= "111111111111111111111" else '1'; 


end rtl ; -- of LED_DRIVER

--------------------------------------------------------------------------------
-- Entity declaration of 'CLK_DIV'.
-- Last modified : Mon Jul 16 21:42:48 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity CLK_DIV is
  port(
    CLK10MHz : in     std_logic;
    CLKRD    : out    std_logic;
    RST      : in     std_logic);
end CLK_DIV ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'CLK_DIV'
-- Last modified : Mon Jul 16 21:42:48 2007.
--------------------------------------------------------------------------------

architecture rtl of CLK_DIV is

signal CLKRD_TMP: std_logic;

begin
  CLKRD <= CLKRD_TMP;

  process(CLK10MHz,RST)
  begin
  	if RST = '0' then
  	  CLKRD_TMP <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '0') then -- let op: CLKRD gaat op een negatieve flank
  	  CLKRD_TMP <=  not CLKRD_TMP;
    end if;
  end process;

end rtl ; -- of CLK_DIV

--------------------------------------------------------------------------------
-- Entity declaration of 'EVENT_DATA_HANDLER'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity EVENT_DATA_HANDLER is
  port(
    CLKRD           : in     std_logic;
    DATA_IN         : in     std_logic_vector(7 downto 0);
    DATA_READY      : in     std_logic;
    DATA_READY_FIFO : in     std_logic;
    DIN_VALID       : in     std_logic;
    RDEN            : out    std_logic;
    READOUT_BUSY    : out    std_logic;
    SYSRST          : in     std_logic;
    USB_DATA        : out    std_logic_vector(7 downto 0);
    WR              : in     std_logic;
    WR_EN           : out    std_logic);
end EVENT_DATA_HANDLER ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'EVENT_DATA_HANDLER'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of EVENT_DATA_HANDLER is

signal RDEN_TMP: std_logic ;
signal VALID_BUF1: std_logic ;
signal VALID_BUF1_DEL1: std_logic ;
signal VALID_BUF1_DEL2: std_logic ;
signal VALID_BUF2: std_logic ;
signal RST_VALID_BUF1: std_logic ;
signal RST_VALID_BUF2: std_logic ;
signal DATA_BUF1: std_logic_vector(7 downto 0) ;
signal DATA_BUF2: std_logic_vector(7 downto 0) ;
signal USB_DATA_TMP: std_logic_vector(7 downto 0) ;

begin

  RDEN <= RDEN_TMP;
  USB_DATA <= USB_DATA_TMP;
  READOUT_BUSY <= DATA_READY_FIFO or VALID_BUF1;
  WR_EN <= VALID_BUF1_DEL2 or VALID_BUF2;
  
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  VALID_BUF1_DEL1 <= '0';
  	  VALID_BUF1_DEL2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then 
  	  if RST_VALID_BUF1 = '1' then
  	    VALID_BUF1_DEL1 <= '0';
  	    VALID_BUF1_DEL2 <= '0';
  	  else
        VALID_BUF1_DEL1 <= VALID_BUF1;
        VALID_BUF1_DEL2 <= VALID_BUF1_DEL1;
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  RDEN_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '0') then -- RDEN changes on a negative clock edge
  	  if DATA_READY = '1' then
	    if VALID_BUF1 = '0' then
          RDEN_TMP <= not RDEN_TMP;
        else
          RDEN_TMP <= '0';
        end if;
      else
        RDEN_TMP <= '0';
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  DATA_BUF1 <= "00000000";
  	  DATA_BUF2 <= "00000000";
  	  VALID_BUF1 <= '0';
  	  VALID_BUF2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then 
  	  if RST_VALID_BUF1 = '1' then
  	    VALID_BUF1 <= '0';
  	  elsif DIN_VALID = '1' then
  	    DATA_BUF1 <= DATA_IN;
  	    VALID_BUF1 <= DIN_VALID;
      end if;
  	  if RST_VALID_BUF2 = '1' then
  	    VALID_BUF2 <= '0';
      elsif DIN_VALID = '1' and VALID_BUF1 = '1' then
  	    VALID_BUF2 <= VALID_BUF1;
  	    DATA_BUF2 <= DATA_BUF1;
      end if;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  RST_VALID_BUF1 <= '0';
  	  RST_VALID_BUF2 <= '0';
    elsif (CLKRD'event and CLKRD = '0') then 
  	  if WR = '1' then 
        if VALID_BUF2  = '1' then
          RST_VALID_BUF2 <= '1';
        elsif VALID_BUF1_DEL2  = '1' then
          RST_VALID_BUF1 <= '1';
        end if;
      else
  	    RST_VALID_BUF1 <= '0';
  	    RST_VALID_BUF2 <= '0';
      end if;
    end if;
  end process;
          
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  USB_DATA_TMP <= "00000000";
    elsif (CLKRD'event and CLKRD = '1') then 
      if VALID_BUF2 = '1' then
        USB_DATA_TMP <= DATA_BUF2;
      elsif VALID_BUF1 = '1' then
        USB_DATA_TMP <= DATA_BUF1;
      else
        USB_DATA_TMP <= USB_DATA_TMP;        
      end if;
    end if;
  end process;

end rtl ; -- of EVENT_DATA_HANDLER

--------------------------------------------------------------------------------
-- Entity declaration of 'USB_WRITE_HANDLER'.
-- Last modified : Wed Jul 18 11:22:51 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity USB_WRITE_HANDLER is
  port(
    ALTITUDE                    : in     std_logic_vector(63 downto 0);
    CLK10MHz                    : in     std_logic;
    CLKRD                       : in     std_logic;
    COINC_TIME                  : in     std_logic_vector(15 downto 0);
    COMPDATA                    : in     std_logic_vector(127 downto 0);
    COMPDATA_READOUT_DONE       : out    std_logic;
    COMPDATA_VALID              : in     std_logic;
    CTD_IN                      : in     std_logic_vector(31 downto 0);
    CTD_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
    CTP_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
    EVENT_DATA_IN               : in     std_logic_vector(7 downto 0);
    EVENT_READOUT_BUSY          : in     std_logic;
    EVENT_WR                    : out    std_logic;
    EVENT_WR_EN                 : in     std_logic;
    GPS_TS_IN                   : in     std_logic_vector(55 downto 0);
    GPS_TS_ONE_PPS              : in     std_logic_vector(55 downto 0);
    LATITUDE                    : in     std_logic_vector(63 downto 0);
    LONGITUDE                   : in     std_logic_vector(63 downto 0);
    NEW_DATA_WHILE_READOUT      : out    std_logic;
    PARAMETER_LIST              : in     std_logic_vector(271 downto 0);
    PARAMETER_LIST_READOUT_DONE : out    std_logic;
    PARAMETER_LIST_VALID        : in     std_logic;
    POST_TIME                   : in     std_logic_vector(15 downto 0);
    PRE_TIME                    : in     std_logic_vector(15 downto 0);
    READ_ERROR_DATA             : in     std_logic_vector(7 downto 0);
    READ_ERROR_READOUT_DONE     : out    std_logic;
    READ_ERROR_VALID            : in     std_logic;
    SAT_INFO                    : in     std_logic_vector(487 downto 0);
    SECOND_MESSAGE_ALLOWED      : in     std_logic;
    SEND_EVENT_DATA             : out    std_logic;
    START_WRITE_EVENT           : in     std_logic;
    SYSRST                      : in     std_logic;
    TEMP                        : in     std_logic_vector(31 downto 0);
    TH_COUNTERS_IN              : in     std_logic_vector(63 downto 0);
    TRIGGER_PATTERN             : in     std_logic_vector(15 downto 0);
    TR_CONDITION                : in     std_logic_vector(7 downto 0);
    TS_ONE_PPS_READOUT_DONE     : out    std_logic;
    TS_ONE_PPS_VALID_INPUT      : in     std_logic;
    USB_DATA_OUT                : out    std_logic_vector(7 downto 0);
    USB_TXE                     : in     std_logic;
    USB_WR                      : out    std_logic;
    USB_WRITE_BUSY              : out    std_logic;
    USB_WRITE_ENABLE            : in     std_logic;
    USB_WRITE_REQUEST           : out    std_logic);
end USB_WRITE_HANDLER ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'USB_WRITE_HANDLER'
-- Last modified : Wed Jul 18 11:22:51 2007.
--------------------------------------------------------------------------------

architecture rtl of USB_WRITE_HANDLER is

signal WR_TMP: std_logic ;
signal WRITE_EVENT_MODE: std_logic ; -- True when event data is send to computer
signal WRITE_EVENT_MODE_DEL: std_logic ; 
signal WRITE_GPS_MODE: std_logic ; -- True when data of GPS counters is send to computer
signal WRITE_GPS_MODE_DEL: std_logic ;  
signal WRITE_PARAMETER_LIST_MODE: std_logic ; -- True when PARAMETER_LIST is send to computer
signal WRITE_PARAMETER_LIST_MODE_DEL: std_logic ;  
signal WRITE_READ_ERROR_MODE: std_logic ; -- True when READ_ERROR data is send to computer
signal WRITE_READ_ERROR_MODE_DEL: std_logic ;  
signal WRITE_COMP_MODE: std_logic ; -- True when data of comperators is send to computer
signal WRITE_COMP_MODE_DEL: std_logic ;  
signal START_WRITE_EVENT_PRIOR: std_logic ; 
signal START_WRITE_EVENT_PRIOR_DEL: std_logic ; 
signal START_WRITE_GPS_COUNT_PRIOR: std_logic ; 
signal START_WRITE_GPS_COUNT_PRIOR_DEL: std_logic ; 
signal START_WRITE_PARAMETER_LIST_PRIOR: std_logic ; 
signal START_WRITE_PARAMETER_LIST_PRIOR_DEL: std_logic ; 
signal START_WRITE_READ_ERROR_PRIOR: std_logic ; 
signal START_WRITE_READ_ERROR_PRIOR_DEL: std_logic ; 
signal START_WRITE_COMP_DATA_PRIOR: std_logic ; 
signal START_WRITE_COMP_DATA_PRIOR_DEL: std_logic ; 
signal ADDITIONAL_DATA_COUNT: integer range 22 downto 0;
signal WRITE_ENABLE_ADDITIONAL_DATA: std_logic ; 
signal WRITE_ENABLE_ADDITIONAL_DATA_DEL1: std_logic ; 
signal WR_ADDITIONAL_DATA: std_logic ; 
signal WR_ADDITIONAL_DATA_DEL: std_logic ; 
signal USB_WR_EN: std_logic ; 
signal EVENT_READOUT_BUSY_DEL: std_logic ; 
signal SEND_EVENT_DATA_TMP: std_logic ; 
signal WR_END_BYTE: std_logic ; 
signal WR_END_BYTE_DEL: std_logic ; 
signal WR_END_BYTE_ENABLE: std_logic ; 
signal WR_END_BYTE_ENABLE_DEL1: std_logic ; 
signal ADDITIONAL_DATA_TMP: std_logic_vector(7 downto 0); 
signal USB_DATA_PRE: std_logic_vector(7 downto 0); 
signal USB_DATA: std_logic_vector(7 downto 0); 
signal USB_DATA_MODE_PRE: std_logic_vector(2 downto 0); 
signal USB_DATA_MODE: std_logic_vector(4 downto 0); 
signal WR_GPS_DATA_ENABLE: std_logic ; 
signal WR_GPS_DATA_ENABLE_DEL: std_logic ; 
signal GPS_DATA_COUNT: integer range 87 downto 0;
signal GPS_DATA_TMP: std_logic_vector(7 downto 0); 
signal WR_GPS_DATA: std_logic ; 
signal WR_GPS_DATA_DEL: std_logic ; 
signal WR_PARAMETER_LIST_ENABLE: std_logic ; 
signal WR_PARAMETER_LIST_ENABLE_DEL: std_logic ; 
signal PARAMETER_LIST_COUNT: integer range 79 downto 0;
signal WR_PARAMETER_LIST: std_logic ; 
signal WR_PARAMETER_LIST_DEL: std_logic ; 
signal PARAMETER_LIST_TMP: std_logic_vector(7 downto 0); 
signal WR_READ_ERROR_ENABLE: std_logic ; 
signal WR_READ_ERROR_ENABLE_DEL: std_logic ; 
signal READ_ERROR_COUNT: integer range 4 downto 0;
signal WR_READ_ERROR: std_logic ; 
signal WR_READ_ERROR_DEL: std_logic ; 
signal READ_ERROR_TMP: std_logic_vector(7 downto 0); 
signal WR_COMP_DATA_ENABLE: std_logic ; 
signal WR_COMP_DATA_ENABLE_DEL: std_logic ; 
signal COMP_DATA_COUNT: integer range 19 downto 0;
signal COMP_DATA_TMP: std_logic_vector(7 downto 0); 
signal WR_COMP_DATA: std_logic ; 
signal WR_COMP_DATA_DEL: std_logic ; 

signal TS_ONE_PPS_VALID_IN: std_logic ; 
signal TS_ONE_PPS_VALID_IN_DEL: std_logic ; 
signal START_WRITE_EVENT_DEL: std_logic ; 
signal PARAMETER_LIST_VALID_DEL: std_logic ; 
signal READ_ERROR_VALID_DEL: std_logic ; 
signal COMPDATA_VALID_DEL: std_logic ; 
signal USB_WRITE_BUSY_TMP: std_logic ; 


begin

  TS_ONE_PPS_VALID_IN <= TS_ONE_PPS_VALID_INPUT and SECOND_MESSAGE_ALLOWED; -- Enable One second message with bit 1 of spare bytes

  USB_WRITE_REQUEST <= TS_ONE_PPS_VALID_IN or START_WRITE_EVENT or PARAMETER_LIST_VALID or READ_ERROR_VALID or COMPDATA_VALID;
  USB_WRITE_BUSY_TMP <= WRITE_EVENT_MODE or WRITE_GPS_MODE or WRITE_PARAMETER_LIST_MODE or WRITE_READ_ERROR_MODE or WRITE_COMP_MODE;
  USB_WRITE_BUSY <= USB_WRITE_BUSY_TMP;
  USB_WR <= WR_TMP;
  USB_WR_EN <= WRITE_ENABLE_ADDITIONAL_DATA or EVENT_WR_EN or WR_END_BYTE_ENABLE or WR_GPS_DATA_ENABLE or WR_PARAMETER_LIST_ENABLE or WR_READ_ERROR_ENABLE or WR_COMP_DATA_ENABLE;
  SEND_EVENT_DATA <= SEND_EVENT_DATA_TMP;
  WR_ADDITIONAL_DATA <= WR_TMP when WRITE_ENABLE_ADDITIONAL_DATA = '1' else '0';
  EVENT_WR <= WR_TMP when SEND_EVENT_DATA_TMP = '1' else '0';
  WR_END_BYTE <= WR_TMP when WR_END_BYTE_ENABLE = '1' else '0';
  USB_DATA_MODE_PRE(0) <= WRITE_ENABLE_ADDITIONAL_DATA;
  USB_DATA_MODE_PRE(1) <= SEND_EVENT_DATA_TMP;
  USB_DATA_MODE_PRE(2) <= WR_END_BYTE_ENABLE;
  USB_DATA_MODE(0) <= WRITE_ENABLE_ADDITIONAL_DATA or SEND_EVENT_DATA_TMP or WR_END_BYTE_ENABLE;
  USB_DATA_MODE(1) <= WR_GPS_DATA_ENABLE;
  USB_DATA_MODE(2) <= WR_PARAMETER_LIST_ENABLE;
  USB_DATA_MODE(3) <= WR_READ_ERROR_ENABLE;
  USB_DATA_MODE(4) <= WR_COMP_DATA_ENABLE;
  WR_GPS_DATA <= WR_TMP when WR_GPS_DATA_ENABLE = '1' else '0';
  TS_ONE_PPS_READOUT_DONE <= not WR_GPS_DATA_ENABLE and WR_GPS_DATA_ENABLE_DEL;
  WR_PARAMETER_LIST <= WR_TMP when WR_PARAMETER_LIST_ENABLE = '1' else '0';
  PARAMETER_LIST_READOUT_DONE <= not WR_PARAMETER_LIST_ENABLE and WR_PARAMETER_LIST_ENABLE_DEL;
  WR_READ_ERROR <= WR_TMP when WR_READ_ERROR_ENABLE = '1' else '0';
  READ_ERROR_READOUT_DONE <= not WR_READ_ERROR_ENABLE and WR_READ_ERROR_ENABLE_DEL;
  WR_COMP_DATA <= WR_TMP when WR_COMP_DATA_ENABLE = '1' else '0';
  COMPDATA_READOUT_DONE <= not WR_COMP_DATA_ENABLE and WR_COMP_DATA_ENABLE_DEL;
  
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WRITE_EVENT_MODE_DEL <= '0';
  	  WRITE_ENABLE_ADDITIONAL_DATA_DEL1 <= '0';
  	  EVENT_READOUT_BUSY_DEL <= '0';
  	  WR_END_BYTE_ENABLE_DEL1 <= '0';
  	  START_WRITE_EVENT_PRIOR_DEL <= '0';
  	  START_WRITE_GPS_COUNT_PRIOR_DEL <= '0';
  	  START_WRITE_PARAMETER_LIST_PRIOR_DEL <= '0';
  	  START_WRITE_READ_ERROR_PRIOR_DEL <= '0';
  	  START_WRITE_COMP_DATA_PRIOR_DEL <= '0';
  	  WRITE_GPS_MODE_DEL <= '0';
  	  WR_GPS_DATA_ENABLE_DEL <= '0';
  	  WRITE_PARAMETER_LIST_MODE_DEL <= '0';
  	  WR_PARAMETER_LIST_ENABLE_DEL <= '0';
  	  WRITE_READ_ERROR_MODE_DEL <= '0';
  	  WR_READ_ERROR_ENABLE_DEL <= '0';
  	  WRITE_COMP_MODE_DEL <= '0';
  	  WR_COMP_DATA_ENABLE_DEL <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
  	  WRITE_EVENT_MODE_DEL <= WRITE_EVENT_MODE;
  	  WRITE_ENABLE_ADDITIONAL_DATA_DEL1 <= WRITE_ENABLE_ADDITIONAL_DATA;
  	  EVENT_READOUT_BUSY_DEL <= EVENT_READOUT_BUSY;
  	  WR_END_BYTE_ENABLE_DEL1 <= WR_END_BYTE_ENABLE;
  	  START_WRITE_EVENT_PRIOR_DEL <= START_WRITE_EVENT_PRIOR;
  	  START_WRITE_GPS_COUNT_PRIOR_DEL <= START_WRITE_GPS_COUNT_PRIOR;
  	  START_WRITE_PARAMETER_LIST_PRIOR_DEL <= START_WRITE_PARAMETER_LIST_PRIOR;
  	  START_WRITE_READ_ERROR_PRIOR_DEL <= START_WRITE_READ_ERROR_PRIOR;
  	  START_WRITE_COMP_DATA_PRIOR_DEL <= START_WRITE_COMP_DATA_PRIOR;
  	  WRITE_GPS_MODE_DEL <= WRITE_GPS_MODE;
  	  WR_GPS_DATA_ENABLE_DEL <= WR_GPS_DATA_ENABLE;
  	  WRITE_PARAMETER_LIST_MODE_DEL <= WRITE_PARAMETER_LIST_MODE;
  	  WR_PARAMETER_LIST_ENABLE_DEL <= WR_PARAMETER_LIST_ENABLE;
  	  WRITE_READ_ERROR_MODE_DEL <= WRITE_READ_ERROR_MODE;
  	  WR_READ_ERROR_ENABLE_DEL <= WR_READ_ERROR_ENABLE;
  	  WRITE_COMP_MODE_DEL <= WRITE_COMP_MODE;
  	  WR_COMP_DATA_ENABLE_DEL <= WR_COMP_DATA_ENABLE;
    end if;
  end process;

  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  TS_ONE_PPS_VALID_IN_DEL <= '0';
  	  START_WRITE_EVENT_DEL <= '0';
  	  PARAMETER_LIST_VALID_DEL <= '0';
  	  READ_ERROR_VALID_DEL <= '0';
  	  COMPDATA_VALID_DEL <= '0';
  	  NEW_DATA_WHILE_READOUT <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
  	  TS_ONE_PPS_VALID_IN_DEL <= TS_ONE_PPS_VALID_IN;
  	  START_WRITE_EVENT_DEL <= START_WRITE_EVENT;
  	  PARAMETER_LIST_VALID_DEL <= PARAMETER_LIST_VALID;
  	  READ_ERROR_VALID_DEL <= READ_ERROR_VALID;
  	  COMPDATA_VALID_DEL <= COMPDATA_VALID;
  	  if USB_WRITE_BUSY_TMP = '1' and 
  	   ((TS_ONE_PPS_VALID_IN = '1' and TS_ONE_PPS_VALID_IN_DEL = '0') or 
  	    (START_WRITE_EVENT = '1' and START_WRITE_EVENT_DEL = '0') or 
  	    (PARAMETER_LIST_VALID = '1' and PARAMETER_LIST_VALID_DEL = '0') or 
  	    (READ_ERROR_VALID = '1' and READ_ERROR_VALID_DEL = '0') or 
  	    (COMPDATA_VALID = '1' and COMPDATA_VALID_DEL = '0')) then
  	    NEW_DATA_WHILE_READOUT <= '1';
  	  else   
  	    NEW_DATA_WHILE_READOUT <= '0';
      end if;
    end if;
  end process;
 
  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
      WR_ADDITIONAL_DATA_DEL <= '0';
      WR_END_BYTE_DEL <= '0';
      WR_GPS_DATA_DEL <= '0';
      WR_PARAMETER_LIST_DEL <= '0';
      WR_READ_ERROR_DEL <= '0';
      WR_COMP_DATA_DEL <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
  	  WR_ADDITIONAL_DATA_DEL <= WR_ADDITIONAL_DATA;
  	  WR_END_BYTE_DEL <= WR_END_BYTE;
  	  WR_GPS_DATA_DEL <= WR_GPS_DATA;
  	  WR_PARAMETER_LIST_DEL <= WR_PARAMETER_LIST;
  	  WR_READ_ERROR_DEL <= WR_READ_ERROR;
  	  WR_COMP_DATA_DEL <= WR_COMP_DATA;
    end if;
  end process;

  -- Priority encoding for writing to USB
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
   	  START_WRITE_EVENT_PRIOR <= '0';
      START_WRITE_GPS_COUNT_PRIOR <= '0'; 
      START_WRITE_PARAMETER_LIST_PRIOR <= '0'; 
      START_WRITE_READ_ERROR_PRIOR <= '0'; 
      START_WRITE_COMP_DATA_PRIOR <= '0'; 
    elsif (CLKRD'event and CLKRD = '1') then 
      if WRITE_EVENT_MODE = '0' and WRITE_GPS_MODE = '0' and WRITE_COMP_MODE = '0' and WRITE_PARAMETER_LIST_MODE = '0' and WRITE_READ_ERROR_MODE = '0' and USB_WRITE_ENABLE = '1' then  -- if there is no writing to USB
        if TS_ONE_PPS_VALID_IN = '1' then -- Start WRITE_GPS_MODE
          START_WRITE_GPS_COUNT_PRIOR <= '1'; 
        elsif START_WRITE_EVENT = '1' then -- Start WRITE_EVENT_MODE
          START_WRITE_EVENT_PRIOR <= '1'; 
        elsif COMPDATA_VALID = '1' then -- Start WRITE_COMP_MODE
          START_WRITE_COMP_DATA_PRIOR <= '1'; 
        elsif PARAMETER_LIST_VALID = '1' then -- Start WRITE_PARAMETER_LIST_MODE
          START_WRITE_PARAMETER_LIST_PRIOR <= '1'; 
        elsif READ_ERROR_VALID = '1' then -- Start WRITE_READ_ERROR_MODE
          START_WRITE_READ_ERROR_PRIOR <= '1'; 
        end if;
      else  
  	    START_WRITE_EVENT_PRIOR <= '0';
        START_WRITE_GPS_COUNT_PRIOR <= '0'; 
        START_WRITE_PARAMETER_LIST_PRIOR <= '0'; 
        START_WRITE_READ_ERROR_PRIOR <= '0'; 
        START_WRITE_COMP_DATA_PRIOR <= '0'; 
      end if;
    end if;
  end process;

---------------------------------- Write event data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WRITE_EVENT_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
  	  if WR_END_BYTE_ENABLE = '0' and WR_END_BYTE_ENABLE_DEL1 = '1' then -- At downgoing edge of WR_END_BYTE_ENABLE
  	    WRITE_EVENT_MODE <= '0';
      elsif WRITE_EVENT_MODE = '1' then -- WRITE_EVENT_MODE locks itself
  	    WRITE_EVENT_MODE <= WRITE_EVENT_MODE;
      elsif START_WRITE_EVENT_PRIOR = '1' and START_WRITE_EVENT_PRIOR_DEL = '0' then -- Start WRITE_EVENT_MODE
  	    WRITE_EVENT_MODE <= '1';
      end if;
    end if;
  end process;

  -- Write ADDITIONAL_DATA
  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  ADDITIONAL_DATA_COUNT <= 22;
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_EVENT_MODE = '1' and WRITE_EVENT_MODE_DEL = '0' then  -- upgoing edge of WRITE_EVENT_MODE
  	    ADDITIONAL_DATA_COUNT <= 22;
      elsif WR_ADDITIONAL_DATA = '1' and WR_ADDITIONAL_DATA_DEL = '0' then  -- upgoing edge of WR_ADDITIONAL_DATA
        ADDITIONAL_DATA_COUNT <= ADDITIONAL_DATA_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WRITE_ENABLE_ADDITIONAL_DATA <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_EVENT_MODE = '1' and WRITE_EVENT_MODE_DEL = '0' then  -- upgoing edge of WRITE_EVENT_MODE
  	    WRITE_ENABLE_ADDITIONAL_DATA <= '1';
      elsif WR_ADDITIONAL_DATA = '0' and WR_ADDITIONAL_DATA_DEL = '1' and ADDITIONAL_DATA_COUNT = 0 then  -- downgoing edge of WR_ADDITIONAL_DATA
  	    WRITE_ENABLE_ADDITIONAL_DATA <= '0';
      end if;
    end if;
  end process;

  -- Write event data
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  SEND_EVENT_DATA_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
      if WRITE_ENABLE_ADDITIONAL_DATA = '0' and WRITE_ENABLE_ADDITIONAL_DATA_DEL1 = '1' then  -- downgoing edge of WRITE_ENABLE_TRIGGER_PATTERN
  	    SEND_EVENT_DATA_TMP <= '1';
      elsif EVENT_READOUT_BUSY = '0' and EVENT_READOUT_BUSY_DEL = '1' then  -- downgoing edge of EVENT_READOUT_BUSY
  	    SEND_EVENT_DATA_TMP <= '0';
      end if;
    end if;
  end process;

  -- Write end byte
  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WR_END_BYTE_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if EVENT_READOUT_BUSY = '0' and EVENT_READOUT_BUSY_DEL = '1' then  -- downgoing edge of EVENT_READOUT_BUSY
  	    WR_END_BYTE_ENABLE <= '1';
      elsif WR_END_BYTE = '0' and WR_END_BYTE_DEL = '1' then  -- downgoing edge of WR_END_BYTE
  	    WR_END_BYTE_ENABLE <= '0';
      end if;
    end if;
  end process;


  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WR_TMP <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
  	  if USB_WR_EN = '1' then
   	    if USB_TXE = '0' then
          WR_TMP <= not WR_TMP;
        else  
          WR_TMP <= '0';
		end if;
	  else 
        WR_TMP <= '0';
      end if;
    end if;
  end process;

  process(ADDITIONAL_DATA_COUNT,TR_CONDITION,TRIGGER_PATTERN,PRE_TIME,COINC_TIME,POST_TIME,GPS_TS_IN,CTD_IN)
  begin
    case (ADDITIONAL_DATA_COUNT) is
      when 21 => ADDITIONAL_DATA_TMP <= "10011001"; -- 99h
      when 20 => ADDITIONAL_DATA_TMP <= "10100000"; -- A0h
      when 19 => ADDITIONAL_DATA_TMP <= TR_CONDITION; 
      when 18 => ADDITIONAL_DATA_TMP <= TRIGGER_PATTERN(15 downto 8); 
      when 17 => ADDITIONAL_DATA_TMP <= TRIGGER_PATTERN(7 downto 0); 
      when 16 => ADDITIONAL_DATA_TMP <= PRE_TIME(15 downto 8); 
      when 15 => ADDITIONAL_DATA_TMP <= PRE_TIME(7 downto 0); 
      when 14 => ADDITIONAL_DATA_TMP <= COINC_TIME(15 downto 8); 
      when 13 => ADDITIONAL_DATA_TMP <= COINC_TIME(7 downto 0); 
      when 12 => ADDITIONAL_DATA_TMP <= POST_TIME(15 downto 8); 
      when 11 => ADDITIONAL_DATA_TMP <= POST_TIME(7 downto 0); 
      when 10 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(55 downto 48); 
      when 9 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(47 downto 40); 
      when 8 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(39 downto 32); 
      when 7 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(31 downto 24); 
      when 6 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(23 downto 16); 
      when 5 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(15 downto 8); 
      when 4 => ADDITIONAL_DATA_TMP <= GPS_TS_IN(7 downto 0); 
      when 3 => ADDITIONAL_DATA_TMP <= CTD_IN(31 downto 24); 
      when 2 => ADDITIONAL_DATA_TMP <= CTD_IN(23 downto 16); 
      when 1 => ADDITIONAL_DATA_TMP <= CTD_IN(15 downto 8); 
      when 0 => ADDITIONAL_DATA_TMP <= CTD_IN(7 downto 0); 
      when others => ADDITIONAL_DATA_TMP <= "00000000";
    end case;
  end process;

  process(USB_DATA_MODE_PRE,ADDITIONAL_DATA_TMP,EVENT_DATA_IN)
  begin
    case (USB_DATA_MODE_PRE) is
      when "001" => USB_DATA_PRE <= ADDITIONAL_DATA_TMP; 
      when "010" => USB_DATA_PRE <= EVENT_DATA_IN; 
      when "100" => USB_DATA_PRE <= "01100110"; -- 66h
      when others => USB_DATA_PRE <= "00000000";
    end case;
  end process;


---------------------------------- GPS counter data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WRITE_GPS_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
      if WR_GPS_DATA_ENABLE = '0' and WR_GPS_DATA_ENABLE_DEL = '1' then -- At downgoing edge of WR_GPS_DATA_ENABLE
  	    WRITE_GPS_MODE <= '0';
      elsif WRITE_GPS_MODE = '1' then -- WRITE_GPS_MODE locks itself
  	    WRITE_GPS_MODE <= WRITE_GPS_MODE;
      elsif START_WRITE_GPS_COUNT_PRIOR = '1' and START_WRITE_GPS_COUNT_PRIOR_DEL = '0' then -- Start WRITE_GPS_MODE
  	    WRITE_GPS_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  GPS_DATA_COUNT <= 87;
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_GPS_MODE = '1' and WRITE_GPS_MODE_DEL = '0' then  -- upgoing edge of WRITE_GPS_MODE
  	    GPS_DATA_COUNT <= 87;
      elsif WR_GPS_DATA = '1' and WR_GPS_DATA_DEL = '0' then  -- upgoing edge of WR_GPS_DATA
        GPS_DATA_COUNT <= GPS_DATA_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WR_GPS_DATA_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_GPS_MODE = '1' and WRITE_GPS_MODE_DEL = '0' then  -- upgoing edge of WRITE_GPS_MODE
  	    WR_GPS_DATA_ENABLE <= '1';
      elsif WR_GPS_DATA = '0' and WR_GPS_DATA_DEL = '1' and GPS_DATA_COUNT = 0 then  -- downgoing edge of WR_GPS_DATA
  	    WR_GPS_DATA_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(GPS_DATA_COUNT,GPS_TS_ONE_PPS,CTP_TS_ONE_PPS,CTD_TS_ONE_PPS,TH_COUNTERS_IN,SAT_INFO)
  begin
    case (GPS_DATA_COUNT) is
      when 86 => GPS_DATA_TMP <= "10011001"; -- 99h
      when 85 => GPS_DATA_TMP <= "10100100"; -- A4h
      when 84 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(55 downto 48); 
      when 83 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(47 downto 40); 
      when 82 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(39 downto 32); 
      when 81 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(31 downto 24); 
      when 80 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(23 downto 16); 
      when 79 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(15 downto 8); 
      when 78 => GPS_DATA_TMP <= GPS_TS_ONE_PPS(7 downto 0); 
      when 77 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(31 downto 24); 
      when 76 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(23 downto 16); 
      when 75 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(15 downto 8); 
      when 74 => GPS_DATA_TMP <= CTP_TS_ONE_PPS(7 downto 0); 
      when 73 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(31 downto 24); 
      when 72 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(23 downto 16); 
      when 71 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(15 downto 8); 
      when 70 => GPS_DATA_TMP <= CTD_TS_ONE_PPS(7 downto 0); 
      when 69 => GPS_DATA_TMP <= TH_COUNTERS_IN(63 downto 56); 
      when 68 => GPS_DATA_TMP <= TH_COUNTERS_IN(55 downto 48); 
      when 67 => GPS_DATA_TMP <= TH_COUNTERS_IN(47 downto 40); 
      when 66 => GPS_DATA_TMP <= TH_COUNTERS_IN(39 downto 32); 
      when 65 => GPS_DATA_TMP <= TH_COUNTERS_IN(31 downto 24); 
      when 64 => GPS_DATA_TMP <= TH_COUNTERS_IN(23 downto 16); 
      when 63 => GPS_DATA_TMP <= TH_COUNTERS_IN(15 downto 8); 
      when 62 => GPS_DATA_TMP <= TH_COUNTERS_IN(7 downto 0); 
      when 61 => GPS_DATA_TMP <= SAT_INFO(487 downto 480); 
      when 60 => GPS_DATA_TMP <= SAT_INFO(479 downto 472); 
      when 59 => GPS_DATA_TMP <= SAT_INFO(471 downto 464); 
      when 58 => GPS_DATA_TMP <= SAT_INFO(463 downto 456); 
      when 57 => GPS_DATA_TMP <= SAT_INFO(455 downto 448); 
      when 56 => GPS_DATA_TMP <= SAT_INFO(447 downto 440); 
      when 55 => GPS_DATA_TMP <= SAT_INFO(439 downto 432); 
      when 54 => GPS_DATA_TMP <= SAT_INFO(431 downto 424); 
      when 53 => GPS_DATA_TMP <= SAT_INFO(423 downto 416); 
      when 52 => GPS_DATA_TMP <= SAT_INFO(415 downto 408); 
      when 51 => GPS_DATA_TMP <= SAT_INFO(407 downto 400); 
      when 50 => GPS_DATA_TMP <= SAT_INFO(399 downto 392); 
      when 49 => GPS_DATA_TMP <= SAT_INFO(391 downto 384); 
      when 48 => GPS_DATA_TMP <= SAT_INFO(383 downto 376); 
      when 47 => GPS_DATA_TMP <= SAT_INFO(375 downto 368); 
      when 46 => GPS_DATA_TMP <= SAT_INFO(367 downto 360); 
      when 45 => GPS_DATA_TMP <= SAT_INFO(359 downto 352); 
      when 44 => GPS_DATA_TMP <= SAT_INFO(351 downto 344); 
      when 43 => GPS_DATA_TMP <= SAT_INFO(343 downto 336); 
      when 42 => GPS_DATA_TMP <= SAT_INFO(335 downto 328); 
      when 41 => GPS_DATA_TMP <= SAT_INFO(327 downto 320); 
      when 40 => GPS_DATA_TMP <= SAT_INFO(319 downto 312); 
      when 39 => GPS_DATA_TMP <= SAT_INFO(311 downto 304); 
      when 38 => GPS_DATA_TMP <= SAT_INFO(303 downto 296); 
      when 37 => GPS_DATA_TMP <= SAT_INFO(295 downto 288); 
      when 36 => GPS_DATA_TMP <= SAT_INFO(287 downto 280); 
      when 35 => GPS_DATA_TMP <= SAT_INFO(279 downto 272); 
      when 34 => GPS_DATA_TMP <= SAT_INFO(271 downto 264); 
      when 33 => GPS_DATA_TMP <= SAT_INFO(263 downto 256); 
      when 32 => GPS_DATA_TMP <= SAT_INFO(255 downto 248); 
      when 31 => GPS_DATA_TMP <= SAT_INFO(247 downto 240); 
      when 30 => GPS_DATA_TMP <= SAT_INFO(239 downto 232); 
      when 29 => GPS_DATA_TMP <= SAT_INFO(231 downto 224); 
      when 28 => GPS_DATA_TMP <= SAT_INFO(223 downto 216); 
      when 27 => GPS_DATA_TMP <= SAT_INFO(215 downto 208); 
      when 26 => GPS_DATA_TMP <= SAT_INFO(207 downto 200); 
      when 25 => GPS_DATA_TMP <= SAT_INFO(199 downto 192); 
      when 24 => GPS_DATA_TMP <= SAT_INFO(191 downto 184); 
      when 23 => GPS_DATA_TMP <= SAT_INFO(183 downto 176); 
      when 22 => GPS_DATA_TMP <= SAT_INFO(175 downto 168); 
      when 21 => GPS_DATA_TMP <= SAT_INFO(167 downto 160); 
      when 20 => GPS_DATA_TMP <= SAT_INFO(159 downto 152); 
      when 19 => GPS_DATA_TMP <= SAT_INFO(151 downto 144); 
      when 18 => GPS_DATA_TMP <= SAT_INFO(143 downto 136); 
      when 17 => GPS_DATA_TMP <= SAT_INFO(135 downto 128); 
      when 16 => GPS_DATA_TMP <= SAT_INFO(127 downto 120); 
      when 15 => GPS_DATA_TMP <= SAT_INFO(119 downto 112); 
      when 14 => GPS_DATA_TMP <= SAT_INFO(111 downto 104); 
      when 13 => GPS_DATA_TMP <= SAT_INFO(103 downto 96); 
      when 12 => GPS_DATA_TMP <= SAT_INFO(95 downto 88); 
      when 11 => GPS_DATA_TMP <= SAT_INFO(87 downto 80); 
      when 10 => GPS_DATA_TMP <= SAT_INFO(79 downto 72); 
      when 9 => GPS_DATA_TMP <= SAT_INFO(71 downto 64); 
      when 8 => GPS_DATA_TMP <= SAT_INFO(63 downto 56); 
      when 7 => GPS_DATA_TMP <= SAT_INFO(55 downto 48); 
      when 6 => GPS_DATA_TMP <= SAT_INFO(47 downto 40); 
      when 5 => GPS_DATA_TMP <= SAT_INFO(39 downto 32); 
      when 4 => GPS_DATA_TMP <= SAT_INFO(31 downto 24); 
      when 3 => GPS_DATA_TMP <= SAT_INFO(23 downto 16); 
      when 2 => GPS_DATA_TMP <= SAT_INFO(15 downto 8); 
      when 1 => GPS_DATA_TMP <= SAT_INFO(7 downto 0); 
      when 0 => GPS_DATA_TMP <= "01100110"; -- 66h 
      when others => GPS_DATA_TMP <= "00000000";
    end case;
  end process;

---------------------------------- Comparator data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WRITE_COMP_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
      if WR_COMP_DATA_ENABLE = '0' and WR_COMP_DATA_ENABLE_DEL = '1' then -- At downgoing edge of WR_COMP_DATA_ENABLE
  	    WRITE_COMP_MODE <= '0';
      elsif WRITE_COMP_MODE = '1' then -- WRITE_GPS_MODE locks itself
  	    WRITE_COMP_MODE <= WRITE_COMP_MODE;
      elsif START_WRITE_COMP_DATA_PRIOR = '1' and START_WRITE_COMP_DATA_PRIOR_DEL = '0' then -- Start WRITE_COMP_MODE
  	    WRITE_COMP_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  COMP_DATA_COUNT <= 19;
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_COMP_MODE = '1' and WRITE_COMP_MODE_DEL = '0' then  -- upgoing edge of WRITE_COMP_MODE
  	    COMP_DATA_COUNT <= 19;
      elsif WR_COMP_DATA = '1' and WR_COMP_DATA_DEL = '0' then  -- upgoing edge of WR_COMP_DATA
        COMP_DATA_COUNT <= COMP_DATA_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WR_COMP_DATA_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_COMP_MODE = '1' and WRITE_COMP_MODE_DEL = '0' then  -- upgoing edge of WRITE_COMP_MODE
  	    WR_COMP_DATA_ENABLE <= '1';
      elsif WR_COMP_DATA = '0' and WR_COMP_DATA_DEL = '1' and COMP_DATA_COUNT = 0 then  -- downgoing edge of WR_COMP_DATA
  	    WR_COMP_DATA_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(COMP_DATA_COUNT,COMPDATA)
  begin
    case (COMP_DATA_COUNT) is
      when 18 => COMP_DATA_TMP <= "10011001"; -- 99h
      when 17 => COMP_DATA_TMP <= "10100010"; -- A2h
      when 16 => COMP_DATA_TMP <= COMPDATA(127 downto 120); 
      when 15 => COMP_DATA_TMP <= COMPDATA(119 downto 112); 
      when 14 => COMP_DATA_TMP <= COMPDATA(111 downto 104); 
      when 13 => COMP_DATA_TMP <= COMPDATA(103 downto 96); 
      when 12 => COMP_DATA_TMP <= COMPDATA(95 downto 88); 
      when 11 => COMP_DATA_TMP <= COMPDATA(87 downto 80); 
      when 10 => COMP_DATA_TMP <= COMPDATA(79 downto 72); 
      when 9 => COMP_DATA_TMP <= COMPDATA(71 downto 64); 
      when 8 => COMP_DATA_TMP <= COMPDATA(63 downto 56); 
      when 7 => COMP_DATA_TMP <= COMPDATA(55 downto 48); 
      when 6 => COMP_DATA_TMP <= COMPDATA(47 downto 40); 
      when 5 => COMP_DATA_TMP <= COMPDATA(39 downto 32); 
      when 4 => COMP_DATA_TMP <= COMPDATA(31 downto 24); 
      when 3 => COMP_DATA_TMP <= COMPDATA(23 downto 16); 
      when 2 => COMP_DATA_TMP <= COMPDATA(15 downto 8); 
      when 1 => COMP_DATA_TMP <= COMPDATA(7 downto 0); 
      when 0 => COMP_DATA_TMP <= "01100110"; -- 66h 
      when others => COMP_DATA_TMP <= "00000000";
    end case;
  end process;


---------------------------------- PARAMETER_LIST data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WRITE_PARAMETER_LIST_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
      if WR_PARAMETER_LIST_ENABLE = '0' and WR_PARAMETER_LIST_ENABLE_DEL = '1' then -- At downgoing edge of WR_PARAMETER_LIST_ENABLE
  	    WRITE_PARAMETER_LIST_MODE <= '0';
      elsif WRITE_PARAMETER_LIST_MODE = '1' then -- WRITE_PARAMETER_LIST_MODE locks itself
  	    WRITE_PARAMETER_LIST_MODE <= WRITE_PARAMETER_LIST_MODE;
      elsif START_WRITE_PARAMETER_LIST_PRIOR = '1' and START_WRITE_PARAMETER_LIST_PRIOR_DEL = '0' then -- Start WRITE_PARAMETER_LIST_MODE
  	    WRITE_PARAMETER_LIST_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  PARAMETER_LIST_COUNT <= 79;
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_PARAMETER_LIST_MODE = '1' and WRITE_PARAMETER_LIST_MODE_DEL = '0' then  -- upgoing edge of WRITE_PARAMETER_LIST_MODE
  	    PARAMETER_LIST_COUNT <= 79;
      elsif WR_PARAMETER_LIST = '1' and WR_PARAMETER_LIST_DEL = '0' then  -- upgoing edge of WR_PARAMETER_LIST
        PARAMETER_LIST_COUNT <= PARAMETER_LIST_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WR_PARAMETER_LIST_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_PARAMETER_LIST_MODE = '1' and WRITE_PARAMETER_LIST_MODE_DEL = '0' then  -- upgoing edge of WRITE_PARAMETER_LIST_MODE
  	    WR_PARAMETER_LIST_ENABLE <= '1';
      elsif WR_PARAMETER_LIST = '0' and WR_PARAMETER_LIST_DEL = '1' and PARAMETER_LIST_COUNT = 0 then  -- downgoing edge of WR_PARAMETER_LIST
  	    WR_PARAMETER_LIST_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(PARAMETER_LIST_COUNT,PARAMETER_LIST,TR_CONDITION,PRE_TIME,COINC_TIME,POST_TIME,GPS_TS_ONE_PPS,LONGITUDE,LATITUDE,ALTITUDE,TEMP)
  begin
    case (PARAMETER_LIST_COUNT) is
      when 78 => PARAMETER_LIST_TMP <= "10011001"; -- 99h
      when 77 => PARAMETER_LIST_TMP <= "01010101"; -- 55h
      when 76 => PARAMETER_LIST_TMP <= PARAMETER_LIST(7 downto 0);-- CH1_OFFSET_ADJ_POS 
      when 75 => PARAMETER_LIST_TMP <= PARAMETER_LIST(15 downto 8);-- CH1_OFFSET_ADJ_NEG 
      when 74 => PARAMETER_LIST_TMP <= PARAMETER_LIST(23 downto 16);-- CH2_OFFSET_ADJ_POS 
      when 73 => PARAMETER_LIST_TMP <= PARAMETER_LIST(31 downto 24);-- CH2_OFFSET_ADJ_NEG 
      when 72 => PARAMETER_LIST_TMP <= PARAMETER_LIST(39 downto 32);-- CH1_GAIN_ADJ_POS 
      when 71 => PARAMETER_LIST_TMP <= PARAMETER_LIST(47 downto 40);-- CH1_GAIN_ADJ_NEG 
      when 70 => PARAMETER_LIST_TMP <= PARAMETER_LIST(55 downto 48);-- CH2_GAIN_ADJ_POS 
      when 69 => PARAMETER_LIST_TMP <= PARAMETER_LIST(63 downto 56);-- CH2_GAIN_ADJ_NEG 
      when 68 => PARAMETER_LIST_TMP <= PARAMETER_LIST(71 downto 64);-- COMMON_OFFSET_ADJ 
      when 67 => PARAMETER_LIST_TMP <= PARAMETER_LIST(79 downto 72);-- FULL_SCALE_ADJ 
      when 66 => PARAMETER_LIST_TMP <= PARAMETER_LIST(87 downto 80);-- CH1_INTEGRATOR 
      when 65 => PARAMETER_LIST_TMP <= PARAMETER_LIST(95 downto 88);-- CH2_INTEGRATOR 
      when 64 => PARAMETER_LIST_TMP <= PARAMETER_LIST(103 downto 96);-- COMP_THRES_LOW 
      when 63 => PARAMETER_LIST_TMP <= PARAMETER_LIST(111 downto 104);-- COMP_THRES_HIGH 
      when 62 => PARAMETER_LIST_TMP <= PARAMETER_LIST(119 downto 112);-- CH1_PMT_HV_ADJ 
      when 61 => PARAMETER_LIST_TMP <= PARAMETER_LIST(127 downto 120);-- CH2_PMT_HV_ADJ 
      when 60 => PARAMETER_LIST_TMP <= PARAMETER_LIST(143 downto 136);-- CH1_THRES_LOW - higher byte
      when 59 => PARAMETER_LIST_TMP <= PARAMETER_LIST(135 downto 128);-- CH1_THRES_LOW - lower byte
      when 58 => PARAMETER_LIST_TMP <= PARAMETER_LIST(159 downto 152);-- CH1_THRES_HIGH - higher byte 
      when 57 => PARAMETER_LIST_TMP <= PARAMETER_LIST(151 downto 144);-- CH1_THRES_HIGH - lower byte 
      when 56 => PARAMETER_LIST_TMP <= PARAMETER_LIST(175 downto 168);-- CH2_THRES_LOW - higher byte 
      when 55 => PARAMETER_LIST_TMP <= PARAMETER_LIST(167 downto 160);-- CH2_THRES_LOW - lower byte 
      when 54 => PARAMETER_LIST_TMP <= PARAMETER_LIST(191 downto 184);-- CH2_THRES_HIGH - higher byte 
      when 53 => PARAMETER_LIST_TMP <= PARAMETER_LIST(183 downto 176);-- CH2_THRES_HIGH - lower byte 
      when 52 => PARAMETER_LIST_TMP <= TR_CONDITION; 
      when 51 => PARAMETER_LIST_TMP <= PRE_TIME(15 downto 8); 
      when 50 => PARAMETER_LIST_TMP <= PRE_TIME(7 downto 0); 
      when 49 => PARAMETER_LIST_TMP <= COINC_TIME(15 downto 8); 
      when 48 => PARAMETER_LIST_TMP <= COINC_TIME(7 downto 0); 
      when 47 => PARAMETER_LIST_TMP <= POST_TIME(15 downto 8); 
      when 46 => PARAMETER_LIST_TMP <= POST_TIME(7 downto 0); 
      when 45 => PARAMETER_LIST_TMP <= PARAMETER_LIST(199 downto 192);-- STATUS 
      when 44 => PARAMETER_LIST_TMP <= PARAMETER_LIST(231 downto 224);-- SPARE_BYTES - highest byte 
      when 43 => PARAMETER_LIST_TMP <= PARAMETER_LIST(223 downto 216); 
      when 42 => PARAMETER_LIST_TMP <= PARAMETER_LIST(215 downto 208); 
      when 41 => PARAMETER_LIST_TMP <= PARAMETER_LIST(207 downto 200);-- SPARE_BYTES - lowest byte 
      when 40 => PARAMETER_LIST_TMP <= PARAMETER_LIST(239 downto 232);-- CH1_PMT_SUPPLY_CURR 
      when 39 => PARAMETER_LIST_TMP <= PARAMETER_LIST(247 downto 240);-- CH2_PMT_SUPPLY_CURR 
      when 38 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(55 downto 48); 
      when 37 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(47 downto 40); 
      when 36 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(39 downto 32); 
      when 35 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(31 downto 24); 
      when 34 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(23 downto 16); 
      when 33 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(15 downto 8); 
      when 32 => PARAMETER_LIST_TMP <= GPS_TS_ONE_PPS(7 downto 0); 
      when 31 => PARAMETER_LIST_TMP <= LONGITUDE(63 downto 56); 
      when 30 => PARAMETER_LIST_TMP <= LONGITUDE(55 downto 48); 
      when 29 => PARAMETER_LIST_TMP <= LONGITUDE(47 downto 40); 
      when 28 => PARAMETER_LIST_TMP <= LONGITUDE(39 downto 32); 
      when 27 => PARAMETER_LIST_TMP <= LONGITUDE(31 downto 24); 
      when 26 => PARAMETER_LIST_TMP <= LONGITUDE(23 downto 16); 
      when 25 => PARAMETER_LIST_TMP <= LONGITUDE(15 downto 8); 
      when 24 => PARAMETER_LIST_TMP <= LONGITUDE(7 downto 0); 
      when 23 => PARAMETER_LIST_TMP <= LATITUDE(63 downto 56); 
      when 22 => PARAMETER_LIST_TMP <= LATITUDE(55 downto 48); 
      when 21 => PARAMETER_LIST_TMP <= LATITUDE(47 downto 40); 
      when 20 => PARAMETER_LIST_TMP <= LATITUDE(39 downto 32); 
      when 19 => PARAMETER_LIST_TMP <= LATITUDE(31 downto 24); 
      when 18 => PARAMETER_LIST_TMP <= LATITUDE(23 downto 16); 
      when 17 => PARAMETER_LIST_TMP <= LATITUDE(15 downto 8); 
      when 16 => PARAMETER_LIST_TMP <= LATITUDE(7 downto 0); 
      when 15 => PARAMETER_LIST_TMP <= ALTITUDE(63 downto 56); 
      when 14 => PARAMETER_LIST_TMP <= ALTITUDE(55 downto 48); 
      when 13 => PARAMETER_LIST_TMP <= ALTITUDE(47 downto 40); 
      when 12 => PARAMETER_LIST_TMP <= ALTITUDE(39 downto 32); 
      when 11 => PARAMETER_LIST_TMP <= ALTITUDE(31 downto 24); 
      when 10 => PARAMETER_LIST_TMP <= ALTITUDE(23 downto 16); 
      when 9 => PARAMETER_LIST_TMP <= ALTITUDE(15 downto 8); 
      when 8 => PARAMETER_LIST_TMP <= ALTITUDE(7 downto 0); 
      when 7 => PARAMETER_LIST_TMP <= TEMP(31 downto 24); 
      when 6 => PARAMETER_LIST_TMP <= TEMP(23 downto 16); 
      when 5 => PARAMETER_LIST_TMP <= TEMP(15 downto 8); 
      when 4 => PARAMETER_LIST_TMP <= TEMP(7 downto 0); 
      when 3 => PARAMETER_LIST_TMP <= PARAMETER_LIST(271 downto 264);-- VERSION - highest byte 
      when 2 => PARAMETER_LIST_TMP <= PARAMETER_LIST(263 downto 256); 
      when 1 => PARAMETER_LIST_TMP <= PARAMETER_LIST(255 downto 248);-- VERSION - lowest byte 
      when 0 => PARAMETER_LIST_TMP <= "01100110"; -- 66h 
      when others => PARAMETER_LIST_TMP <= "00000000";
    end case;
  end process;

---------------------------------- READ_ERROR data --------------------------------------------------
  process(CLKRD,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WRITE_READ_ERROR_MODE <= '0';
    elsif (CLKRD'event and CLKRD = '1') then 
      if WR_READ_ERROR_ENABLE = '0' and WR_READ_ERROR_ENABLE_DEL = '1' then -- At downgoing edge of WR_READ_ERROR_ENABLE
  	    WRITE_READ_ERROR_MODE <= '0';
      elsif WRITE_READ_ERROR_MODE = '1' then -- WRITE_READ_ERROR_MODE locks itself
  	    WRITE_READ_ERROR_MODE <= WRITE_READ_ERROR_MODE;
      elsif START_WRITE_READ_ERROR_PRIOR = '1' and START_WRITE_READ_ERROR_PRIOR_DEL = '0' then -- Start WRITE_READ_ERROR_MODE
  	    WRITE_READ_ERROR_MODE <= '1';
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  READ_ERROR_COUNT <= 4;
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_READ_ERROR_MODE = '1' and WRITE_READ_ERROR_MODE_DEL = '0' then  -- upgoing edge of WRITE_READ_ERROR_MODE
  	    READ_ERROR_COUNT <= 4;
      elsif WR_READ_ERROR = '1' and WR_READ_ERROR_DEL = '0' then  -- upgoing edge of WR_READ_ERROR
        READ_ERROR_COUNT <= READ_ERROR_COUNT - 1;
      end if;
    end if;
  end process;

  process(CLK10MHz,SYSRST)
  begin
  	if SYSRST = '1' then
  	  WR_READ_ERROR_ENABLE <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then 
      if WRITE_READ_ERROR_MODE = '1' and WRITE_READ_ERROR_MODE_DEL = '0' then  -- upgoing edge of WRITE_READ_ERROR_MODE
  	    WR_READ_ERROR_ENABLE <= '1';
      elsif WR_READ_ERROR = '0' and WR_READ_ERROR_DEL = '1' and READ_ERROR_COUNT = 0 then  -- downgoing edge of WR_READ_ERROR
  	    WR_READ_ERROR_ENABLE <= '0';
      end if;
    end if;
  end process;

  process(READ_ERROR_COUNT,READ_ERROR_DATA)
  begin
    case (READ_ERROR_COUNT) is
      when 3 => READ_ERROR_TMP <= "10011001"; -- 99h
      when 2 => READ_ERROR_TMP <= "10001000"; -- 88h
      when 1 => READ_ERROR_TMP <= READ_ERROR_DATA; 
      when 0 => READ_ERROR_TMP <= "01100110"; -- 66h 
      when others => READ_ERROR_TMP <= "00000000";
    end case;
  end process;

  process(USB_DATA_MODE,USB_DATA_PRE,GPS_DATA_TMP,COMP_DATA_TMP,PARAMETER_LIST_TMP,READ_ERROR_TMP)
  begin
    case (USB_DATA_MODE) is
      when "00001" => USB_DATA <= USB_DATA_PRE; 
      when "00010" => USB_DATA <= GPS_DATA_TMP; 
      when "00100" => USB_DATA <= PARAMETER_LIST_TMP; 
      when "01000" => USB_DATA <= READ_ERROR_TMP; 
      when "10000" => USB_DATA <= COMP_DATA_TMP; 
      when others => USB_DATA <= "00000000";
    end case;
  end process;

  USB_DATA_OUT <= USB_DATA when USB_WRITE_ENABLE = '1' else "ZZZZZZZZ";


    
end rtl ; -- of USB_WRITE_HANDLER

--------------------------------------------------------------------------------
-- Entity declaration of 'USB_READ_HANDLER'.
-- Last modified : Wed Aug 29 15:06:39 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity USB_READ_HANDLER is
  port(
    ADC_A0                      : out    std_logic;
    ADC_A1                      : out    std_logic;
    ADC_DATA_IN                 : in     std_logic_vector(7 downto 0);
    ADC_MODE                    : out    std_logic;
    ADC_nCS                     : out    std_logic;
    ADC_nINT                    : in     std_logic;
    ADC_nRD                     : out    std_logic;
    ADC_nWR_RDY                 : in     std_logic;
    CLK10MHz                    : in     std_logic;
    CLKRD                       : in     std_logic;
    COINC_TIME                  : out    integer range 1000 downto 0;
    COINC_TIME_OUT              : out    std_logic_vector(15 downto 0);
    DAC_A0                      : out    std_logic;
    DAC_A1                      : out    std_logic;
    DAC_A2                      : out    std_logic;
    DAC_DATA_0                  : out    std_logic;
    DAC_DATA_1                  : out    std_logic;
    DAC_DATA_2                  : out    std_logic;
    DAC_DATA_3                  : out    std_logic;
    DAC_DATA_4                  : out    std_logic;
    DAC_DATA_5                  : out    std_logic;
    DAC_DATA_6                  : out    std_logic;
    DAC_DATA_7                  : out    std_logic;
    DAC_nCLR                    : out    std_logic;
    DAC_nCS1                    : out    std_logic;
    DAC_nCS2                    : out    std_logic;
    DAC_nLDAC                   : out    std_logic;
    DAC_nRD                     : out    std_logic;
    DAC_nWR                     : out    std_logic;
    ERROR_READ_OUT              : out    std_logic;
    GPS_PROG_ENABLE             : out    std_logic;
    MASTER                      : in     std_logic;
    ONE_PPS                     : in     std_logic;
    PARAMETER_LIST              : out    std_logic_vector(271 downto 0);
    PARAMETER_LIST_READOUT_DONE : in     std_logic;
    PARAMETER_LIST_VALID        : out    std_logic;
    POST_TIME                   : out    integer range 1600 downto 0;
    POST_TIME_OUT               : out    std_logic_vector(15 downto 0);
    PRE_TIME_OUT                : out    std_logic_vector(15 downto 0);
    READ_BUSY_OUT               : out    std_logic;
    READ_ERROR_DATA             : out    std_logic_vector(7 downto 0);
    READ_ERROR_READOUT_DONE     : in     std_logic;
    READ_ERROR_VALID            : out    std_logic;
    SECOND_MESSAGE_ALLOWED      : out    std_logic;
    SERIAL_NUMBER               : in     std_logic_vector(9 downto 0);
    SLAVE_PRESENT               : in     std_logic;
    SOFT_RESET                  : out    std_logic;
    STOP_READ_OUT               : out    std_logic;
    SYSRST                      : in     std_logic;
    THH1                        : out    std_logic_vector(11 downto 0);
    THH2                        : out    std_logic_vector(11 downto 0);
    THL1                        : out    std_logic_vector(11 downto 0);
    THL2                        : out    std_logic_vector(11 downto 0);
    TOTAL_TIME                  : out    integer range 2000 downto 0;
    TOTAL_TIME_3X               : out    integer range 6000 downto 0;
    TR_CONDITION                : out    std_logic_vector(7 downto 0);
    USB_DATA_IN                 : in     std_logic_vector(7 downto 0);
    USB_RD                      : out    std_logic;
    USB_RXF                     : in     std_logic;
    USB_WRITE_BUSY              : in     std_logic;
    USB_WRITE_ENABLE            : out    std_logic;
    USB_WRITE_REQUEST           : in     std_logic);
end USB_READ_HANDLER ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'USB_READ_HANDLER'
-- Last modified : Wed Aug 29 15:06:39 2007.
--------------------------------------------------------------------------------

architecture rtl of USB_READ_HANDLER is

signal PRE_TIME_SET: integer range 400 downto 0;-- The maximum PRE_TIME_SET can be 2 us. This are 400 steps of 5 ns. 
signal COINC_TIME_SET: integer range 1000 downto 0;-- The maximum COINC_TIME_SET can be 5 us. This are 1000 steps of 5 ns.  
signal POST_TIME_SET: integer range 1600 downto 0;-- The maximum POST_TIME_SET can be 8 us. This are 1600 steps of 5 ns.  
signal TOTAL_TIME_TMP: integer range 2000 downto 0;-- The maximum TOTAL_TIME can be 10 us. This are 2000 steps of 5 ns. 
signal PRE_TIME_LOAD: std_logic_vector(15 downto 0);
signal COINC_TIME_LOAD: std_logic_vector(15 downto 0);
signal POST_TIME_LOAD: std_logic_vector(15 downto 0);
signal PRE_TIME_TMP: std_logic_vector(15 downto 0);
signal COINC_TIME_TMP: std_logic_vector(15 downto 0);
signal POST_TIME_TMP: std_logic_vector(15 downto 0);

signal CH1_OFFSET_ADJ_POS: std_logic_vector(7 downto 0);
signal CH1_OFFSET_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_OFFSET_ADJ_POS: std_logic;
signal CLR_CH1_OFFSET_ADJ_POS: std_logic;

signal CH1_OFFSET_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH1_OFFSET_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_OFFSET_ADJ_NEG: std_logic;
signal CLR_CH1_OFFSET_ADJ_NEG: std_logic;

signal CH2_OFFSET_ADJ_POS: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_OFFSET_ADJ_POS: std_logic;
signal CLR_CH2_OFFSET_ADJ_POS: std_logic;

signal CH2_OFFSET_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_OFFSET_ADJ_NEG: std_logic;
signal CLR_CH2_OFFSET_ADJ_NEG: std_logic;

signal CH1_GAIN_ADJ_POS: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_GAIN_ADJ_POS: std_logic;
signal CLR_CH1_GAIN_ADJ_POS: std_logic;

signal CH1_GAIN_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_GAIN_ADJ_NEG: std_logic;
signal CLR_CH1_GAIN_ADJ_NEG: std_logic;

signal CH2_GAIN_ADJ_POS: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_POS_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_GAIN_ADJ_POS: std_logic;
signal CLR_CH2_GAIN_ADJ_POS: std_logic;

signal CH2_GAIN_ADJ_NEG: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_NEG_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_GAIN_ADJ_NEG: std_logic;
signal CLR_CH2_GAIN_ADJ_NEG: std_logic;

signal COMMON_OFFSET_ADJ: std_logic_vector(7 downto 0);
signal COMMON_OFFSET_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_COMMON_OFFSET_ADJ: std_logic;
signal CLR_COMMON_OFFSET_ADJ: std_logic;

signal FULL_SCALE_ADJ: std_logic_vector(7 downto 0);
signal FULL_SCALE_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_FULL_SCALE_ADJ: std_logic;
signal CLR_FULL_SCALE_ADJ: std_logic;

signal CH1_INTEGRATOR: std_logic_vector(7 downto 0);
signal CH1_INTEGRATOR_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_INTEGRATOR: std_logic;
signal CLR_CH1_INTEGRATOR: std_logic;

signal CH2_INTEGRATOR: std_logic_vector(7 downto 0);
signal CH2_INTEGRATOR_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_INTEGRATOR: std_logic;
signal CLR_CH2_INTEGRATOR: std_logic;

signal COMP_THRES_LOW: std_logic_vector(7 downto 0);
signal COMP_THRES_LOW_DEL: std_logic_vector(7 downto 0);
signal SET_COMP_THRES_LOW: std_logic;
signal CLR_COMP_THRES_LOW: std_logic;

signal COMP_THRES_HIGH: std_logic_vector(7 downto 0);
signal COMP_THRES_HIGH_DEL: std_logic_vector(7 downto 0);
signal SET_COMP_THRES_HIGH: std_logic;
signal CLR_COMP_THRES_HIGH: std_logic;

signal CH1_PMT_HV_ADJ: std_logic_vector(7 downto 0);
signal CH1_PMT_HV_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_CH1_PMT_HV_ADJ: std_logic;
signal CLR_CH1_PMT_HV_ADJ: std_logic;

signal CH2_PMT_HV_ADJ: std_logic_vector(7 downto 0);
signal CH2_PMT_HV_ADJ_DEL: std_logic_vector(7 downto 0);
signal SET_CH2_PMT_HV_ADJ: std_logic;
signal CLR_CH2_PMT_HV_ADJ: std_logic;

signal CH1_THRES_LOW: std_logic_vector(15 downto 0);
signal CH1_THRES_HIGH: std_logic_vector(15 downto 0);
signal CH2_THRES_LOW: std_logic_vector(15 downto 0);
signal CH2_THRES_HIGH: std_logic_vector(15 downto 0);

signal SPARE_BYTES: std_logic_vector(31 downto 0);

signal CH1_PMT_SUPPLY_CURR: std_logic_vector(7 downto 0);
signal CH2_PMT_SUPPLY_CURR: std_logic_vector(7 downto 0);
signal STATUS: std_logic_vector(7 downto 0);
signal VERSION: std_logic_vector(23 downto 0);
signal SOFTWARE_VERSION: std_logic_vector(7 downto 0);

signal WRITE_PARAMETER_LIST: std_logic;
signal WRITE_PARAMETER_LIST_DEL: std_logic;
signal PARAMETER_LIST_READOUT_DONE_DEL1: std_logic;
signal READ_ERROR: std_logic;
signal READ_ERROR_READOUT_DONE_DEL1: std_logic;

--signal USB_RXF_DEL: std_logic;
--signal USB_RXF_OR: std_logic;
--signal USB_READ_ENABLE: std_logic;
signal USB_READ_BUSY: std_logic;
signal USB_WRITE_ENABLE_TMP: std_logic;
signal USB_WRITE_ALLOWED: std_logic; -- Least significant bit of SPARE_BYTES and controlled by LabView to enable writing to PC
--signal START_READING: std_logic;
signal STOP_READING: std_logic;
signal USB_WRITE_BUSY_DEL1: std_logic; -- to detect the falling edge of USB_WRITE_BUSY
signal USB_WRITE_BUSY_DEL2: std_logic;
signal USB_WRITE_BUSY_DEL3: std_logic;
signal USB_WRITE_BUSY_DEL4: std_logic;
signal USB_WRITE_BUSY_DEL5: std_logic;
--signal USB_WRITE_REQUEST_DEL1: std_logic;
--signal USB_WRITE_REQUEST_DEL2: std_logic;
--signal USB_WRITE_REQUEST_DEL3: std_logic;
--signal USB_WRITE_REQUEST_DEL4: std_logic;

signal CH1_OFFSET_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH1_OFFSET_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH2_OFFSET_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH1_GAIN_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_POS_TMP: std_logic_vector(7 downto 0);
signal CH2_GAIN_ADJ_NEG_TMP: std_logic_vector(7 downto 0);
signal COMMON_OFFSET_ADJ_TMP: std_logic_vector(7 downto 0);
signal FULL_SCALE_ADJ_TMP: std_logic_vector(7 downto 0);
signal CH1_INTEGRATOR_TMP: std_logic_vector(7 downto 0);
signal CH2_INTEGRATOR_TMP: std_logic_vector(7 downto 0);
signal COMP_THRES_LOW_TMP: std_logic_vector(7 downto 0);
signal COMP_THRES_HIGH_TMP: std_logic_vector(7 downto 0);
signal CH1_PMT_HV_ADJ_TMP: std_logic_vector(7 downto 0);
signal CH2_PMT_HV_ADJ_TMP: std_logic_vector(7 downto 0);
signal CH1_THRES_LOW_TMP: std_logic_vector(15 downto 0);
signal CH1_THRES_HIGH_TMP: std_logic_vector(15 downto 0);
signal CH2_THRES_LOW_TMP: std_logic_vector(15 downto 0);
signal CH2_THRES_HIGH_TMP: std_logic_vector(15 downto 0);
signal TR_CONDITION_TMP: std_logic_vector(7 downto 0);
signal PRE_TIME_LOAD_TMP: std_logic_vector(15 downto 0);
signal COINC_TIME_LOAD_TMP: std_logic_vector(15 downto 0);
signal POST_TIME_LOAD_TMP: std_logic_vector(15 downto 0);
signal SPARE_BYTES_TMP: std_logic_vector(31 downto 0);
signal STATUS_TMP: std_logic_vector(7 downto 0);

signal RD_TMP: std_logic;
signal READ_COUNT: integer range 41 downto 0; -- Send message can be maximum 39 bytes (1 extra for error notification)
signal READ_ID: std_logic_vector(7 downto 0);
signal TIME_OUT_COUNT: std_logic_vector(23 downto 0); --Counts 1 s when read busy hangs


signal PRELOAD_DACS: std_logic;
signal PRELOAD_DACS_DEL1: std_logic;
signal PRELOAD_DACS_DEL2: std_logic;
signal PRELOAD_DAC_COUNT: std_logic_vector(2 downto 0);
signal WR_DACS: std_logic;
signal DAC_DATA_OUT: std_logic_vector(7 downto 0);

signal ONE_PPS_DEL1: std_logic;
signal ONE_PPS_DEL2: std_logic;
signal SET_CURR_ADC: std_logic;
signal CLR_CURR_ADC: std_logic;
signal CURR_ADC_COUNT: integer range 75 downto 0; 


begin

  USB_WRITE_ALLOWED <= SPARE_BYTES(0);
  SECOND_MESSAGE_ALLOWED <= SPARE_BYTES(1);
  STATUS(6 downto 3) <= "0000";
  STATUS(2) <= USB_WRITE_ALLOWED;
  STATUS(1) <= SLAVE_PRESENT;
  STATUS(0) <= MASTER;
  GPS_PROG_ENABLE <= STATUS(7);
  SOFTWARE_VERSION <= "00000011";
  VERSION(23 downto 16) <= SOFTWARE_VERSION;
  VERSION(15 downto 10) <= "000000";
  VERSION(9) <= not SERIAL_NUMBER(9);
  VERSION(8) <= not SERIAL_NUMBER(8);
  VERSION(7) <= not SERIAL_NUMBER(7);
  VERSION(6) <= not SERIAL_NUMBER(6);
  VERSION(5) <= not SERIAL_NUMBER(5);
  VERSION(4) <= not SERIAL_NUMBER(4);
  VERSION(3) <= not SERIAL_NUMBER(3);
  VERSION(2) <= not SERIAL_NUMBER(2);
  VERSION(1) <= not SERIAL_NUMBER(1);
  VERSION(0) <= not SERIAL_NUMBER(0);
  THL1 <= CH1_THRES_LOW(11 downto 0);
  THH1 <= CH1_THRES_HIGH(11 downto 0);
  THL2 <= CH2_THRES_LOW(11 downto 0);
  THH2 <= CH2_THRES_HIGH(11 downto 0);
--  PRE_TIME_TMP <= PRE_TIME_LOAD when PRE_TIME_LOAD <= "0000000110010000" else "0000000110010000"; -- 400
--  COINC_TIME_TMP <= COINC_TIME_LOAD when COINC_TIME_LOAD <= "0000001111101000" else "0000001111101000"; -- 1000
--  POST_TIME_TMP <= POST_TIME_LOAD when POST_TIME_LOAD <= "0000011001000000" else "0000011001000000"; -- 1600
  PRE_TIME_OUT <= PRE_TIME_TMP;
  COINC_TIME_OUT <= COINC_TIME_TMP;
  POST_TIME_OUT <= POST_TIME_TMP;
  PRE_TIME_SET <= to_integer(unsigned(PRE_TIME_TMP)) ;
  POST_TIME_SET <= to_integer(unsigned(POST_TIME_TMP)) ;
  COINC_TIME_SET <= to_integer(unsigned(COINC_TIME_TMP)) ;
  COINC_TIME <= COINC_TIME_SET;
  POST_TIME <= POST_TIME_SET;
--  TOTAL_TIME_TMP <= PRE_TIME_SET + COINC_TIME_SET + POST_TIME_SET when (PRE_TIME_SET + COINC_TIME_SET + POST_TIME_SET) <= 2000 else TOTAL_TIME_TMP;
  TOTAL_TIME <= TOTAL_TIME_TMP;
  TOTAL_TIME_3X <= TOTAL_TIME_TMP + TOTAL_TIME_TMP + TOTAL_TIME_TMP;
    
  ADC_MODE <= '0';
  ADC_nCS <= '0';
  ADC_A1 <= '0';

  USB_WRITE_ENABLE <= USB_WRITE_ENABLE_TMP;
  READ_BUSY_OUT <= USB_READ_BUSY;
  STOP_READ_OUT <= STOP_READING;
  ERROR_READ_OUT <= READ_ERROR;
  
  process(CLK10MHz)
  begin
    if (CLK10MHz'event and CLK10MHz = '1') then
      if PRE_TIME_LOAD <= "0000000110010000" then -- 400
        PRE_TIME_TMP <= PRE_TIME_LOAD;
      else  
        PRE_TIME_TMP <= "0000000110010000";
      end if;
      if COINC_TIME_LOAD <= "0000001111101000" then -- 1000
        COINC_TIME_TMP <= COINC_TIME_LOAD;
      else  
        COINC_TIME_TMP <= "0000001111101000";
      end if;
      if POST_TIME_LOAD <= "0000011001000000" then -- 1600
        POST_TIME_TMP <= POST_TIME_LOAD;
      else  
        POST_TIME_TMP <= "0000011001000000";
      end if;
      if (PRE_TIME_SET + COINC_TIME_SET + POST_TIME_SET) <= 2000 then 
        TOTAL_TIME_TMP <= PRE_TIME_SET + COINC_TIME_SET + POST_TIME_SET;
      else  
        TOTAL_TIME_TMP <= 2000; -- Limit on 2000
      end if;
    end if;
  end process;  

  PARAMETER_LIST(7 downto 0) <= CH1_OFFSET_ADJ_POS;
  PARAMETER_LIST(15 downto 8) <= CH1_OFFSET_ADJ_NEG;
  PARAMETER_LIST(23 downto 16) <= CH2_OFFSET_ADJ_POS;
  PARAMETER_LIST(31 downto 24) <= CH2_OFFSET_ADJ_NEG;
  PARAMETER_LIST(39 downto 32) <= CH1_GAIN_ADJ_POS;
  PARAMETER_LIST(47 downto 40) <= CH1_GAIN_ADJ_NEG;
  PARAMETER_LIST(55 downto 48) <= CH2_GAIN_ADJ_POS;
  PARAMETER_LIST(63 downto 56) <= CH2_GAIN_ADJ_NEG;
  PARAMETER_LIST(71 downto 64) <= COMMON_OFFSET_ADJ;
  PARAMETER_LIST(79 downto 72) <= FULL_SCALE_ADJ;
  PARAMETER_LIST(87 downto 80) <= CH1_INTEGRATOR;
  PARAMETER_LIST(95 downto 88) <= CH2_INTEGRATOR;
  PARAMETER_LIST(103 downto 96) <= COMP_THRES_LOW;
  PARAMETER_LIST(111 downto 104) <= COMP_THRES_HIGH;
  PARAMETER_LIST(119 downto 112) <= CH1_PMT_HV_ADJ;
  PARAMETER_LIST(127 downto 120) <= CH2_PMT_HV_ADJ;
  PARAMETER_LIST(143 downto 128) <= CH1_THRES_LOW;
  PARAMETER_LIST(159 downto 144) <= CH1_THRES_HIGH;
  PARAMETER_LIST(175 downto 160) <= CH2_THRES_LOW;
  PARAMETER_LIST(191 downto 176) <= CH2_THRES_HIGH;
  PARAMETER_LIST(199 downto 192) <= STATUS;
  PARAMETER_LIST(231 downto 200) <= SPARE_BYTES;
  PARAMETER_LIST(239 downto 232) <= CH1_PMT_SUPPLY_CURR;
  PARAMETER_LIST(247 downto 240) <= CH2_PMT_SUPPLY_CURR;
  PARAMETER_LIST(271 downto 248) <= VERSION;


  --USB_WRITE_ENABLE <= not USB_READ_ENABLE;
  USB_RD <= RD_TMP;
  DAC_nWR <= WR_DACS;
  DAC_nLDAC <= '0';
  DAC_nCLR <= '1';
  DAC_nRD <= '1';
  DAC_DATA_0 <= DAC_DATA_OUT(0);
  DAC_DATA_1 <= DAC_DATA_OUT(1);
  DAC_DATA_2 <= DAC_DATA_OUT(2);
  DAC_DATA_3 <= DAC_DATA_OUT(3);
  DAC_DATA_4 <= DAC_DATA_OUT(4);
  DAC_DATA_5 <= DAC_DATA_OUT(5);
  DAC_DATA_6 <= DAC_DATA_OUT(6);
  DAC_DATA_7 <= DAC_DATA_OUT(7);
  
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      PRELOAD_DACS_DEL1 <= '0';        
      PRELOAD_DACS_DEL2 <= '0';        
      CH1_OFFSET_ADJ_POS_DEL <= "00000000";        
      CH1_OFFSET_ADJ_NEG_DEL <= "00000000";        
      CH2_OFFSET_ADJ_POS_DEL <= "00000000";        
      CH2_OFFSET_ADJ_NEG_DEL <= "00000000";        
      CH1_GAIN_ADJ_POS_DEL <= "00000000";        
      CH1_GAIN_ADJ_NEG_DEL <= "00000000";        
      CH2_GAIN_ADJ_POS_DEL <= "00000000";        
      CH2_GAIN_ADJ_NEG_DEL <= "00000000";        
      COMMON_OFFSET_ADJ_DEL <= "00000000";        
      FULL_SCALE_ADJ_DEL <= "00000000";        
      CH1_INTEGRATOR_DEL <= "00000000";        
      CH2_INTEGRATOR_DEL <= "00000000";        
      COMP_THRES_LOW_DEL <= "00000000";        
      COMP_THRES_HIGH_DEL <= "00000000";        
      CH1_PMT_HV_ADJ_DEL <= "00000000";        
      CH2_PMT_HV_ADJ_DEL <= "00000000";        
      ONE_PPS_DEL1 <= '0';        
      ONE_PPS_DEL2 <= '0';        
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      PRELOAD_DACS_DEL1 <= PRELOAD_DACS;        
      PRELOAD_DACS_DEL2 <= PRELOAD_DACS_DEL1;        
      CH1_OFFSET_ADJ_POS_DEL <= CH1_OFFSET_ADJ_POS;        
      CH1_OFFSET_ADJ_NEG_DEL <= CH1_OFFSET_ADJ_NEG;        
      CH2_OFFSET_ADJ_POS_DEL <= CH2_OFFSET_ADJ_POS;        
      CH2_OFFSET_ADJ_NEG_DEL <= CH2_OFFSET_ADJ_NEG;        
      CH1_GAIN_ADJ_POS_DEL <= CH1_GAIN_ADJ_POS;        
      CH1_GAIN_ADJ_NEG_DEL <= CH1_GAIN_ADJ_NEG;        
      CH2_GAIN_ADJ_POS_DEL <= CH2_GAIN_ADJ_POS;        
      CH2_GAIN_ADJ_NEG_DEL <= CH2_GAIN_ADJ_NEG;        
      COMMON_OFFSET_ADJ_DEL <= COMMON_OFFSET_ADJ;        
      FULL_SCALE_ADJ_DEL <= FULL_SCALE_ADJ;        
      CH1_INTEGRATOR_DEL <= CH1_INTEGRATOR;        
      CH2_INTEGRATOR_DEL <= CH2_INTEGRATOR;        
      COMP_THRES_LOW_DEL <= COMP_THRES_LOW;        
      COMP_THRES_HIGH_DEL <= COMP_THRES_HIGH;        
      CH1_PMT_HV_ADJ_DEL <= CH1_PMT_HV_ADJ;        
      CH2_PMT_HV_ADJ_DEL <= CH2_PMT_HV_ADJ;        
      ONE_PPS_DEL1 <= ONE_PPS;        
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;        
    end if;
  end process;  

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      WRITE_PARAMETER_LIST_DEL <= '0';        
      PARAMETER_LIST_READOUT_DONE_DEL1 <= '0';        
      READ_ERROR_READOUT_DONE_DEL1 <= '0';        
      USB_WRITE_BUSY_DEL1 <= '0';        
      USB_WRITE_BUSY_DEL2 <= '0';        
      USB_WRITE_BUSY_DEL3 <= '0';        
      USB_WRITE_BUSY_DEL4 <= '0';        
      USB_WRITE_BUSY_DEL5 <= '0';        
--      USB_WRITE_REQUEST_DEL1 <= '0';        
--      USB_WRITE_REQUEST_DEL2 <= '0';        
--      USB_WRITE_REQUEST_DEL3 <= '0';        
--      USB_WRITE_REQUEST_DEL4 <= '0';        
    elsif (CLKRD'event and CLKRD = '1') then
      WRITE_PARAMETER_LIST_DEL <= WRITE_PARAMETER_LIST;        
      PARAMETER_LIST_READOUT_DONE_DEL1 <= PARAMETER_LIST_READOUT_DONE;        
      READ_ERROR_READOUT_DONE_DEL1 <= READ_ERROR_READOUT_DONE;        
      USB_WRITE_BUSY_DEL1 <= USB_WRITE_BUSY;        
      USB_WRITE_BUSY_DEL2 <= USB_WRITE_BUSY_DEL1;        
      USB_WRITE_BUSY_DEL3 <= USB_WRITE_BUSY_DEL2;        
      USB_WRITE_BUSY_DEL4 <= USB_WRITE_BUSY_DEL3;        
      USB_WRITE_BUSY_DEL5 <= USB_WRITE_BUSY_DEL4;        
--      USB_WRITE_REQUEST_DEL1 <= USB_WRITE_REQUEST;        
--      USB_WRITE_REQUEST_DEL2 <= USB_WRITE_REQUEST_DEL1;        
--      USB_WRITE_REQUEST_DEL3 <= USB_WRITE_REQUEST_DEL2;        
--      USB_WRITE_REQUEST_DEL4 <= USB_WRITE_REQUEST_DEL3;        
    end if;
  end process;  

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      PARAMETER_LIST_VALID <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if WRITE_PARAMETER_LIST = '1' and WRITE_PARAMETER_LIST_DEL = '0' then
        PARAMETER_LIST_VALID <= '1';
      elsif PARAMETER_LIST_READOUT_DONE = '1' and PARAMETER_LIST_READOUT_DONE_DEL1 = '0' then
        PARAMETER_LIST_VALID <= '0';
      end if;
    end if;
  end process;  

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      READ_ERROR_VALID <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      if READ_ERROR = '1' then
        READ_ERROR_VALID <= '1';
      elsif READ_ERROR_READOUT_DONE = '1' and READ_ERROR_READOUT_DONE_DEL1 = '0' then
        READ_ERROR_VALID <= '0';
      end if;
    end if;
  end process;  

  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      USB_WRITE_ENABLE_TMP <= '0'; -- Default (on power up) USB is in read mode
      USB_READ_BUSY <= '0'; 
    elsif (CLKRD'event and CLKRD = '1') then
      if STOP_READING = '1' or READ_ERROR = '1' then -- on stop or error, reset USB_READ_BUSY
        USB_READ_BUSY <= '0';
      elsif USB_WRITE_BUSY_DEL4 = '0' and USB_WRITE_BUSY_DEL5 = '1' then -- on falling edge of USB_WRITE_BUSY, reset USB_WRITE_ENABLE
        USB_WRITE_ENABLE_TMP <= '0';
      elsif USB_WRITE_ENABLE_TMP = '1' or USB_READ_BUSY = '1' then -- if writing or reading is busy then do nothing
        USB_READ_BUSY <= USB_READ_BUSY; 
        USB_WRITE_ENABLE_TMP <= USB_WRITE_ENABLE_TMP; 
      elsif USB_READ_BUSY = '0' and USB_RXF = '0' then -- reading has first priority; USB_RXF = '0' when there is data to readout
        USB_READ_BUSY <= '1';
      elsif USB_WRITE_ENABLE_TMP = '0' and USB_WRITE_REQUEST = '1' and USB_WRITE_ALLOWED = '1' then 
        USB_WRITE_ENABLE_TMP <= '1';
      else
        USB_READ_BUSY <= '0';
        USB_WRITE_ENABLE_TMP <= '0';
      end if;
    end if;
  end process;  

  process(CLKRD,SYSRST,READ_ID,USB_DATA_IN)
  begin
    if SYSRST = '1' then
      RD_TMP <= '1'; 
      READ_COUNT <= 0;
      READ_ID <= (others => '0');
	  READ_ERROR <= '0';
  	  READ_ERROR_DATA <= (others => '0');
	  STOP_READING <= '0';
  	  TIME_OUT_COUNT <= (others => '0');
	  CH1_OFFSET_ADJ_POS_TMP <= (others => '0');
	  CH1_OFFSET_ADJ_NEG_TMP <= (others => '0');
	  CH2_OFFSET_ADJ_POS_TMP <= (others => '0');
	  CH2_OFFSET_ADJ_NEG_TMP <= (others => '0');
	  CH1_GAIN_ADJ_POS_TMP <= (others => '0');
	  CH1_GAIN_ADJ_NEG_TMP <= (others => '0');
	  CH2_GAIN_ADJ_POS_TMP <= (others => '0');
	  CH2_GAIN_ADJ_NEG_TMP <= (others => '0');
	  COMMON_OFFSET_ADJ_TMP <= (others => '0');
	  FULL_SCALE_ADJ_TMP <= (others => '0');
	  CH1_INTEGRATOR_TMP <= (others => '0');
	  CH2_INTEGRATOR_TMP <= (others => '0');
	  COMP_THRES_LOW_TMP <= (others => '0');
	  COMP_THRES_HIGH_TMP <= (others => '0');
	  CH1_PMT_HV_ADJ_TMP <= (others => '0');
	  CH2_PMT_HV_ADJ_TMP <= (others => '0');
	  CH1_THRES_LOW_TMP <= (others => '0');
	  CH1_THRES_HIGH_TMP <= (others => '0');
	  CH2_THRES_LOW_TMP <= (others => '0');
	  CH2_THRES_HIGH_TMP <= (others => '0');
  	  TR_CONDITION_TMP <= (others => '0');
	  PRE_TIME_LOAD_TMP <= (others => '0');
	  COINC_TIME_LOAD_TMP <= (others => '0');
	  POST_TIME_LOAD_TMP <= (others => '0'); 
	  SPARE_BYTES_TMP <= (others => '0');
      STATUS_TMP(7) <= '0';
	  CH1_OFFSET_ADJ_POS <= "10000000";
	  CH1_OFFSET_ADJ_NEG <= "10000000";
	  CH2_OFFSET_ADJ_POS <= "10000000";
	  CH2_OFFSET_ADJ_NEG <= "10000000";
	  CH1_GAIN_ADJ_POS <= "10000000";
	  CH1_GAIN_ADJ_NEG <= "10000000";
	  CH2_GAIN_ADJ_POS <= "10000000";
	  CH2_GAIN_ADJ_NEG <= "10000000";
	  COMMON_OFFSET_ADJ <= "00000000";
	  FULL_SCALE_ADJ <= "00000000";
	  CH1_INTEGRATOR <= "11111111";
	  CH2_INTEGRATOR <= "11111111";
	  COMP_THRES_LOW <= "01011000";
	  COMP_THRES_HIGH <= "11100110";
	  CH1_PMT_HV_ADJ <= "00000000";
	  CH2_PMT_HV_ADJ <= "00000000";
	  CH1_THRES_LOW <= "0000000100000000";
	  CH1_THRES_HIGH <= "0000100000000000";
	  CH2_THRES_LOW <= "0000000100000000";
	  CH2_THRES_HIGH <= "0000100000000000";
  	  TR_CONDITION <= "00001000";
	  PRE_TIME_LOAD <= "0000000011001000";
	  COINC_TIME_LOAD <= "0000000110010000";
	  POST_TIME_LOAD <= "0000000110010000"; 
	  SPARE_BYTES <= (others => '0');
      STATUS(7) <= '0';
      WRITE_PARAMETER_LIST <= '0';
      SOFT_RESET <= '0';	  
    elsif (CLKRD'event and CLKRD = '1') then
      if USB_READ_BUSY = '1' and READ_ERROR = '0' and STOP_READING = '0' then
        TIME_OUT_COUNT <= TIME_OUT_COUNT + "000000000000000000000001"; -- counts 1s if reading hangs
        if TIME_OUT_COUNT(23) = '1' then 
          READ_ERROR <= '1';
  	      READ_ERROR_DATA <= "11111111"; -- Timed out
        elsif USB_RXF = '0' then 
          if RD_TMP = '1' then 
            RD_TMP <= '0'; 
          else 
            RD_TMP <= '1';
            if READ_COUNT = 0 then -- wait for startbyte 99h
              if USB_DATA_IN = "10011001" then -- if there is a startbyte
                READ_COUNT <= READ_COUNT + 1; -- count the startbyte
              else -- if there is no startbyte
                READ_ERROR <= '1';
  			    READ_ERROR_DATA <= "10011001"; -- Missing start byte
              end if;
            elsif READ_COUNT = 1 then -- get ID
              if USB_DATA_IN = "00010000" or USB_DATA_IN = "00010001" or USB_DATA_IN = "00010010" or USB_DATA_IN = "00010011" 
                or USB_DATA_IN = "00010100" or USB_DATA_IN = "00010101" or USB_DATA_IN = "00010110" or USB_DATA_IN = "00010111" 
                or USB_DATA_IN = "00011000" or USB_DATA_IN = "00011001" or USB_DATA_IN = "00011010" or USB_DATA_IN = "00011011" 
                or USB_DATA_IN = "00011100" or USB_DATA_IN = "00011101" or USB_DATA_IN = "00011110" or USB_DATA_IN = "00011111" 
                or USB_DATA_IN = "00100000" or USB_DATA_IN = "00100001" or USB_DATA_IN = "00100010" or USB_DATA_IN = "00100011" 
                or USB_DATA_IN = "00110000" or USB_DATA_IN = "00110001" or USB_DATA_IN = "00110010" or USB_DATA_IN = "00110011" 
                or USB_DATA_IN = "00110100" or USB_DATA_IN = "00110101" 
                or USB_DATA_IN = "01000000" or USB_DATA_IN = "01000001" or USB_DATA_IN = "01000010" or USB_DATA_IN = "01000011" 
                or USB_DATA_IN = "01000100" or USB_DATA_IN = "01000101" or USB_DATA_IN = "01000110" or USB_DATA_IN = "01000111" 
                or USB_DATA_IN = "01010000" or USB_DATA_IN = "01010101" or USB_DATA_IN = "10001000" or USB_DATA_IN = "11111111" then -- if there is a valid ID
                READ_COUNT <= READ_COUNT + 1; -- count the ID byte
                READ_ID <= USB_DATA_IN;
              else -- if there is no valid ID
                READ_ERROR <= '1';
  			    READ_ERROR_DATA <= "10001001"; -- Wrong ID 89h
              end if;
            elsif READ_COUNT = 2 then -- get first data byte or end byte             
              READ_COUNT <= READ_COUNT + 1; 
      	      if READ_ID = "01010101" then
      	        if USB_DATA_IN = "01100110" then
      	          WRITE_PARAMETER_LIST <= '1'; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "11111111" then
      	        if USB_DATA_IN = "01100110" then
      	          SOFT_RESET <= '1'; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      		  case (READ_ID) is
    		    when "00010000" => CH1_OFFSET_ADJ_POS_TMP <= USB_DATA_IN; 
    		    when "00010001" => CH1_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN; 
    		    when "00010010" => CH2_OFFSET_ADJ_POS_TMP <= USB_DATA_IN; 
    		    when "00010011" => CH2_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN; 
    		    when "00010100" => CH1_GAIN_ADJ_POS_TMP <= USB_DATA_IN; 
    		    when "00010101" => CH1_GAIN_ADJ_NEG_TMP <= USB_DATA_IN; 
    		    when "00010110" => CH2_GAIN_ADJ_POS_TMP <= USB_DATA_IN; 
    		    when "00010111" => CH2_GAIN_ADJ_NEG_TMP <= USB_DATA_IN; 
    		    when "00011000" => COMMON_OFFSET_ADJ_TMP <= USB_DATA_IN; 
    		    when "00011001" => FULL_SCALE_ADJ_TMP <= USB_DATA_IN; 
    		    when "00011010" => CH1_INTEGRATOR_TMP <= USB_DATA_IN; 
    		    when "00011011" => CH2_INTEGRATOR_TMP <= USB_DATA_IN; 
    		    when "00011100" => COMP_THRES_LOW_TMP <= USB_DATA_IN; 
    		    when "00011101" => COMP_THRES_HIGH_TMP <= USB_DATA_IN; 
    		    when "00011110" => CH1_PMT_HV_ADJ_TMP <= USB_DATA_IN; 
    		    when "00011111" => CH2_PMT_HV_ADJ_TMP <= USB_DATA_IN; 
      	        when "00100000" => CH1_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00100001" => CH1_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00100010" => CH2_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN; 
      	        when "00100011" => CH2_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
     	        when "00110000" => TR_CONDITION_TMP <= USB_DATA_IN; 
      	        when "00110001" => PRE_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00110010" => COINC_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00110011" => POST_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "00110100" => STATUS_TMP(7) <= USB_DATA_IN(7);
      	        when "00110101" => SPARE_BYTES_TMP(31 downto 24) <= USB_DATA_IN;
      	        when "01010000" => CH1_OFFSET_ADJ_POS_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 3 then -- get second data byte or end byte             
              READ_COUNT <= READ_COUNT + 1; 
      	      if READ_ID = "00010000" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_OFFSET_ADJ_POS <= CH1_OFFSET_ADJ_POS_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00010001" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_OFFSET_ADJ_NEG <= CH1_OFFSET_ADJ_NEG_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00010010" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_OFFSET_ADJ_POS <= CH2_OFFSET_ADJ_POS_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00010011" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_OFFSET_ADJ_NEG <= CH2_OFFSET_ADJ_NEG_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00010100" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_GAIN_ADJ_POS <= CH1_GAIN_ADJ_POS_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00010101" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_GAIN_ADJ_NEG <= CH1_GAIN_ADJ_NEG_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00010110" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_GAIN_ADJ_POS <= CH2_GAIN_ADJ_POS_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00010111" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_GAIN_ADJ_NEG <= CH2_GAIN_ADJ_NEG_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011000" then
      	        if USB_DATA_IN = "01100110" then
      	          COMMON_OFFSET_ADJ <= COMMON_OFFSET_ADJ_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011001" then
      	        if USB_DATA_IN = "01100110" then
      	          FULL_SCALE_ADJ <= FULL_SCALE_ADJ_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011010" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_INTEGRATOR <= CH1_INTEGRATOR_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011011" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_INTEGRATOR <= CH2_INTEGRATOR_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011100" then
      	        if USB_DATA_IN = "01100110" then
      	          COMP_THRES_LOW <= COMP_THRES_LOW_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011101" then
      	        if USB_DATA_IN = "01100110" then
      	          COMP_THRES_HIGH <= COMP_THRES_HIGH_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011110" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_PMT_HV_ADJ <= CH1_PMT_HV_ADJ_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00011111" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_PMT_HV_ADJ <= CH2_PMT_HV_ADJ_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00110000" then
      	        if USB_DATA_IN = "01100110" then
      	          TR_CONDITION <= TR_CONDITION_TMP; 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00110100" then
      	        if USB_DATA_IN = "01100110" then
      	          STATUS(7) <= STATUS_TMP(7); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      		  case (READ_ID) is
      	        when "00100000" => CH1_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "00100001" => CH1_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "00100010" => CH2_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN; 
      	        when "00100011" => CH2_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "00110001" => PRE_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "00110010" => COINC_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "00110011" => POST_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "00110101" => SPARE_BYTES_TMP(23 downto 16) <= USB_DATA_IN;
      	        when "01010000" => CH1_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 4 then -- get third data byte or end byte             
              READ_COUNT <= READ_COUNT + 1; 
      	      if READ_ID = "00100000" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_THRES_LOW(15 downto 8) <= CH1_THRES_LOW_TMP(15 downto 8); 
      	          CH1_THRES_LOW(7 downto 0) <= CH1_THRES_LOW_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00100001" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_THRES_HIGH(15 downto 8) <= CH1_THRES_HIGH_TMP(15 downto 8); 
      	          CH1_THRES_HIGH(7 downto 0) <= CH1_THRES_HIGH_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00100010" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_THRES_LOW(15 downto 8) <= CH2_THRES_LOW_TMP(15 downto 8); 
      	          CH2_THRES_LOW(7 downto 0) <= CH2_THRES_LOW_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00100011" then
      	        if USB_DATA_IN = "01100110" then
      	          CH2_THRES_HIGH(15 downto 8) <= CH2_THRES_HIGH_TMP(15 downto 8); 
      	          CH2_THRES_HIGH(7 downto 0) <= CH2_THRES_HIGH_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00110001" then
      	        if USB_DATA_IN = "01100110" then
      	          PRE_TIME_LOAD(15 downto 8) <= PRE_TIME_LOAD_TMP(15 downto 8); 
      	          PRE_TIME_LOAD(7 downto 0) <= PRE_TIME_LOAD_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00110010" then
      	        if USB_DATA_IN = "01100110" then
      	          COINC_TIME_LOAD(15 downto 8) <= COINC_TIME_LOAD_TMP(15 downto 8); 
      	          COINC_TIME_LOAD(7 downto 0) <= COINC_TIME_LOAD_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      	      if READ_ID = "00110011" then
      	        if USB_DATA_IN = "01100110" then
      	          POST_TIME_LOAD(15 downto 8) <= POST_TIME_LOAD_TMP(15 downto 8); 
      	          POST_TIME_LOAD(7 downto 0) <= POST_TIME_LOAD_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      		  case (READ_ID) is
      	        when "00110101" => SPARE_BYTES_TMP(15 downto 8) <= USB_DATA_IN;
      	        when "01010000" => CH2_OFFSET_ADJ_POS_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 5 then -- get fourth data byte or end byte             
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "00110101" => SPARE_BYTES_TMP(7 downto 0) <= USB_DATA_IN;
      	        when "01010000" => CH2_OFFSET_ADJ_NEG_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 6 then -- get fifth data byte or end byte             
              READ_COUNT <= READ_COUNT + 1; 
      	      if READ_ID = "00110101" then
      	        if USB_DATA_IN = "01100110" then
      	          SPARE_BYTES(31 downto 24) <= SPARE_BYTES_TMP(31 downto 24); 
      	          SPARE_BYTES(23 downto 16) <= SPARE_BYTES_TMP(23 downto 16); 
      	          SPARE_BYTES(15 downto 8) <= SPARE_BYTES_TMP(15 downto 8); 
      	          SPARE_BYTES(7 downto 0) <= SPARE_BYTES_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
      		  case (READ_ID) is
      	        when "01010000" => CH1_GAIN_ADJ_POS_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 7 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH1_GAIN_ADJ_NEG_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 8 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_GAIN_ADJ_POS_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 9 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_GAIN_ADJ_NEG_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 10 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => COMMON_OFFSET_ADJ_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 11 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => FULL_SCALE_ADJ_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 12 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH1_INTEGRATOR_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 13 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_INTEGRATOR_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 14 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => COMP_THRES_LOW_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 15 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => COMP_THRES_HIGH_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 16 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH1_PMT_HV_ADJ_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 17 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_PMT_HV_ADJ_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 18 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH1_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 19 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH1_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 20 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH1_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 21 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH1_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 22 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_THRES_LOW_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 23 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_THRES_LOW_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 24 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_THRES_HIGH_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 25 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => CH2_THRES_HIGH_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 26 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => TR_CONDITION_TMP <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 27 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => PRE_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 28 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => PRE_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 29 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => COINC_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 30 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => COINC_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 31 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => POST_TIME_LOAD_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 32 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => POST_TIME_LOAD_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 33 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => STATUS_TMP(7) <= USB_DATA_IN(7);
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 34 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => SPARE_BYTES_TMP(31 downto 24) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 35 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => SPARE_BYTES_TMP(23 downto 16) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 36 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => SPARE_BYTES_TMP(15 downto 8) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 37 then              
              READ_COUNT <= READ_COUNT + 1; 
      		  case (READ_ID) is
      	        when "01010000" => SPARE_BYTES_TMP(7 downto 0) <= USB_DATA_IN;
		        when others =>  -- Do nothing
    	      end case;
            elsif READ_COUNT = 38 then              
              READ_COUNT <= READ_COUNT + 1; 
      	      if READ_ID = "01010000" then
      	        if USB_DATA_IN = "01100110" then
      	          CH1_OFFSET_ADJ_POS <= CH1_OFFSET_ADJ_POS_TMP;
	  			  CH1_OFFSET_ADJ_NEG <= CH1_OFFSET_ADJ_NEG_TMP; 
      	  		  CH2_OFFSET_ADJ_POS <= CH2_OFFSET_ADJ_POS_TMP; 
      	  		  CH2_OFFSET_ADJ_NEG <= CH2_OFFSET_ADJ_NEG_TMP; 
      	  		  CH1_GAIN_ADJ_POS <= CH1_GAIN_ADJ_POS_TMP; 
      	  		  CH1_GAIN_ADJ_NEG <= CH1_GAIN_ADJ_NEG_TMP; 
      	  		  CH2_GAIN_ADJ_POS <= CH2_GAIN_ADJ_POS_TMP; 
      	  		  CH2_GAIN_ADJ_NEG <= CH2_GAIN_ADJ_NEG_TMP; 
      	  		  COMMON_OFFSET_ADJ <= COMMON_OFFSET_ADJ_TMP; 
      	  		  FULL_SCALE_ADJ <= FULL_SCALE_ADJ_TMP; 
      	  		  CH1_INTEGRATOR <= CH1_INTEGRATOR_TMP; 
      	  		  CH2_INTEGRATOR <= CH2_INTEGRATOR_TMP; 
      	  		  COMP_THRES_LOW <= COMP_THRES_LOW_TMP; 
      	  		  COMP_THRES_HIGH <= COMP_THRES_HIGH_TMP; 
      	  		  CH1_PMT_HV_ADJ <= CH1_PMT_HV_ADJ_TMP; 
      	  		  CH2_PMT_HV_ADJ <= CH2_PMT_HV_ADJ_TMP; 
      	  		  CH1_THRES_LOW(15 downto 8) <= CH1_THRES_LOW_TMP(15 downto 8); 
      	  		  CH1_THRES_LOW(7 downto 0) <= CH1_THRES_LOW_TMP(7 downto 0); 
      	  		  CH1_THRES_HIGH(15 downto 8) <= CH1_THRES_HIGH_TMP(15 downto 8); 
      	  		  CH1_THRES_HIGH(7 downto 0) <= CH1_THRES_HIGH_TMP(7 downto 0); 
      	  		  CH2_THRES_LOW(15 downto 8) <= CH2_THRES_LOW_TMP(15 downto 8); 
      	  		  CH2_THRES_LOW(7 downto 0) <= CH2_THRES_LOW_TMP(7 downto 0); 
      	  		  CH2_THRES_HIGH(15 downto 8) <= CH2_THRES_HIGH_TMP(15 downto 8); 
      	  		  CH2_THRES_HIGH(7 downto 0) <= CH2_THRES_HIGH_TMP(7 downto 0); 
      	  	      TR_CONDITION <= TR_CONDITION_TMP; 
      	  		  PRE_TIME_LOAD(15 downto 8) <= PRE_TIME_LOAD_TMP(15 downto 8); 
      	  		  PRE_TIME_LOAD(7 downto 0) <= PRE_TIME_LOAD_TMP(7 downto 0); 
      	  		  COINC_TIME_LOAD(15 downto 8) <= COINC_TIME_LOAD_TMP(15 downto 8); 
      	  		  COINC_TIME_LOAD(7 downto 0) <= COINC_TIME_LOAD_TMP(7 downto 0); 
      	  		  POST_TIME_LOAD(15 downto 8) <= POST_TIME_LOAD_TMP(15 downto 8); 
      	  		  POST_TIME_LOAD(7 downto 0) <= POST_TIME_LOAD_TMP(7 downto 0); 
      	  		  STATUS(7) <= STATUS_TMP(7); 
      	  		  SPARE_BYTES(31 downto 24) <= SPARE_BYTES_TMP(31 downto 24); 
      	  		  SPARE_BYTES(23 downto 16) <= SPARE_BYTES_TMP(23 downto 16); 
      	  		  SPARE_BYTES(15 downto 8) <= SPARE_BYTES_TMP(15 downto 8); 
      	  		  SPARE_BYTES(7 downto 0) <= SPARE_BYTES_TMP(7 downto 0); 
	              STOP_READING <= '1';
      	        else
                  READ_ERROR <= '1';
  		          READ_ERROR_DATA <= "01100110"; -- Missing stop byte
                end if;
              end if;
            elsif READ_COUNT = 39 then              
              READ_ERROR <= '1';
  		      READ_ERROR_DATA <= "01100110"; -- Missing stop byte
            end if;
          end if;
        end if;
      else
        RD_TMP <= '1'; 
        READ_COUNT <= 0;
	    READ_ERROR <= '0';
	    STOP_READING <= '0';
        WRITE_PARAMETER_LIST <= '0';
        SOFT_RESET <= '0';	  
  	    TIME_OUT_COUNT <= (others => '0');
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      PRELOAD_DAC_COUNT <= "000";        
      PRELOAD_DACS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if PRELOAD_DAC_COUNT /= "111" then
        PRELOAD_DAC_COUNT <= PRELOAD_DAC_COUNT + "001";
        PRELOAD_DACS <= '0';
      else
        PRELOAD_DAC_COUNT <= PRELOAD_DAC_COUNT;
        PRELOAD_DACS <= '1';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_OFFSET_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_OFFSET_ADJ_POS /= CH1_OFFSET_ADJ_POS_DEL) then
        SET_CH1_OFFSET_ADJ_POS <= '1';
      elsif CLR_CH1_OFFSET_ADJ_POS = '1' then
        SET_CH1_OFFSET_ADJ_POS <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_OFFSET_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_OFFSET_ADJ_NEG /= CH1_OFFSET_ADJ_NEG_DEL) then
        SET_CH1_OFFSET_ADJ_NEG <= '1';
      elsif CLR_CH1_OFFSET_ADJ_NEG = '1' then
        SET_CH1_OFFSET_ADJ_NEG <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_OFFSET_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_OFFSET_ADJ_POS /= CH2_OFFSET_ADJ_POS_DEL) then
        SET_CH2_OFFSET_ADJ_POS <= '1';
      elsif CLR_CH2_OFFSET_ADJ_POS = '1' then
        SET_CH2_OFFSET_ADJ_POS <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_OFFSET_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_OFFSET_ADJ_NEG /= CH2_OFFSET_ADJ_NEG_DEL) then
        SET_CH2_OFFSET_ADJ_NEG <= '1';
      elsif CLR_CH2_OFFSET_ADJ_NEG = '1' then
        SET_CH2_OFFSET_ADJ_NEG <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_GAIN_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_GAIN_ADJ_POS /= CH1_GAIN_ADJ_POS_DEL) then
        SET_CH1_GAIN_ADJ_POS <= '1';
      elsif CLR_CH1_GAIN_ADJ_POS = '1' then
        SET_CH1_GAIN_ADJ_POS <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_GAIN_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_GAIN_ADJ_NEG /= CH1_GAIN_ADJ_NEG_DEL) then
        SET_CH1_GAIN_ADJ_NEG <= '1';
      elsif CLR_CH1_GAIN_ADJ_NEG = '1' then
        SET_CH1_GAIN_ADJ_NEG <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_GAIN_ADJ_POS <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_GAIN_ADJ_POS /= CH2_GAIN_ADJ_POS_DEL) then
        SET_CH2_GAIN_ADJ_POS <= '1';
      elsif CLR_CH2_GAIN_ADJ_POS = '1' then
        SET_CH2_GAIN_ADJ_POS <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_GAIN_ADJ_NEG <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_GAIN_ADJ_NEG /= CH2_GAIN_ADJ_NEG_DEL) then
        SET_CH2_GAIN_ADJ_NEG <= '1';
      elsif CLR_CH2_GAIN_ADJ_NEG = '1' then
        SET_CH2_GAIN_ADJ_NEG <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_COMMON_OFFSET_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (COMMON_OFFSET_ADJ /= COMMON_OFFSET_ADJ_DEL) then
        SET_COMMON_OFFSET_ADJ <= '1';
      elsif CLR_COMMON_OFFSET_ADJ = '1' then
        SET_COMMON_OFFSET_ADJ <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_FULL_SCALE_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (FULL_SCALE_ADJ /= FULL_SCALE_ADJ_DEL) then
        SET_FULL_SCALE_ADJ <= '1';
      elsif CLR_FULL_SCALE_ADJ = '1' then
        SET_FULL_SCALE_ADJ <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_INTEGRATOR <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_INTEGRATOR /= CH1_INTEGRATOR_DEL) then
        SET_CH1_INTEGRATOR <= '1';
      elsif CLR_CH1_INTEGRATOR = '1' then
        SET_CH1_INTEGRATOR <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_INTEGRATOR <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_INTEGRATOR /= CH2_INTEGRATOR_DEL) then
        SET_CH2_INTEGRATOR <= '1';
      elsif CLR_CH2_INTEGRATOR = '1' then
        SET_CH2_INTEGRATOR <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_COMP_THRES_LOW <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (COMP_THRES_LOW /= COMP_THRES_LOW_DEL) then
        SET_COMP_THRES_LOW <= '1';
      elsif CLR_COMP_THRES_LOW = '1' then
        SET_COMP_THRES_LOW <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_COMP_THRES_HIGH <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (COMP_THRES_HIGH /= COMP_THRES_HIGH_DEL) then
        SET_COMP_THRES_HIGH <= '1';
      elsif CLR_COMP_THRES_HIGH = '1' then
        SET_COMP_THRES_HIGH <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH1_PMT_HV_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH1_PMT_HV_ADJ /= CH1_PMT_HV_ADJ_DEL) then
        SET_CH1_PMT_HV_ADJ <= '1';
      elsif CLR_CH1_PMT_HV_ADJ = '1' then
        SET_CH1_PMT_HV_ADJ <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,PRELOAD_DACS)
  begin
    if PRELOAD_DACS = '0' then
      SET_CH2_PMT_HV_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if (PRELOAD_DACS_DEL1 = '1' and PRELOAD_DACS_DEL2 = '0') or (CH2_PMT_HV_ADJ /= CH2_PMT_HV_ADJ_DEL) then
        SET_CH2_PMT_HV_ADJ <= '1';
      elsif CLR_CH2_PMT_HV_ADJ = '1' then
        SET_CH2_PMT_HV_ADJ <= '0';              
      end if;
    end if;
  end process;  

-- Changes are done because of channelswap on the board.
-- The DAC outputs to the analog channels are driven with the register of the other
-- E.g. If you set the offset of channel 1 (by software), the offset of channel 2 will be set instead
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      WR_DACS <= '1';
      DAC_A2 <= '0';
      DAC_A1 <= '0';
      DAC_A0 <= '0';
      DAC_nCS1 <= '1';
      DAC_nCS2 <= '1';
      DAC_DATA_OUT <= "00000000";        
      CLR_CH1_OFFSET_ADJ_POS <= '0';
      CLR_CH1_OFFSET_ADJ_NEG <= '0';
      CLR_CH2_OFFSET_ADJ_POS <= '0';
      CLR_CH2_OFFSET_ADJ_NEG <= '0';
      CLR_CH1_GAIN_ADJ_POS <= '0';
      CLR_CH1_GAIN_ADJ_NEG <= '0';
      CLR_CH2_GAIN_ADJ_POS <= '0';
      CLR_CH2_GAIN_ADJ_NEG <= '0';
      CLR_COMMON_OFFSET_ADJ <= '0';
      CLR_FULL_SCALE_ADJ <= '0';
      CLR_CH1_INTEGRATOR <= '0';
      CLR_CH2_INTEGRATOR <= '0';
      CLR_COMP_THRES_LOW <= '0';
      CLR_COMP_THRES_HIGH <= '0';
      CLR_CH1_PMT_HV_ADJ <= '0';
      CLR_CH2_PMT_HV_ADJ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if SET_CH1_OFFSET_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_OFFSET_ADJ_POS;
--          DAC_A2 <= '1';
--          DAC_A1 <= '0';
--          DAC_A0 <= '0';
--          DAC_nCS1 <= '0';
--          DAC_nCS2 <= '1';
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH1_OFFSET_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_OFFSET_ADJ_POS <= '0';
        end if;
      elsif SET_CH1_OFFSET_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_OFFSET_ADJ_NEG;
--          DAC_A2 <= '1';
--          DAC_A1 <= '0';
--          DAC_A0 <= '1';
--          DAC_nCS1 <= '0';
--          DAC_nCS2 <= '1';
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH1_OFFSET_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_OFFSET_ADJ_NEG <= '0';
        end if;
      elsif SET_CH2_OFFSET_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_OFFSET_ADJ_POS;
--          DAC_A2 <= '1';
--          DAC_A1 <= '1';
--          DAC_A0 <= '0';
--          DAC_nCS1 <= '0';
--          DAC_nCS2 <= '1';
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH2_OFFSET_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_OFFSET_ADJ_POS <= '0';
        end if;
      elsif SET_CH2_OFFSET_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_OFFSET_ADJ_NEG;
--          DAC_A2 <= '1';
--          DAC_A1 <= '1';
--          DAC_A0 <= '1';
--          DAC_nCS1 <= '0';
--          DAC_nCS2 <= '1';
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_CH2_OFFSET_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_OFFSET_ADJ_NEG <= '0';
        end if;
      elsif SET_CH1_GAIN_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_GAIN_ADJ_POS;
--          DAC_A2 <= '1';
--          DAC_A1 <= '0';
--          DAC_A0 <= '0';
--          DAC_nCS1 <= '1';
--          DAC_nCS2 <= '0';
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_GAIN_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_GAIN_ADJ_POS <= '0';
        end if;
      elsif SET_CH1_GAIN_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_GAIN_ADJ_NEG;
--          DAC_A2 <= '1';
--          DAC_A1 <= '0';
--          DAC_A0 <= '1';
--          DAC_nCS1 <= '1';
--          DAC_nCS2 <= '0';
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_GAIN_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_GAIN_ADJ_NEG <= '0';
        end if;
      elsif SET_CH2_GAIN_ADJ_POS = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_GAIN_ADJ_POS;
--          DAC_A2 <= '1';
--          DAC_A1 <= '1';
--          DAC_A0 <= '0';
--          DAC_nCS1 <= '1';
--          DAC_nCS2 <= '0';
          DAC_A2 <= '1';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_GAIN_ADJ_POS <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_GAIN_ADJ_POS <= '0';
        end if;
      elsif SET_CH2_GAIN_ADJ_NEG = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_GAIN_ADJ_NEG;
--          DAC_A2 <= '1';
--          DAC_A1 <= '1';
--          DAC_A0 <= '1';
--          DAC_nCS1 <= '1';
--          DAC_nCS2 <= '0';
          DAC_A2 <= '1';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_GAIN_ADJ_NEG <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_GAIN_ADJ_NEG <= '0';
        end if;
      elsif SET_COMMON_OFFSET_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= COMMON_OFFSET_ADJ;
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_COMMON_OFFSET_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_COMMON_OFFSET_ADJ <= '0';
        end if;
      elsif SET_FULL_SCALE_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= FULL_SCALE_ADJ;
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_FULL_SCALE_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_FULL_SCALE_ADJ <= '0';
        end if;
      elsif SET_CH1_INTEGRATOR = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_INTEGRATOR;
--          DAC_A2 <= '0';
--          DAC_A1 <= '1';
--          DAC_A0 <= '0';
--          DAC_nCS1 <= '1';
--          DAC_nCS2 <= '0';
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_INTEGRATOR <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_INTEGRATOR <= '0';
        end if;
      elsif SET_CH2_INTEGRATOR = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_INTEGRATOR;
--          DAC_A2 <= '0';
--          DAC_A1 <= '1';
--          DAC_A0 <= '1';
--          DAC_nCS1 <= '1';
--          DAC_nCS2 <= '0';
          DAC_A2 <= '0';
          DAC_A1 <= '1';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_INTEGRATOR <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_INTEGRATOR <= '0';
        end if;
      elsif SET_COMP_THRES_LOW = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= COMP_THRES_LOW;
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_COMP_THRES_LOW <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_COMP_THRES_LOW <= '0';
        end if;
      elsif SET_COMP_THRES_HIGH = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= COMP_THRES_HIGH;
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '0';
          DAC_nCS2 <= '1';
          WR_DACS <= '0';
          CLR_COMP_THRES_HIGH <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_COMP_THRES_HIGH <= '0';
        end if;
      elsif SET_CH1_PMT_HV_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH1_PMT_HV_ADJ;
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '0';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH1_PMT_HV_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH1_PMT_HV_ADJ <= '0';
        end if;
      elsif SET_CH2_PMT_HV_ADJ = '1' then
        if WR_DACS = '1' then
          DAC_DATA_OUT <= CH2_PMT_HV_ADJ;
          DAC_A2 <= '0';
          DAC_A1 <= '0';
          DAC_A0 <= '1';
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '0';
          WR_DACS <= '0';
          CLR_CH2_PMT_HV_ADJ <= '1';
        else
          DAC_nCS1 <= '1';
          DAC_nCS2 <= '1';
          WR_DACS <= '1';
          CLR_CH2_PMT_HV_ADJ <= '0';
        end if;
      end if;
    end if;
  end process;  

  -- Readout Current ADCs
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      SET_CURR_ADC <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then  -- Starts at ONE_PPS
        SET_CURR_ADC <= '1';
      elsif CLR_CURR_ADC = '1' then
        SET_CURR_ADC <= '0';              
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST,CURR_ADC_COUNT,ADC_DATA_IN)
  begin
    if SYSRST = '1' then
      CH1_PMT_SUPPLY_CURR <= "00000000";
      CH2_PMT_SUPPLY_CURR <= "00000000";
      CLR_CURR_ADC <= '0';
      ADC_nRD <= '1';
      ADC_A0 <= '0';
      CURR_ADC_COUNT <= 0;
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if SET_CURR_ADC = '1' then
        CURR_ADC_COUNT <= CURR_ADC_COUNT + 1;
    	case (CURR_ADC_COUNT) is
      	  when 1 => ADC_A0 <= '0'; ADC_nRD <= '1';
      	  when 8 => ADC_A0 <= '0'; ADC_nRD <= '0'; -- 700ns aquisition time
      	  when 36 => ADC_A0 <= '1'; ADC_nRD <= '1'; CH1_PMT_SUPPLY_CURR <= ADC_DATA_IN; -- 2800ns conversion time
      	  when 43 => ADC_A0 <= '1'; ADC_nRD <= '0'; -- 700ns aquisition time
      	  when 71 => ADC_A0 <= '0'; ADC_nRD <= '1'; CH2_PMT_SUPPLY_CURR <= ADC_DATA_IN; CLR_CURR_ADC <= '1'; -- 2800ns conversion time
		  when others =>  -- Do nothing
    	end case;
      else
        CLR_CURR_ADC <= '0';
        ADC_nRD <= '1';
        ADC_A0 <= '0';
        CURR_ADC_COUNT <= 0;
      end if;
    end if;
  end process;  


end rtl ; -- of USB_READ_HANDLER

--------------------------------------------------------------------------------
-- Entity declaration of 'GPS_STUFF'.
-- Last modified : Mon Apr 23 09:04:21 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity GPS_STUFF is
  port(
    ALTITUDE_OUT            : out    std_logic_vector(63 downto 0);
    CLK10MHz                : in     std_logic;
    CLK200MHz               : in     std_logic;
    COINC                   : in     std_logic;
    COMPDATA_OUT            : out    std_logic_vector(127 downto 0);
    COMPDATA_READOUT_DONE   : in     std_logic;
    COMPDATA_VALID_OUT      : out    std_logic;
    COMPH1_IN               : in     std_logic;
    COMPH2_IN               : in     std_logic;
    COMPL1_IN               : in     std_logic;
    COMPL2_IN               : in     std_logic;
    CTD_OUT                 : out    std_logic_vector(31 downto 0);
    CTD_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
    CTP_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
    GPS_PROG_ENABLE         : in     std_logic;
    GPS_SDI                 : out    std_logic;
    GPS_SDO                 : in     std_logic;
    GPS_TS_ONE_PPS_OUT      : out    std_logic_vector(55 downto 0);
    GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
    LATITUDE_OUT            : out    std_logic_vector(63 downto 0);
    LONGITUDE_OUT           : out    std_logic_vector(63 downto 0);
    MASTER                  : out    std_logic;
    ONE_PPS                 : in     std_logic;
    RXD                     : in     std_logic;
    SAT_INFO_OUT            : out    std_logic_vector(487 downto 0);
    SPY_CON                 : in     std_logic;
    SPY_SDI                 : out    std_logic;
    SPY_SDO                 : in     std_logic;
    SYSRST                  : in     std_logic;
    TEMP_OUT                : out    std_logic_vector(31 downto 0);
    TS_ONE_PPS_READOUT_DONE : in     std_logic;
    TS_ONE_PPS_VALID_OUT    : out    std_logic);
end GPS_STUFF ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'GPS_STUFF'
-- Last modified : Mon Apr 23 09:04:21 2007.
--------------------------------------------------------------------------------

architecture rtl of GPS_STUFF is

signal COUNTER_153600 : std_logic_vector (6 downto 0); -- Counter at 153600Hz; Sample counter
signal CLK_153600 : std_logic;  

signal COUNTER_ONE_SEC_SEVEN : std_logic_vector (18 downto 0); -- Counter at 1.7 seconds; Time out counter for RXD; used for GPS master detection
signal COUNTER_ONE_SEC_SEVEN_DEL : std_logic; -- Delayed COUNTER_ONE_SEC_SEVEN(18) bit
signal RXD_TIME_OUT : std_logic_vector (1 downto 0); -- Time out counter for RXD; Counts 3 counts of COUNTER_ONE_SEC_SEVEN
signal GPS_SDO_DEL : std_logic; 

signal SAMPLE_COUNT : integer range 168 downto 0; -- Counter which samples the incomming serial data
signal TIME_OUT_COUNT : integer range 1760 downto 0; --10 bytes (16 times oversampling; 11 bits per byte (8xdata + parity, start and stop)) 
signal TIME_OUT : std_logic; -- Reset when there is 10 bytes long no data
signal RST_MESSAGE : std_logic; -- This is a OR of TIME_OUT and when there is an END byte detected in one of the three messages (END_BYTE_DETECTED)
signal DECODER_BYTE_COUNT : integer range 99 downto 0; -- Counts valid (not stuffed) number of bytes in the serial data stream
signal GET_BYTE : std_logic_vector (7 downto 0); -- This byte stores the serial bits
signal MESSAGE_BYTE1 : std_logic_vector (7 downto 0); -- This byte stores the first GET_BYTE
signal MESSAGE_BYTE2 : std_logic_vector (7 downto 0); -- This byte stores the second GET_BYTE
signal MESSAGE_BYTE3 : std_logic_vector (7 downto 0); -- This byte stores the third GET_BYTE
signal DECODE_BYTE1 : std_logic_vector (7 downto 0); -- This byte stores a GET_BYTE in the message
signal MESSAGE_SELECT : std_logic_vector (1 downto 0); -- "00" means nothing selected; "01" means 8F-AB selected; "10" means 8F-AC selected; "11" means 47 selected;
signal STUFFED_BYTE : std_logic; -- This bit is thrue when there is a stuffed byte; in other words: an even number of 0x10 bytes 
signal END_BYTE_DETECTED : std_logic; -- This bit is thrue when a odd number of 0x10 bytes and a 0x03 byte is detected
signal DUMP  : std_logic_vector (7 downto 0); -- Dump byte for case statement to satisfy Modelsim
signal GPS_SEC  : std_logic_vector (7 downto 0); -- Seconds (0 to 59)
signal GPS_MIN   : std_logic_vector (7 downto 0); -- Minutes (0 to 59)
signal GPS_HOUR   : std_logic_vector (7 downto 0); -- Hours (0 to 23)
signal GPS_DAY   : std_logic_vector (7 downto 0); -- Day (1 to 31)
signal GPS_MONTH   : std_logic_vector (7 downto 0); -- Month (1 to 12)
signal GPS_YEAR1   : std_logic_vector (7 downto 0); -- Year Higher byte
signal GPS_YEAR0   : std_logic_vector (7 downto 0); -- Year Lower byte
signal GPS_SEC_BUF  : std_logic_vector (7 downto 0); -- Buffering needed to stabilize the data during a COINC
signal GPS_MIN_BUF   : std_logic_vector (7 downto 0); 
signal GPS_HOUR_BUF   : std_logic_vector (7 downto 0); 
signal GPS_DAY_BUF   : std_logic_vector (7 downto 0); 
signal GPS_MONTH_BUF   : std_logic_vector (7 downto 0); 
signal GPS_YEAR1_BUF   : std_logic_vector (7 downto 0); 
signal GPS_YEAR0_BUF   : std_logic_vector (7 downto 0); 
signal GPS_TEMP3   : std_logic_vector (7 downto 0); -- Temperture Higher byte
signal GPS_TEMP2   : std_logic_vector (7 downto 0); -- Temperture 
signal GPS_TEMP1   : std_logic_vector (7 downto 0); -- Temperture 
signal GPS_TEMP0   : std_logic_vector (7 downto 0); -- Temperture Lower byte
signal GPS_LAT7  : std_logic_vector (7 downto 0); -- Latitude Higher byte
signal GPS_LAT6  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT5  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT4  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT3  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT2  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT1  : std_logic_vector (7 downto 0); -- Latitude
signal GPS_LAT0  : std_logic_vector (7 downto 0); -- Latitude Lower byte
signal GPS_LONG7  : std_logic_vector (7 downto 0); -- Longitude Higher byte
signal GPS_LONG6  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG5  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG4  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG3  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG2  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG1  : std_logic_vector (7 downto 0); -- Longitude
signal GPS_LONG0  : std_logic_vector (7 downto 0); -- Longitude Lower byte
signal GPS_ALT7  : std_logic_vector (7 downto 0); -- Altitude Higher byte
signal GPS_ALT6  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT5  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT4  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT3  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT2  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT1  : std_logic_vector (7 downto 0); -- Altitude
signal GPS_ALT0  : std_logic_vector (7 downto 0); -- Altitude Lower byte
signal GPS_QUANT3  : std_logic_vector (7 downto 0); -- PPS Quantization error Higher byte
signal GPS_QUANT2  : std_logic_vector (7 downto 0); -- PPS Quantization error
signal GPS_QUANT1  : std_logic_vector (7 downto 0); -- PPS Quantization error
signal GPS_QUANT0  : std_logic_vector (7 downto 0); -- PPS Quantization error Lower byte
signal GPS_SATCOUNT  : std_logic_vector (7 downto 0); -- Number of tracked satellites
signal GPS_SATNUM1  : std_logic_vector (7 downto 0); -- Number of satellite 1
signal GPS_SAT1LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SAT1LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SAT1LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SAT1LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 1
signal GPS_SATNUM2  : std_logic_vector (7 downto 0); -- Number of satellite 2
signal GPS_SAT2LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SAT2LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SAT2LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SAT2LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 2
signal GPS_SATNUM3  : std_logic_vector (7 downto 0); -- Number of satellite 3
signal GPS_SAT3LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SAT3LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SAT3LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SAT3LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 3
signal GPS_SATNUM4  : std_logic_vector (7 downto 0); -- Number of satellite 4
signal GPS_SAT4LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SAT4LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SAT4LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SAT4LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 4
signal GPS_SATNUM5  : std_logic_vector (7 downto 0); -- Number of satellite 5
signal GPS_SAT5LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SAT5LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SAT5LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SAT5LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 5
signal GPS_SATNUM6  : std_logic_vector (7 downto 0); -- Number of satellite 6
signal GPS_SAT6LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SAT6LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SAT6LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SAT6LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 6
signal GPS_SATNUM7  : std_logic_vector (7 downto 0); -- Number of satellite 7
signal GPS_SAT7LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SAT7LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SAT7LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SAT7LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 7
signal GPS_SATNUM8  : std_logic_vector (7 downto 0); -- Number of satellite 8
signal GPS_SAT8LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SAT8LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SAT8LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SAT8LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 8
signal GPS_SATNUM9  : std_logic_vector (7 downto 0); -- Number of satellite 9
signal GPS_SAT9LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SAT9LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SAT9LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SAT9LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 9
signal GPS_SATNUM10  : std_logic_vector (7 downto 0); -- Number of satellite 10
signal GPS_SAT10LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SAT10LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SAT10LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SAT10LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 10
signal GPS_SATNUM11  : std_logic_vector (7 downto 0); -- Number of satellite 11
signal GPS_SAT11LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SAT11LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SAT11LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SAT11LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 11
signal GPS_SATNUM12  : std_logic_vector (7 downto 0); -- Number of satellite 12
signal GPS_SAT12LEV3  : std_logic_vector (7 downto 0); -- Signal level of satellite 12
signal GPS_SAT12LEV2  : std_logic_vector (7 downto 0); -- Signal level of satellite 12
signal GPS_SAT12LEV1  : std_logic_vector (7 downto 0); -- Signal level of satellite 12
signal GPS_SAT12LEV0  : std_logic_vector (7 downto 0); -- Signal level of satellite 12

signal COINC_DEL: std_logic ;
signal CTP_COUNT: std_logic_vector(31 downto 0);
signal NEG_FASE_BIT: std_logic ; -- This signal clocks the one PPS signal on the negative fase of the CLK200MHz clock to determine the offset 2.5ns better
signal NEG_FASE_BIT_DEL: std_logic ; -- NEG_FASE_BIT after a negative edge of the CLK200MHz clock
signal ONE_PPS_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious ONE_PPS with the 200MHz
signal ONE_PPS_DEL2: std_logic ;
signal ONE_PPS_SLOW_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious ONE_PPS with the 10MHz
signal ONE_PPS_SLOW_DEL2: std_logic ;
signal ONE_PPS_SLOW_DEL3: std_logic ;
signal TS_ONE_PPS_READOUT_DONE_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious TS_ONE_PPS_READOUT_DONE with the 200MHz
signal TS_ONE_PPS_READOUT_DONE_DEL2: std_logic ;

signal COMPL1_IN_DEL1: std_logic ; 
signal COMPL1_IN_DEL2: std_logic ; 
signal COMPH1_IN_DEL1: std_logic ; 
signal COMPH1_IN_DEL2: std_logic ; 
signal COMPL2_IN_DEL1: std_logic ; 
signal COMPL2_IN_DEL2: std_logic ; 
signal COMPH2_IN_DEL1: std_logic ; 
signal COMPH2_IN_DEL2: std_logic ; 
signal COMPL1_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPL1 is high
signal COMPH1_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPH1 is high
signal COMPL2_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPL2 is high
signal COMPH2_COUNT: std_logic_vector(31 downto 0); -- Counts the time COMPH2 is high
signal COMPL1_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPL1
signal COMPH1_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPH1
signal COMPL2_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPL2
signal COMPH2_TIMESTAMP: std_logic_vector(87 downto 0); -- Latches the time on a rising edge of COMPH2
signal RST_COMPL1: std_logic ; -- Reset signal synchronized at 200MHz 
signal RST_COMPH1: std_logic ; -- Reset signal synchronized at 200MHz 
signal RST_COMPL2: std_logic ; -- Reset signal synchronized at 200MHz 
signal RST_COMPH2: std_logic ; -- Reset signal synchronized at 200MHz 
signal RST_COMPL1_10MHZ: std_logic ; 
signal RST_COMPH1_10MHZ: std_logic ; 
signal RST_COMPL2_10MHZ: std_logic ; 
signal RST_COMPH2_10MHZ: std_logic ; 
signal VALID_COMPL1: std_logic ; 
signal VALID_COMPH1: std_logic ; 
signal VALID_COMPL2: std_logic ; 
signal VALID_COMPH2: std_logic ; 
signal VALID_COMPL1_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz
signal VALID_COMPH1_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz 
signal VALID_COMPL2_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz 
signal VALID_COMPH2_10MHZ: std_logic ; -- Valid signal synchronized at 10MHz 
signal COMPDATA_READOUT_DONE_DEL1: std_logic ; 
signal COMPDATA_READOUT_DONE_DEL2: std_logic ; 
signal COMPDATA_VALID_OUT_TMP: std_logic ; 

begin
  

  GPS_SDI <= SPY_SDO and GPS_PROG_ENABLE; 
  SPY_SDI <= GPS_SDO when SPY_CON = '1' else 'Z'; 


-- 153600HZ counter/clock 
-- Used for sampling the serial RS232 data at 16 times the bautrate of 9600Hz
-- This is actual 153850Hz (10Mhz divide by 65); Mismatch is 0.16%                  
  process (CLK10MHz, SYSRST)
  begin
	if SYSRST = '1' then
	  COUNTER_153600 <= (others => '0');                 
	elsif CLK10MHz'event and CLK10MHz = '1' then
	  if COUNTER_153600 >= "1000000" then -- 10Mhz divide by 65 (from 0 to 64)
		COUNTER_153600 <= (others => '0');
		CLK_153600 <= '1';
	  else
		COUNTER_153600<= COUNTER_153600 + "0000001";
		CLK_153600 <= '0';
	  end if;
	end if;
  end process;

 -- Counter at 1.7 seconds; Time out counter for RXD; used for GPS master detection 
  process(CLK_153600, SYSRST) 
  begin
 	if SYSRST = '1' then
  	  COUNTER_ONE_SEC_SEVEN <= (others => '0');
  	  COUNTER_ONE_SEC_SEVEN_DEL <= '0';
  	  GPS_SDO_DEL <= '0';
  	elsif CLK_153600'event and CLK_153600 = '1' then
   	  COUNTER_ONE_SEC_SEVEN <= COUNTER_ONE_SEC_SEVEN + "0000000000000000001";
  	  COUNTER_ONE_SEC_SEVEN_DEL <= COUNTER_ONE_SEC_SEVEN(18);
  	  GPS_SDO_DEL <= GPS_SDO;
 	end if; 
  end process; 

 -- Master detection 
  process(CLK_153600, SYSRST) 
  begin
 	if SYSRST = '1' then
  	  RXD_TIME_OUT <= "11"; -- Default in Slave mode
  	elsif CLK_153600'event and CLK_153600 = '1' then
  	  if GPS_SDO = '0' and GPS_SDO_DEL = '1' then -- Negative edge of TXD GPS reciever output
  	    RXD_TIME_OUT <= "00"; -- Sets RXD_TIME_OUT in Master mode
      elsif RXD_TIME_OUT = "11" then
  	    RXD_TIME_OUT <= RXD_TIME_OUT;
  	  elsif COUNTER_ONE_SEC_SEVEN(18) = '1' and COUNTER_ONE_SEC_SEVEN_DEL = '0' then -- Rising edge of 1.7s clock
  	    RXD_TIME_OUT <= RXD_TIME_OUT + "01";
 	  end if; 
 	end if; 
  end process; 

  MASTER <= '0' when RXD_TIME_OUT = "11" else '1'; 


------------------ Start Recieving GPS data -----------------------------------------

 -- Sample counter
  process(CLK_153600, SYSRST)                               
  begin
 	if SYSRST = '1' then
  	  SAMPLE_COUNT <= 0;
  	elsif CLK_153600'event and CLK_153600 = '1' then
  	  if SAMPLE_COUNT = 0 and RXD = '1' then
   		SAMPLE_COUNT <= 0 ; -- wait for start 
      elsif SAMPLE_COUNT = 8 and RXD = '1' then
   		SAMPLE_COUNT <= 0 ; -- false start
   	  elsif SAMPLE_COUNT = 168 then 
   		SAMPLE_COUNT <= 0; -- end
      else
   		SAMPLE_COUNT <= SAMPLE_COUNT + 1;
   	  end if;
 	end if; 
  end process;

 -- TIME_OUT counter
 -- This counter counts if there is 1 bytes (176 counts) long no input data (RXD = '1') 
 -- After this, the counter latches itself till a startbit  (RXD = '0')
  process(CLK_153600, SYSRST) 
  begin
 	if SYSRST = '1' then
  	  TIME_OUT_COUNT <= 0;
  	elsif CLK_153600'event and CLK_153600 = '1' then
  	  if RXD = '0' then
  		TIME_OUT_COUNT <= 0; 
  	  elsif TIME_OUT_COUNT = 1760 then
  		TIME_OUT_COUNT <= TIME_OUT_COUNT;
  	  else
   		TIME_OUT_COUNT <= TIME_OUT_COUNT + 1;
      end if;
 	end if; 
  end process; 

  TIME_OUT <= '1' when TIME_OUT_COUNT = 1760 else '0'; 

  RST_MESSAGE <= TIME_OUT or END_BYTE_DETECTED;

  -- Filling of GET_BYTE
  process(CLK_153600, SYSRST)                               
  begin
 	if SYSRST = '1' then
  	  GET_BYTE <= (others => '0');
  	elsif CLK_153600'event and CLK_153600 = '1' then
      if SAMPLE_COUNT = 24 then
        GET_BYTE(0) <= RXD;
      end if;
      if SAMPLE_COUNT = 40 then
        GET_BYTE(1) <= RXD;
      end if;
      if SAMPLE_COUNT = 56 then
        GET_BYTE(2) <= RXD;
      end if;
      if SAMPLE_COUNT = 72 then
        GET_BYTE(3) <= RXD;
      end if;
      if SAMPLE_COUNT = 88 then
        GET_BYTE(4) <= RXD;
      end if;
      if SAMPLE_COUNT = 104 then
        GET_BYTE(5) <= RXD;
      end if;
      if SAMPLE_COUNT = 120 then
        GET_BYTE(6) <= RXD;
      end if;
      if SAMPLE_COUNT = 136 then
        GET_BYTE(7) <= RXD;
      end if;
    end if;
  end process;
        
  -- Filling of MESSAGE_BYTE's
  process(CLK_153600, SYSRST)                               
  begin
 	if SYSRST = '1' then
  	  MESSAGE_BYTE1 <= (others => '0');
  	  MESSAGE_BYTE2 <= (others => '0');
  	  MESSAGE_BYTE3 <= (others => '0');
  	elsif CLK_153600'event and CLK_153600 = '1' then
  	  if RST_MESSAGE = '1' then
  	    MESSAGE_BYTE1 <= (others => '0');
  	    MESSAGE_BYTE2 <= (others => '0');
  	    MESSAGE_BYTE3 <= (others => '0');
      elsif SAMPLE_COUNT = 144 then
        if STUFFED_BYTE = '0' then
          MESSAGE_BYTE1 <= GET_BYTE;
        end if;
          MESSAGE_BYTE2 <= MESSAGE_BYTE1;
          MESSAGE_BYTE3 <= MESSAGE_BYTE2;
      end if;
    end if;
  end process;

  -- MESSAGE_SELECT
  process(CLK_153600, SYSRST)                               
  begin
 	if SYSRST = '1' then
  	  MESSAGE_SELECT <= "00";
  	elsif CLK_153600'event and CLK_153600 = '1' then
  	  if RST_MESSAGE = '1' then
  	    MESSAGE_SELECT <= "00";
      elsif MESSAGE_BYTE3 = "00010000" and MESSAGE_BYTE2 = "10001111" and MESSAGE_BYTE1 = "10101011" then
  	    MESSAGE_SELECT <= "01";
      elsif MESSAGE_BYTE3 = "00010000" and MESSAGE_BYTE2 = "10001111" and MESSAGE_BYTE1 = "10101100" then
  	    MESSAGE_SELECT <= "10";
      elsif MESSAGE_BYTE2 = "00010000" and MESSAGE_BYTE1 = "01000111" then
  	    MESSAGE_SELECT <= "11";
      end if;
    end if;
  end process;

  -- MESSAGE decoding
  process(CLK_153600,SYSRST,DECODER_BYTE_COUNT,DECODE_BYTE1)                               
  begin
 	if SYSRST = '1' then
  	  STUFFED_BYTE <= '0';
  	  END_BYTE_DETECTED <= '0';
  	  DECODE_BYTE1 <= (others => '0');
  	  DECODER_BYTE_COUNT <= 0;
  	  GPS_SEC <= (others => '0');
  	  GPS_MIN <= (others => '0');
  	  GPS_HOUR <= (others => '0');
  	  GPS_DAY <= (others => '0');
  	  GPS_MONTH <= (others => '0');
  	  GPS_YEAR1 <= (others => '0');
  	  GPS_YEAR0 <= (others => '0');
  	  GPS_TEMP3 <= (others => '0');
  	  GPS_TEMP2 <= (others => '0');
  	  GPS_TEMP1 <= (others => '0');
  	  GPS_TEMP0 <= (others => '0');
  	  GPS_LAT7 <= (others => '0');
  	  GPS_LAT6 <= (others => '0');
  	  GPS_LAT5 <= (others => '0');
  	  GPS_LAT4 <= (others => '0');
  	  GPS_LAT3 <= (others => '0');
  	  GPS_LAT2 <= (others => '0');
  	  GPS_LAT1 <= (others => '0');
  	  GPS_LAT0 <= (others => '0');
  	  GPS_LONG7 <= (others => '0');
  	  GPS_LONG6 <= (others => '0');
  	  GPS_LONG5 <= (others => '0');
  	  GPS_LONG4 <= (others => '0');
  	  GPS_LONG3 <= (others => '0');
  	  GPS_LONG2 <= (others => '0');
  	  GPS_LONG1 <= (others => '0');
  	  GPS_LONG0 <= (others => '0');
  	  GPS_ALT7 <= (others => '0');
  	  GPS_ALT6 <= (others => '0');
  	  GPS_ALT5 <= (others => '0');
  	  GPS_ALT4 <= (others => '0');
  	  GPS_ALT3 <= (others => '0');
  	  GPS_ALT2 <= (others => '0');
  	  GPS_ALT1 <= (others => '0');
  	  GPS_ALT0 <= (others => '0');
  	  GPS_QUANT3 <= (others => '0');
  	  GPS_QUANT2 <= (others => '0');
  	  GPS_QUANT1 <= (others => '0');
  	  GPS_QUANT0 <= (others => '0');
  	  GPS_SATCOUNT <= (others => '0');
  	  GPS_SATNUM1 <= (others => '0');
  	  GPS_SAT1LEV3 <= (others => '0');
  	  GPS_SAT1LEV2 <= (others => '0');
  	  GPS_SAT1LEV1 <= (others => '0');
  	  GPS_SAT1LEV0 <= (others => '0');
  	  GPS_SATNUM2 <= (others => '0');
  	  GPS_SAT2LEV3 <= (others => '0');
  	  GPS_SAT2LEV2 <= (others => '0');
  	  GPS_SAT2LEV1 <= (others => '0');
  	  GPS_SAT2LEV0 <= (others => '0');
  	  GPS_SATNUM3 <= (others => '0');
  	  GPS_SAT3LEV3 <= (others => '0');
  	  GPS_SAT3LEV2 <= (others => '0');
  	  GPS_SAT3LEV1 <= (others => '0');
  	  GPS_SAT3LEV0 <= (others => '0');
  	  GPS_SATNUM4 <= (others => '0');
  	  GPS_SAT4LEV3 <= (others => '0');
  	  GPS_SAT4LEV2 <= (others => '0');
  	  GPS_SAT4LEV1 <= (others => '0');
  	  GPS_SAT4LEV0 <= (others => '0');
  	  GPS_SATNUM5 <= (others => '0');
  	  GPS_SAT5LEV3 <= (others => '0');
  	  GPS_SAT5LEV2 <= (others => '0');
  	  GPS_SAT5LEV1 <= (others => '0');
  	  GPS_SAT5LEV0 <= (others => '0');
  	  GPS_SATNUM6 <= (others => '0');
  	  GPS_SAT6LEV3 <= (others => '0');
  	  GPS_SAT6LEV2 <= (others => '0');
  	  GPS_SAT6LEV1 <= (others => '0');
  	  GPS_SAT6LEV0 <= (others => '0');
  	  GPS_SATNUM7 <= (others => '0');
  	  GPS_SAT7LEV3 <= (others => '0');
  	  GPS_SAT7LEV2 <= (others => '0');
  	  GPS_SAT7LEV1 <= (others => '0');
  	  GPS_SAT7LEV0 <= (others => '0');
  	  GPS_SATNUM8 <= (others => '0');
  	  GPS_SAT8LEV3 <= (others => '0');
  	  GPS_SAT8LEV2 <= (others => '0');
  	  GPS_SAT8LEV1 <= (others => '0');
  	  GPS_SAT8LEV0 <= (others => '0');
  	  GPS_SATNUM9 <= (others => '0');
  	  GPS_SAT9LEV3 <= (others => '0');
  	  GPS_SAT9LEV2 <= (others => '0');
  	  GPS_SAT9LEV1 <= (others => '0');
  	  GPS_SAT9LEV0 <= (others => '0');
  	  GPS_SATNUM10 <= (others => '0');
  	  GPS_SAT10LEV3 <= (others => '0');
  	  GPS_SAT10LEV2 <= (others => '0');
  	  GPS_SAT10LEV1 <= (others => '0');
  	  GPS_SAT10LEV0 <= (others => '0');
  	  GPS_SATNUM11 <= (others => '0');
  	  GPS_SAT11LEV3 <= (others => '0');
  	  GPS_SAT11LEV2 <= (others => '0');
  	  GPS_SAT11LEV1 <= (others => '0');
  	  GPS_SAT11LEV0 <= (others => '0');
  	  GPS_SATNUM12 <= (others => '0');
  	  GPS_SAT12LEV3 <= (others => '0');
  	  GPS_SAT12LEV2 <= (others => '0');
  	  GPS_SAT12LEV1 <= (others => '0');
  	  GPS_SAT12LEV0 <= (others => '0');

  	elsif CLK_153600'event and CLK_153600 = '1' then
  	  if RST_MESSAGE = '1' then
  	    STUFFED_BYTE <= '0';
  	    DECODE_BYTE1 <= (others => '0');
  	    END_BYTE_DETECTED <= '0';
  	    DECODER_BYTE_COUNT <= 0;
      elsif SAMPLE_COUNT = 144 and MESSAGE_SELECT /= "00" then
        DECODE_BYTE1 <= GET_BYTE;
        if GET_BYTE = "00010000" and DECODE_BYTE1 = "00010000" then
  	      STUFFED_BYTE <= not STUFFED_BYTE;
        else
  	      STUFFED_BYTE <= '0';
        end if;
        if STUFFED_BYTE = '0' and GET_BYTE = "00000011" and DECODE_BYTE1 = "00010000" then
  	      END_BYTE_DETECTED <= '1'; 
  	     else  
  	      END_BYTE_DETECTED <= '0';
        end if;
        if STUFFED_BYTE = '0' then
          DECODER_BYTE_COUNT <= DECODER_BYTE_COUNT + 1;
        end if;
      end if;
      if MESSAGE_SELECT = "01" and SAMPLE_COUNT = 144 and STUFFED_BYTE = '0' then
   	    case DECODER_BYTE_COUNT is
   	      when 10 => GPS_SEC <= DECODE_BYTE1;    
   	      when 11 => GPS_MIN <= DECODE_BYTE1;    
   	      when 12 => GPS_HOUR <= DECODE_BYTE1;    
   	      when 13 => GPS_DAY <= DECODE_BYTE1;    
   	      when 14 => GPS_MONTH <= DECODE_BYTE1;    
   	      when 15 => GPS_YEAR1 <= DECODE_BYTE1;    
   	      when 16 => GPS_YEAR0 <= DECODE_BYTE1;    
          when others => DUMP <=  DECODE_BYTE1;      
        end case;
      end if;
      if MESSAGE_SELECT = "10" and SAMPLE_COUNT = 144 and STUFFED_BYTE = '0' then
   	    case DECODER_BYTE_COUNT is
   	      when 32 => GPS_TEMP3 <= DECODE_BYTE1;    
   	      when 33 => GPS_TEMP2 <= DECODE_BYTE1;    
   	      when 34 => GPS_TEMP1 <= DECODE_BYTE1;    
   	      when 35 => GPS_TEMP0 <= DECODE_BYTE1;    
   	      when 36 => GPS_LAT7 <= DECODE_BYTE1;    
   	      when 37 => GPS_LAT6 <= DECODE_BYTE1;    
   	      when 38 => GPS_LAT5 <= DECODE_BYTE1;    
   	      when 39 => GPS_LAT4 <= DECODE_BYTE1;    
   	      when 40 => GPS_LAT3 <= DECODE_BYTE1;    
   	      when 41 => GPS_LAT2 <= DECODE_BYTE1;    
   	      when 42 => GPS_LAT1 <= DECODE_BYTE1;    
   	      when 43 => GPS_LAT0 <= DECODE_BYTE1;    
   	      when 44 => GPS_LONG7 <= DECODE_BYTE1;    
   	      when 45 => GPS_LONG6 <= DECODE_BYTE1;    
   	      when 46 => GPS_LONG5 <= DECODE_BYTE1;    
   	      when 47 => GPS_LONG4 <= DECODE_BYTE1;    
   	      when 48 => GPS_LONG3 <= DECODE_BYTE1;    
   	      when 49 => GPS_LONG2 <= DECODE_BYTE1;    
   	      when 50 => GPS_LONG1 <= DECODE_BYTE1;    
   	      when 51 => GPS_LONG0 <= DECODE_BYTE1;    
   	      when 52 => GPS_ALT7 <= DECODE_BYTE1;    
   	      when 53 => GPS_ALT6 <= DECODE_BYTE1;    
   	      when 54 => GPS_ALT5 <= DECODE_BYTE1;    
   	      when 55 => GPS_ALT4 <= DECODE_BYTE1;    
   	      when 56 => GPS_ALT3 <= DECODE_BYTE1;    
   	      when 57 => GPS_ALT2 <= DECODE_BYTE1;    
   	      when 58 => GPS_ALT1 <= DECODE_BYTE1;    
   	      when 59 => GPS_ALT0 <= DECODE_BYTE1;    
   	      when 60 => GPS_QUANT3 <= DECODE_BYTE1;    
   	      when 61 => GPS_QUANT2 <= DECODE_BYTE1;    
   	      when 62 => GPS_QUANT1 <= DECODE_BYTE1;    
   	      when 63 => GPS_QUANT0 <= DECODE_BYTE1;    
          when others => DUMP <=  DECODE_BYTE1;      
        end case;
      end if;
      if MESSAGE_SELECT = "11" and SAMPLE_COUNT = 144 and STUFFED_BYTE = '0' and not (GET_BYTE = "00000011" and DECODE_BYTE1 = "00010000") then
   	    case DECODER_BYTE_COUNT is
   	      when 1 => GPS_SATCOUNT <= DECODE_BYTE1;    
   	        	    GPS_SATNUM1 <= (others => '0');
  	                GPS_SAT1LEV3 <= (others => '0');
  	                GPS_SAT1LEV2 <= (others => '0');
  	                GPS_SAT1LEV1 <= (others => '0');
  	                GPS_SAT1LEV0 <= (others => '0');
  	                GPS_SATNUM2 <= (others => '0');
  	                GPS_SAT2LEV3 <= (others => '0');
  	                GPS_SAT2LEV2 <= (others => '0');
  	                GPS_SAT2LEV1 <= (others => '0');
  	                GPS_SAT2LEV0 <= (others => '0');
  	                GPS_SATNUM3 <= (others => '0');
  	                GPS_SAT3LEV3 <= (others => '0');
  	                GPS_SAT3LEV2 <= (others => '0');
  	                GPS_SAT3LEV1 <= (others => '0');
  	                GPS_SAT3LEV0 <= (others => '0');
  	                GPS_SATNUM4 <= (others => '0');
  	                GPS_SAT4LEV3 <= (others => '0');
  	                GPS_SAT4LEV2 <= (others => '0');
  	                GPS_SAT4LEV1 <= (others => '0');
  	                GPS_SAT4LEV0 <= (others => '0');
  	                GPS_SATNUM5 <= (others => '0');
  	                GPS_SAT5LEV3 <= (others => '0');
  	                GPS_SAT5LEV2 <= (others => '0');
  	                GPS_SAT5LEV1 <= (others => '0');
  	                GPS_SAT5LEV0 <= (others => '0');
  	                GPS_SATNUM6 <= (others => '0');
  	                GPS_SAT6LEV3 <= (others => '0');
  	                GPS_SAT6LEV2 <= (others => '0');
  	                GPS_SAT6LEV1 <= (others => '0');
  	                GPS_SAT6LEV0 <= (others => '0');
  	                GPS_SATNUM7 <= (others => '0');
  	                GPS_SAT7LEV3 <= (others => '0');
  	                GPS_SAT7LEV2 <= (others => '0');
  	                GPS_SAT7LEV1 <= (others => '0');
  	                GPS_SAT7LEV0 <= (others => '0');
  	                GPS_SATNUM8 <= (others => '0');
  	                GPS_SAT8LEV3 <= (others => '0');
  	                GPS_SAT8LEV2 <= (others => '0');
  	                GPS_SAT8LEV1 <= (others => '0');
  	                GPS_SAT8LEV0 <= (others => '0');
  	                GPS_SATNUM9 <= (others => '0');
  	                GPS_SAT9LEV3 <= (others => '0');
  	                GPS_SAT9LEV2 <= (others => '0');
  	                GPS_SAT9LEV1 <= (others => '0');
  	                GPS_SAT9LEV0 <= (others => '0');
  	                GPS_SATNUM10 <= (others => '0');
  	                GPS_SAT10LEV3 <= (others => '0');
  	                GPS_SAT10LEV2 <= (others => '0');
  	                GPS_SAT10LEV1 <= (others => '0');
  	                GPS_SAT10LEV0 <= (others => '0');
  	                GPS_SATNUM11 <= (others => '0');
  	                GPS_SAT11LEV3 <= (others => '0');
  	                GPS_SAT11LEV2 <= (others => '0');
  	                GPS_SAT11LEV1 <= (others => '0');
  	                GPS_SAT11LEV0 <= (others => '0');
  	                GPS_SATNUM12 <= (others => '0');
  	                GPS_SAT12LEV3 <= (others => '0');
  	                GPS_SAT12LEV2 <= (others => '0');
  	                GPS_SAT12LEV1 <= (others => '0');
  	                GPS_SAT12LEV0 <= (others => '0');
   	      when 2 => GPS_SATNUM1 <= DECODE_BYTE1;    
   	      when 3 => GPS_SAT1LEV3 <= DECODE_BYTE1;    
   	      when 4 => GPS_SAT1LEV2 <= DECODE_BYTE1;    
   	      when 5 => GPS_SAT1LEV1 <= DECODE_BYTE1;    
   	      when 6 => GPS_SAT1LEV0 <= DECODE_BYTE1;    
   	      when 7 => GPS_SATNUM2 <= DECODE_BYTE1;    
   	      when 8 => GPS_SAT2LEV3 <= DECODE_BYTE1;    
   	      when 9 => GPS_SAT2LEV2 <= DECODE_BYTE1;    
   	      when 10 => GPS_SAT2LEV1 <= DECODE_BYTE1;    
   	      when 11 => GPS_SAT2LEV0 <= DECODE_BYTE1;    
   	      when 12 => GPS_SATNUM3 <= DECODE_BYTE1;    
   	      when 13 => GPS_SAT3LEV3 <= DECODE_BYTE1;    
   	      when 14 => GPS_SAT3LEV2 <= DECODE_BYTE1;    
   	      when 15 => GPS_SAT3LEV1 <= DECODE_BYTE1;    
   	      when 16 => GPS_SAT3LEV0 <= DECODE_BYTE1;    
   	      when 17 => GPS_SATNUM4 <= DECODE_BYTE1;    
   	      when 18 => GPS_SAT4LEV3 <= DECODE_BYTE1;    
   	      when 19 => GPS_SAT4LEV2 <= DECODE_BYTE1;    
   	      when 20 => GPS_SAT4LEV1 <= DECODE_BYTE1;    
   	      when 21 => GPS_SAT4LEV0 <= DECODE_BYTE1;    
   	      when 22 => GPS_SATNUM5 <= DECODE_BYTE1;    
   	      when 23 => GPS_SAT5LEV3 <= DECODE_BYTE1;    
   	      when 24 => GPS_SAT5LEV2 <= DECODE_BYTE1;    
   	      when 25 => GPS_SAT5LEV1 <= DECODE_BYTE1;    
   	      when 26 => GPS_SAT5LEV0 <= DECODE_BYTE1;    
   	      when 27 => GPS_SATNUM6 <= DECODE_BYTE1;    
   	      when 28 => GPS_SAT6LEV3 <= DECODE_BYTE1;    
   	      when 29 => GPS_SAT6LEV2 <= DECODE_BYTE1;    
   	      when 30 => GPS_SAT6LEV1 <= DECODE_BYTE1;    
   	      when 31 => GPS_SAT6LEV0 <= DECODE_BYTE1;    
   	      when 32 => GPS_SATNUM7 <= DECODE_BYTE1;    
   	      when 33 => GPS_SAT7LEV3 <= DECODE_BYTE1;    
   	      when 34 => GPS_SAT7LEV2 <= DECODE_BYTE1;    
   	      when 35 => GPS_SAT7LEV1 <= DECODE_BYTE1;    
   	      when 36 => GPS_SAT7LEV0 <= DECODE_BYTE1;    
   	      when 37 => GPS_SATNUM8 <= DECODE_BYTE1;    
   	      when 38 => GPS_SAT8LEV3 <= DECODE_BYTE1;    
   	      when 39 => GPS_SAT8LEV2 <= DECODE_BYTE1;    
   	      when 40 => GPS_SAT8LEV1 <= DECODE_BYTE1;    
   	      when 41 => GPS_SAT8LEV0 <= DECODE_BYTE1;    
   	      when 42 => GPS_SATNUM9 <= DECODE_BYTE1;    
   	      when 43 => GPS_SAT9LEV3 <= DECODE_BYTE1;    
   	      when 44 => GPS_SAT9LEV2 <= DECODE_BYTE1;    
   	      when 45 => GPS_SAT9LEV1 <= DECODE_BYTE1;    
   	      when 46 => GPS_SAT9LEV0 <= DECODE_BYTE1;    
   	      when 47 => GPS_SATNUM10 <= DECODE_BYTE1;    
   	      when 48 => GPS_SAT10LEV3 <= DECODE_BYTE1;    
   	      when 49 => GPS_SAT10LEV2 <= DECODE_BYTE1;    
   	      when 50 => GPS_SAT10LEV1 <= DECODE_BYTE1;    
   	      when 51 => GPS_SAT10LEV0 <= DECODE_BYTE1;    
   	      when 52 => GPS_SATNUM11 <= DECODE_BYTE1;    
   	      when 53 => GPS_SAT11LEV3 <= DECODE_BYTE1;    
   	      when 54 => GPS_SAT11LEV2 <= DECODE_BYTE1;    
   	      when 55 => GPS_SAT11LEV1 <= DECODE_BYTE1;    
   	      when 56 => GPS_SAT11LEV0 <= DECODE_BYTE1;    
   	      when 57 => GPS_SATNUM12 <= DECODE_BYTE1;    
   	      when 58 => GPS_SAT12LEV3 <= DECODE_BYTE1;    
   	      when 59 => GPS_SAT12LEV2 <= DECODE_BYTE1;    
   	      when 60 => GPS_SAT12LEV1 <= DECODE_BYTE1;    
   	      when 61 => GPS_SAT12LEV0 <= DECODE_BYTE1;    
          when others => DUMP <=  DECODE_BYTE1;      
        end case;
      end if;
    end if;
  end process;

        
------------------ End Recieving GPS data -----------------------------------------

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COINC_DEL <= '0';        
      ONE_PPS_DEL1 <= '0';        
      ONE_PPS_DEL2 <= '0';        
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COINC_DEL <= COINC;        
      ONE_PPS_DEL1 <= ONE_PPS;        
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;        
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ONE_PPS_SLOW_DEL1 <= '0';        
      ONE_PPS_SLOW_DEL2 <= '0';        
      ONE_PPS_SLOW_DEL3 <= '0';        
      TS_ONE_PPS_READOUT_DONE_DEL1 <= '0';        
      TS_ONE_PPS_READOUT_DONE_DEL2 <= '0';        
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      ONE_PPS_SLOW_DEL1 <= ONE_PPS;        
      ONE_PPS_SLOW_DEL2 <= ONE_PPS_SLOW_DEL1;        
      ONE_PPS_SLOW_DEL3 <= ONE_PPS_SLOW_DEL2;        
      TS_ONE_PPS_READOUT_DONE_DEL1 <= TS_ONE_PPS_READOUT_DONE;        
      TS_ONE_PPS_READOUT_DONE_DEL2 <= TS_ONE_PPS_READOUT_DONE_DEL1;        
    end if;
  end process;  

 -- CTP COUNTER
 -- The CTP counter counts from ONE_PPS to ONE_PPS
  process (CLK200MHz,SYSRST)  
  begin
	if SYSRST = '1' then
	  CTP_COUNT <= "00000000000000000000000000000001";
	elsif CLK200MHz'event and CLK200MHz ='1' then
	  if ONE_PPS_DEL1 = '1'and ONE_PPS_DEL2 = '0' then
		CTP_COUNT <= "00000000000000000000000000000001";
	  else 
		CTP_COUNT <= CTP_COUNT + "00000000000000000000000000000001";
	  end if;
	end if;
  end process;

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      NEG_FASE_BIT <= '0';        
      NEG_FASE_BIT_DEL <= '0';        
    elsif (CLK200MHz'event and CLK200MHz = '0') then -- on a negative edge of the CLK200MHz clock
      NEG_FASE_BIT <= ONE_PPS;        
      NEG_FASE_BIT_DEL <= NEG_FASE_BIT;        
    end if;
  end process;  


  -- Latch GPS_TIME and counter values on positive edge of ONE_PPS
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      CTP_TS_ONE_PPS_OUT <= (others => '0');
      GPS_SEC_BUF <= (others => '0');
      GPS_MIN_BUF <= (others => '0');
      GPS_HOUR_BUF <= (others => '0');
      GPS_DAY_BUF <= (others => '0');
      GPS_MONTH_BUF <= (others => '0');
      GPS_YEAR1_BUF <= (others => '0');
      GPS_YEAR0_BUF <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then
        CTP_TS_ONE_PPS_OUT(30 downto 0) <= CTP_COUNT(30 downto 0);
        CTP_TS_ONE_PPS_OUT(31) <= NEG_FASE_BIT_DEL;
        GPS_SEC_BUF <= GPS_SEC;
        GPS_MIN_BUF <= GPS_MIN;
        GPS_HOUR_BUF <= GPS_HOUR;
        GPS_DAY_BUF <= GPS_DAY;
        GPS_MONTH_BUF <= GPS_MONTH;
        GPS_YEAR1_BUF <= GPS_YEAR1;
        GPS_YEAR0_BUF <= GPS_YEAR0;
      end if;
    end if;
  end process;  

  -- Latch GPS_TIME and counter values on positive edge of ONE_PPS
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      GPS_TS_ONE_PPS_OUT <= (others => '0');
      CTD_TS_ONE_PPS_OUT <= (others => '0');
      LONGITUDE_OUT <= (others => '0');
      LATITUDE_OUT <= (others => '0');
      ALTITUDE_OUT <= (others => '0');
      TEMP_OUT <= (others => '0');
      SAT_INFO_OUT <= (others => '0');
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if ONE_PPS_SLOW_DEL2 = '1' and ONE_PPS_SLOW_DEL3 = '0' then
        GPS_TS_ONE_PPS_OUT(55 downto 48) <= GPS_DAY; -- Day
        GPS_TS_ONE_PPS_OUT(47 downto 40) <= GPS_MONTH; -- Month
        GPS_TS_ONE_PPS_OUT(39 downto 32) <= GPS_YEAR1; -- Year
        GPS_TS_ONE_PPS_OUT(31 downto 24) <= GPS_YEAR0; -- Year
        GPS_TS_ONE_PPS_OUT(23 downto 16) <= GPS_HOUR; -- Hours
        GPS_TS_ONE_PPS_OUT(15 downto 8) <= GPS_MIN; -- Minutes
        GPS_TS_ONE_PPS_OUT(7 downto 0) <= GPS_SEC; -- Seconds
        CTD_TS_ONE_PPS_OUT(31 downto 24) <= GPS_QUANT3;
        CTD_TS_ONE_PPS_OUT(23 downto 16) <= GPS_QUANT2;
        CTD_TS_ONE_PPS_OUT(15 downto 8) <= GPS_QUANT1;
        CTD_TS_ONE_PPS_OUT(7 downto 0) <= GPS_QUANT0;
        LATITUDE_OUT(63 downto 56) <= GPS_LAT7;
        LATITUDE_OUT(55 downto 48) <= GPS_LAT6;
        LATITUDE_OUT(47 downto 40) <= GPS_LAT5;
        LATITUDE_OUT(39 downto 32) <= GPS_LAT4;
        LATITUDE_OUT(31 downto 24) <= GPS_LAT3;
        LATITUDE_OUT(23 downto 16) <= GPS_LAT2;
        LATITUDE_OUT(15 downto 8) <= GPS_LAT1;
        LATITUDE_OUT(7 downto 0) <= GPS_LAT0;
        LONGITUDE_OUT(63 downto 56) <= GPS_LONG7;
        LONGITUDE_OUT(55 downto 48) <= GPS_LONG6;
        LONGITUDE_OUT(47 downto 40) <= GPS_LONG5;
        LONGITUDE_OUT(39 downto 32) <= GPS_LONG4;
        LONGITUDE_OUT(31 downto 24) <= GPS_LONG3;
        LONGITUDE_OUT(23 downto 16) <= GPS_LONG2;
        LONGITUDE_OUT(15 downto 8) <= GPS_LONG1;
        LONGITUDE_OUT(7 downto 0) <= GPS_LONG0;
        ALTITUDE_OUT(63 downto 56) <= GPS_ALT7;
        ALTITUDE_OUT(55 downto 48) <= GPS_ALT6;
        ALTITUDE_OUT(47 downto 40) <= GPS_ALT5;
        ALTITUDE_OUT(39 downto 32) <= GPS_ALT4;
        ALTITUDE_OUT(31 downto 24) <= GPS_ALT3;
        ALTITUDE_OUT(23 downto 16) <= GPS_ALT2;
        ALTITUDE_OUT(15 downto 8) <= GPS_ALT1;
        ALTITUDE_OUT(7 downto 0) <= GPS_ALT0;
        TEMP_OUT(31 downto 24) <= GPS_TEMP3;
        TEMP_OUT(23 downto 16) <= GPS_TEMP2;
        TEMP_OUT(15 downto 8) <= GPS_TEMP1;
        TEMP_OUT(7 downto 0) <= GPS_TEMP0;
        SAT_INFO_OUT(487 downto 480) <= GPS_SATCOUNT;
        SAT_INFO_OUT(479 downto 472) <= GPS_SATNUM1;
        SAT_INFO_OUT(471 downto 464) <= GPS_SAT1LEV3;
        SAT_INFO_OUT(463 downto 456) <= GPS_SAT1LEV2;
        SAT_INFO_OUT(455 downto 448) <= GPS_SAT1LEV1;
        SAT_INFO_OUT(447 downto 440) <= GPS_SAT1LEV0;
        SAT_INFO_OUT(439 downto 432) <= GPS_SATNUM2;
        SAT_INFO_OUT(431 downto 424) <= GPS_SAT2LEV3;
        SAT_INFO_OUT(423 downto 416) <= GPS_SAT2LEV2;
        SAT_INFO_OUT(415 downto 408) <= GPS_SAT2LEV1;
        SAT_INFO_OUT(407 downto 400) <= GPS_SAT2LEV0;
        SAT_INFO_OUT(399 downto 392) <= GPS_SATNUM3;
        SAT_INFO_OUT(391 downto 384) <= GPS_SAT3LEV3;
        SAT_INFO_OUT(383 downto 376) <= GPS_SAT3LEV2;
        SAT_INFO_OUT(375 downto 368) <= GPS_SAT3LEV1;
        SAT_INFO_OUT(367 downto 360) <= GPS_SAT3LEV0;
        SAT_INFO_OUT(359 downto 352) <= GPS_SATNUM4;
        SAT_INFO_OUT(351 downto 344) <= GPS_SAT4LEV3;
        SAT_INFO_OUT(343 downto 336) <= GPS_SAT4LEV2;
        SAT_INFO_OUT(335 downto 328) <= GPS_SAT4LEV1;
        SAT_INFO_OUT(327 downto 320) <= GPS_SAT4LEV0;
        SAT_INFO_OUT(319 downto 312) <= GPS_SATNUM5;
        SAT_INFO_OUT(311 downto 304) <= GPS_SAT5LEV3;
        SAT_INFO_OUT(303 downto 296) <= GPS_SAT5LEV2;
        SAT_INFO_OUT(295 downto 288) <= GPS_SAT5LEV1;
        SAT_INFO_OUT(287 downto 280) <= GPS_SAT5LEV0;
        SAT_INFO_OUT(279 downto 272) <= GPS_SATNUM6;
        SAT_INFO_OUT(271 downto 264) <= GPS_SAT6LEV3;
        SAT_INFO_OUT(263 downto 256) <= GPS_SAT6LEV2;
        SAT_INFO_OUT(255 downto 248) <= GPS_SAT6LEV1;
        SAT_INFO_OUT(247 downto 240) <= GPS_SAT6LEV0;
        SAT_INFO_OUT(239 downto 232) <= GPS_SATNUM7;
        SAT_INFO_OUT(231 downto 224) <= GPS_SAT7LEV3;
        SAT_INFO_OUT(223 downto 216) <= GPS_SAT7LEV2;
        SAT_INFO_OUT(215 downto 208) <= GPS_SAT7LEV1;
        SAT_INFO_OUT(207 downto 200) <= GPS_SAT7LEV0;
        SAT_INFO_OUT(199 downto 192) <= GPS_SATNUM8;
        SAT_INFO_OUT(191 downto 184) <= GPS_SAT8LEV3;
        SAT_INFO_OUT(183 downto 176) <= GPS_SAT8LEV2;
        SAT_INFO_OUT(175 downto 168) <= GPS_SAT8LEV1;
        SAT_INFO_OUT(167 downto 160) <= GPS_SAT8LEV0;
        SAT_INFO_OUT(159 downto 152) <= GPS_SATNUM9;
        SAT_INFO_OUT(151 downto 144) <= GPS_SAT9LEV3;
        SAT_INFO_OUT(143 downto 136) <= GPS_SAT9LEV2;
        SAT_INFO_OUT(135 downto 128) <= GPS_SAT9LEV1;
        SAT_INFO_OUT(127 downto 120) <= GPS_SAT9LEV0;
        SAT_INFO_OUT(119 downto 112) <= GPS_SATNUM10;
        SAT_INFO_OUT(111 downto 104) <= GPS_SAT10LEV3;
        SAT_INFO_OUT(103 downto 96) <= GPS_SAT10LEV2;
        SAT_INFO_OUT(95 downto 88) <= GPS_SAT10LEV1;
        SAT_INFO_OUT(87 downto 80) <= GPS_SAT10LEV0;
        SAT_INFO_OUT(79 downto 72) <= GPS_SATNUM11;
        SAT_INFO_OUT(71 downto 64) <= GPS_SAT11LEV3;
        SAT_INFO_OUT(63 downto 56) <= GPS_SAT11LEV2;
        SAT_INFO_OUT(55 downto 48) <= GPS_SAT11LEV1;
        SAT_INFO_OUT(47 downto 40) <= GPS_SAT11LEV0;
        SAT_INFO_OUT(39 downto 32) <= GPS_SATNUM12;
        SAT_INFO_OUT(31 downto 24) <= GPS_SAT12LEV3;
        SAT_INFO_OUT(23 downto 16) <= GPS_SAT12LEV2;
        SAT_INFO_OUT(15 downto 8) <= GPS_SAT12LEV1;
        SAT_INFO_OUT(7 downto 0) <= GPS_SAT12LEV0;
      end if;
    end if;
  end process;  

  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TS_ONE_PPS_VALID_OUT <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if ONE_PPS_SLOW_DEL2 = '1' and ONE_PPS_SLOW_DEL3 = '0' then
        TS_ONE_PPS_VALID_OUT <= '1';
      elsif TS_ONE_PPS_READOUT_DONE_DEL1 = '1' and TS_ONE_PPS_READOUT_DONE_DEL2 = '0' then
        TS_ONE_PPS_VALID_OUT <= '0';
      end if;
    end if;
  end process;  

  GPS_TS_OUT(55 downto 48) <= GPS_DAY_BUF; -- Day
  GPS_TS_OUT(47 downto 40) <= GPS_MONTH_BUF; -- Month
  GPS_TS_OUT(39 downto 32) <= GPS_YEAR1_BUF; -- Year
  GPS_TS_OUT(31 downto 24) <= GPS_YEAR0_BUF; -- Year
  GPS_TS_OUT(23 downto 16) <= GPS_HOUR_BUF; -- Hours
  GPS_TS_OUT(15 downto 8) <= GPS_MIN_BUF; -- Minutes
  GPS_TS_OUT(7 downto 0) <= GPS_SEC_BUF; -- Seconds
  CTD_OUT <= CTP_COUNT;

------------------------- Comparator stuff ----------------------------------

  -- Delays and synchronization
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_IN_DEL1 <= '0';
      COMPL1_IN_DEL2 <= '0';
      COMPH1_IN_DEL1 <= '0';
      COMPH1_IN_DEL2 <= '0';
      COMPL2_IN_DEL1 <= '0';
      COMPL2_IN_DEL2 <= '0';
      COMPH2_IN_DEL1 <= '0';
      COMPH2_IN_DEL2 <= '0';
      RST_COMPL1 <= '0';
      RST_COMPH1 <= '0';
      RST_COMPL2 <= '0';
      RST_COMPH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      COMPL1_IN_DEL1 <= COMPL1_IN; 
      COMPL1_IN_DEL2 <= COMPL1_IN_DEL1; 
      COMPH1_IN_DEL1 <= COMPH1_IN; 
      COMPH1_IN_DEL2 <= COMPH1_IN_DEL1; 
      COMPL2_IN_DEL1 <= COMPL2_IN; 
      COMPL2_IN_DEL2 <= COMPL2_IN_DEL1; 
      COMPH2_IN_DEL1 <= COMPH2_IN; 
      COMPH2_IN_DEL2 <= COMPH2_IN_DEL1; 
      RST_COMPL1 <= RST_COMPL1_10MHZ; 
      RST_COMPH1 <= RST_COMPH1_10MHZ; 
      RST_COMPL2 <= RST_COMPL2_10MHZ; 
      RST_COMPH2 <= RST_COMPH2_10MHZ; 
    end if;
  end process;  

  process (CLK10MHz, SYSRST)
  begin
	if SYSRST = '1' then
	  VALID_COMPL1_10MHZ <= '0';                 
	  VALID_COMPH1_10MHZ <= '0';                 
	  VALID_COMPL2_10MHZ <= '0';                 
	  VALID_COMPH2_10MHZ <= '0';                 
      COMPDATA_READOUT_DONE_DEL1 <= '0';
      COMPDATA_READOUT_DONE_DEL2 <= '0';
	elsif CLK10MHz'event and CLK10MHz = '1' then
	  VALID_COMPL1_10MHZ <= VALID_COMPL1;                 
	  VALID_COMPH1_10MHZ <= VALID_COMPH1;                 
	  VALID_COMPL2_10MHZ <= VALID_COMPL2;                 
	  VALID_COMPH2_10MHZ <= VALID_COMPH2;                 
	  COMPDATA_READOUT_DONE_DEL1 <= COMPDATA_READOUT_DONE;                 
	  COMPDATA_READOUT_DONE_DEL2 <= COMPDATA_READOUT_DONE_DEL1;                 
	end if;
  end process;

  -- Time over threshold counters
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL1 = '1' then
        COMPL1_COUNT <= (others => '0');
      elsif COMPL1_COUNT = "11111111111111111111111111111111" then
        COMPL1_COUNT <= COMPL1_COUNT;
      elsif COMPL1_IN_DEL1 = '1' then
        COMPL1_COUNT <= COMPL1_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH1 = '1' then
        COMPH1_COUNT <= (others => '0');
      elsif COMPH1_COUNT = "11111111111111111111111111111111" then
        COMPH1_COUNT <= COMPH1_COUNT;
      elsif COMPH1_IN_DEL1 = '1' then
        COMPH1_COUNT <= COMPH1_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL2 = '1' then
        COMPL2_COUNT <= (others => '0');
      elsif COMPL1_COUNT = "11111111111111111111111111111111" then
        COMPL2_COUNT <= COMPL2_COUNT;
      elsif COMPL2_IN_DEL1 = '1' then
        COMPL2_COUNT <= COMPL2_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_COUNT <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH2 = '1' then
        COMPH2_COUNT <= (others => '0');
      elsif COMPL1_COUNT = "11111111111111111111111111111111" then
        COMPH2_COUNT <= COMPH2_COUNT;
      elsif COMPH2_IN_DEL1 = '1' then
        COMPH2_COUNT <= COMPH2_COUNT + "00000000000000000000000000000001";
      end if;
    end if;
  end process;  

  -- Set valid bits for comparator signals
  -- Valid on a negative edge of a COMP signal, because this is the end-time of the COMP counter
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPL1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL1 = '1' then
        VALID_COMPL1 <= '0';
      elsif COMPL1_IN_DEL1 = '0' and COMPL1_IN_DEL2 = '1' then
        VALID_COMPL1 <= '1';
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPH1 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH1 = '1' then
        VALID_COMPH1 <= '0';
      elsif COMPH1_IN_DEL1 = '0' and COMPH1_IN_DEL2 = '1' then
        VALID_COMPH1 <= '1';
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPL2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPL2 = '1' then
        VALID_COMPL2 <= '0';
      elsif COMPL2_IN_DEL1 = '0' and COMPL2_IN_DEL2 = '1' then
        VALID_COMPL2 <= '1';
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      VALID_COMPH2 <= '0';
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if RST_COMPH2 = '1' then
        VALID_COMPH2 <= '0';
      elsif COMPH2_IN_DEL1 = '0' and COMPH2_IN_DEL2 = '1' then
        VALID_COMPH2 <= '1';
      end if;
    end if;
  end process;  

  -- Latch the time on a positive edge of a comparator signal
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL1_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL1_IN_DEL1 = '1' and COMPL1_IN_DEL2 = '0' then
        COMPL1_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPL1_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPL1_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPL1_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPL1_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPL1_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPL1_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPL1_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH1_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH1_IN_DEL1 = '1' and COMPH1_IN_DEL2 = '0' then
        COMPH1_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPH1_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPH1_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPH1_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPH1_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPH1_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPH1_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPH1_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPL2_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPL2_IN_DEL1 = '1' and COMPL2_IN_DEL2 = '0' then
        COMPL2_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPL2_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPL2_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPL2_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPL2_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPL2_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPL2_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPL2_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPH2_TIMESTAMP <= (others => '0');
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COMPH2_IN_DEL1 = '1' and COMPL1_IN_DEL2 = '0' then
        COMPH2_TIMESTAMP(87 downto 80) <= GPS_DAY_BUF; -- Day
        COMPH2_TIMESTAMP(79 downto 72) <= GPS_MONTH_BUF; -- Month
        COMPH2_TIMESTAMP(71 downto 64) <= GPS_YEAR1_BUF; -- Year
        COMPH2_TIMESTAMP(63 downto 56) <= GPS_YEAR0_BUF; -- Year
        COMPH2_TIMESTAMP(55 downto 48) <= GPS_HOUR_BUF; -- Hours
        COMPH2_TIMESTAMP(47 downto 40) <= GPS_MIN_BUF; -- Minutes
        COMPH2_TIMESTAMP(39 downto 32) <= GPS_SEC_BUF; -- Seconds
        COMPH2_TIMESTAMP(31 downto 0) <= CTP_COUNT;
      end if;
    end if;
  end process;  
  
  -- Output selector
  process(CLK10MHz,SYSRST)
  begin
    if SYSRST = '1' then
      COMPDATA_VALID_OUT_TMP <= '0';
      RST_COMPL1_10MHZ <= '0';
      RST_COMPH1_10MHZ <= '0';
      RST_COMPL2_10MHZ <= '0';
      RST_COMPH2_10MHZ <= '0';
    elsif (CLK10MHz'event and CLK10MHz = '1') then
      if COMPDATA_VALID_OUT_TMP = '0' then
        if VALID_COMPL1_10MHZ = '1' then
          COMPDATA_VALID_OUT_TMP <= '1';
          RST_COMPL1_10MHZ <= '1';
          COMPDATA_OUT(127 downto 120) <= "00000001";
          COMPDATA_OUT(119 downto 32) <= COMPL1_TIMESTAMP;
          COMPDATA_OUT(31 downto 0) <= COMPL1_COUNT;
        elsif VALID_COMPH1_10MHZ = '1' then
          COMPDATA_VALID_OUT_TMP <= '1';
          RST_COMPH1_10MHZ <= '1';
          COMPDATA_OUT(127 downto 120) <= "00000010";
          COMPDATA_OUT(119 downto 32) <= COMPH1_TIMESTAMP;
          COMPDATA_OUT(31 downto 0) <= COMPH1_COUNT;
        elsif VALID_COMPL2_10MHZ = '1' then
          COMPDATA_VALID_OUT_TMP <= '1';
          RST_COMPL2_10MHZ <= '1';
          COMPDATA_OUT(127 downto 120) <= "00000100";
          COMPDATA_OUT(119 downto 32) <= COMPL2_TIMESTAMP;
          COMPDATA_OUT(31 downto 0) <= COMPL2_COUNT;
        elsif VALID_COMPH2_10MHZ = '1' then
          COMPDATA_VALID_OUT_TMP <= '1';
          RST_COMPH2_10MHZ <= '1';
          COMPDATA_OUT(127 downto 120) <= "00001000";
          COMPDATA_OUT(119 downto 32) <= COMPH2_TIMESTAMP;
          COMPDATA_OUT(31 downto 0) <= COMPH2_COUNT;
        end if;
      elsif COMPDATA_VALID_OUT_TMP = '1' then
        RST_COMPL1_10MHZ <= '0';
        RST_COMPH1_10MHZ <= '0';
        RST_COMPL2_10MHZ <= '0';
        RST_COMPH2_10MHZ <= '0';
        if COMPDATA_READOUT_DONE_DEL1 = '1' and COMPDATA_READOUT_DONE_DEL2 = '0' then
          COMPDATA_VALID_OUT_TMP <= '0';
          COMPDATA_OUT <= (others => '0');
        end if;
      end if;
    end if;
  end process;  

  COMPDATA_VALID_OUT <= COMPDATA_VALID_OUT_TMP;

end rtl ; -- of GPS_STUFF

--------------------------------------------------------------------------------
-- Entity declaration of 'THRESHOLD_COUNTERS'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity THRESHOLD_COUNTERS is
  port(
    CLK200MHz       : in     std_logic;
    MH1             : in     std_logic;
    MH2             : in     std_logic;
    ML1             : in     std_logic;
    ML2             : in     std_logic;
    ONE_PPS         : in     std_logic;
    SYSRST          : in     std_logic;
    TH_COUNTERS_OUT : out    std_logic_vector(63 downto 0));
end THRESHOLD_COUNTERS ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'THRESHOLD_COUNTERS'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of THRESHOLD_COUNTERS is

signal ML1_DEL: std_logic ;
signal MH1_DEL: std_logic ;
signal ML2_DEL: std_logic ;
signal MH2_DEL: std_logic ;
signal ONE_PPS_DEL1: std_logic ; -- One delay needed to synchronize the asynchronious ONE_PPS with the 200MHz
signal ONE_PPS_DEL2: std_logic ;
signal ONE_PPS_DEL3: std_logic ;
signal ML1_COUNTER: std_logic_vector(15 downto 0) ;
signal MH1_COUNTER: std_logic_vector(15 downto 0) ;
signal ML2_COUNTER: std_logic_vector(15 downto 0) ;
signal MH2_COUNTER: std_logic_vector(15 downto 0) ;


begin

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_DEL <= '0';
      MH1_DEL <= '0';
      ML2_DEL <= '0';
      MH2_DEL <= '0';  
      ONE_PPS_DEL1 <= '0';        
      ONE_PPS_DEL2 <= '0';        
      ONE_PPS_DEL3 <= '0';        
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      ML1_DEL <= ML1;        
      MH1_DEL <= MH1;        
      ML2_DEL <= ML2;        
      MH2_DEL <= MH2;        
      ONE_PPS_DEL1 <= ONE_PPS;        
      ONE_PPS_DEL2 <= ONE_PPS_DEL1;        
      ONE_PPS_DEL3 <= ONE_PPS_DEL2;        
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML1_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        ML1_COUNTER <= "0000000000000000"; 
      elsif ML1 = '1' and ML1_DEL = '0' then
        ML1_COUNTER <= ML1_COUNTER + "0000000000000001";       
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH1_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        MH1_COUNTER <= "0000000000000000"; 
      elsif MH1 = '1' and MH1_DEL = '0' then
        MH1_COUNTER <= MH1_COUNTER + "0000000000000001";       
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      ML2_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        ML2_COUNTER <= "0000000000000000"; 
      elsif ML2 = '1' and ML2_DEL = '0' then
        ML2_COUNTER <= ML2_COUNTER + "0000000000000001";       
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      MH2_COUNTER <= "0000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL2 = '1' and ONE_PPS_DEL3 = '0' then
        MH2_COUNTER <= "0000000000000000"; 
      elsif MH2 = '1' and MH2_DEL = '0' then
        MH2_COUNTER <= MH2_COUNTER + "0000000000000001";       
      end if;
    end if;
  end process;  

  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TH_COUNTERS_OUT <= (others => '0'); 
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if ONE_PPS_DEL1 = '1' and ONE_PPS_DEL2 = '0' then
        TH_COUNTERS_OUT(15 downto 0) <= ML1_COUNTER;
        TH_COUNTERS_OUT(31 downto 16) <= MH1_COUNTER;
        TH_COUNTERS_OUT(47 downto 32) <= ML2_COUNTER;
        TH_COUNTERS_OUT(63 downto 48) <= MH2_COUNTER;
      end if;
    end if;
  end process;  


end rtl ; -- of THRESHOLD_COUNTERS

--------------------------------------------------------------------------------
-- Entity declaration of 'LVDS_MUX'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity LVDS_MUX is
  port(
    COINC           : out    std_logic;
    COINC_MASTER    : in     std_logic;
    GPS_DATA_MASTER : in     std_logic;
    GPS_DATA_OUT    : out    std_logic;
    LVDS_IN1        : in     std_logic;
    LVDS_IN2        : in     std_logic;
    LVDS_IN3        : in     std_logic;
    LVDS_IN4        : in     std_logic;
    LVDS_OUT1       : out    std_logic;
    LVDS_OUT2       : out    std_logic;
    LVDS_OUT3       : out    std_logic;
    LVDS_OUT4       : out    std_logic;
    MASTER          : in     std_logic;
    MH1             : in     std_logic;
    MH2             : in     std_logic;
    ML1             : in     std_logic;
    ML2             : in     std_logic;
    ONE_PPS_MASTER  : in     std_logic;
    ONE_PPS_OUT     : out    std_logic;
    SH1             : out    std_logic;
    SH2             : out    std_logic;
    SL1             : out    std_logic;
    SL2             : out    std_logic);
end LVDS_MUX ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'LVDS_MUX'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of LVDS_MUX is

begin

  SL1 <= LVDS_IN1 when MASTER = '1' else '1';
  SH1 <= LVDS_IN2 when MASTER = '1' else '1';
  SL2 <= LVDS_IN3 when MASTER = '1' else '1';
  SH2 <= LVDS_IN4 when MASTER = '1' else '1';

  GPS_DATA_OUT <= GPS_DATA_MASTER when MASTER = '1' else LVDS_IN1;
  ONE_PPS_OUT <= ONE_PPS_MASTER when MASTER = '1' else LVDS_IN2;
  COINC <= COINC_MASTER when MASTER = '1' else LVDS_IN3;
  
  LVDS_OUT1 <= GPS_DATA_MASTER when MASTER = '1' else ML1;
  LVDS_OUT2 <= ONE_PPS_MASTER when MASTER = '1' else MH1;
  LVDS_OUT3 <= COINC_MASTER when MASTER = '1' else ML2;
  LVDS_OUT4 <= '0' when MASTER = '1' else MH2;

end rtl ; -- of LVDS_MUX

--------------------------------------------------------------------------------
-- Entity declaration of 'INVERTER'.
-- Last modified : Fri Jun 22 14:11:35 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity INVERTER is
  port(
    INP  : in     std_logic;
    OUTP : out    std_logic);
end INVERTER ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'INVERTER'
-- Last modified : Fri Jun 22 14:11:35 2007.
--------------------------------------------------------------------------------

architecture rtl of INVERTER is

begin
  OUTP <= not INP;
end rtl ; -- of INVERTER

--------------------------------------------------------------------------------
-- Entity declaration of 'DUMMIES'.
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity DUMMIES is
  port(
    ADC_1_NEG_OR : in     std_logic;
    ADC_1_POS_OR : in     std_logic;
    ADC_2_NEG_OR : in     std_logic;
    ADC_2_POS_OR : in     std_logic;
    LED4         : out    std_logic;
    LED5         : out    std_logic;
    LED6         : out    std_logic;
    LED7         : out    std_logic;
    LED8         : out    std_logic;
    LED9         : out    std_logic);
end DUMMIES ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'DUMMIES'
-- Last modified : Mon Nov 06 11:01:12 2006.
--------------------------------------------------------------------------------

architecture rtl of DUMMIES is

begin

-- The ADC input signals are not connected

-- LED1 is used for SLAVE_PRESENT
-- LED2 is used for MASTER (GPS PRESENT)
-- LED3 is used for COINC
  LED4 <= '1';
  LED5 <= '1';
  LED6 <= '1';
  LED7 <= '1';
  LED8 <= '1';
  LED9 <= '1';


  
end rtl ; -- of DUMMIES

--------------------------------------------------------------------------------
-- Entity declaration of 'FIFO_SELECT'.
-- Last modified : Fri Jun 29 21:30:34 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity FIFO_SELECT is
  port(
    BLOCK_COINC            : out    std_logic;
    CLK200MHz              : in     std_logic;
    CLKRD                  : in     std_logic;
    COINC_TO_END_TIME      : in     std_logic;
    COINC_TO_END_TIME1_CH1 : out    std_logic;
    COINC_TO_END_TIME1_CH2 : out    std_logic;
    COINC_TO_END_TIME2_CH1 : out    std_logic;
    COINC_TO_END_TIME2_CH2 : out    std_logic;
    CTD_IN                 : in     std_logic_vector(31 downto 0);
    CTD_OUT                : out    std_logic_vector(31 downto 0);
    DATA_OUT1_CH1          : in     std_logic_vector(11 downto 0);
    DATA_OUT1_CH2          : in     std_logic_vector(11 downto 0);
    DATA_OUT2_CH1          : in     std_logic_vector(11 downto 0);
    DATA_OUT2_CH2          : in     std_logic_vector(11 downto 0);
    DATA_OUT_CH1           : out    std_logic_vector(11 downto 0);
    DATA_OUT_CH2           : out    std_logic_vector(11 downto 0);
    DATA_READY1_CH1        : in     std_logic;
    DATA_READY1_CH2        : in     std_logic;
    DATA_READY2_CH1        : in     std_logic;
    DATA_READY2_CH2        : in     std_logic;
    DATA_READY_CH1         : out    std_logic;
    DATA_READY_CH2         : out    std_logic;
    DATA_VALID_CH1         : out    std_logic;
    DATA_VALID_CH2         : out    std_logic;
    GPS_TS_IN              : in     std_logic_vector(55 downto 0);
    GPS_TS_OUT             : out    std_logic_vector(55 downto 0);
    RDEN1_CH1              : out    std_logic;
    RDEN1_CH2              : out    std_logic;
    RDEN2_CH1              : out    std_logic;
    RDEN2_CH2              : out    std_logic;
    RDEN_CH1               : in     std_logic;
    RDEN_CH2               : in     std_logic;
    READOUT_BUSY1_CH1      : in     std_logic;
    READOUT_BUSY1_CH2      : in     std_logic;
    READOUT_BUSY2_CH1      : in     std_logic;
    READOUT_BUSY2_CH2      : in     std_logic;
    SYSRST                 : in     std_logic;
    TRIGGER_PATTERN        : out    std_logic_vector(15 downto 0);
    TRIGGER_PATTERN_IN     : in     std_logic_vector(15 downto 0));
end FIFO_SELECT ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'FIFO_SELECT'
-- Last modified : Fri Jun 29 21:30:34 2007.
--------------------------------------------------------------------------------

architecture rtl of FIFO_SELECT is

signal COINC_TO_END_TIME1_TMP: std_logic;  
signal COINC_TO_END_TIME2_TMP: std_logic;  
signal COINC_TO_END_TIME1_TMP_DEL: std_logic;  
signal COINC_TO_END_TIME2_TMP_DEL: std_logic;  
signal COINC_SWITCH: std_logic_vector(1 downto 0); -- bit0 is DATA_READY1 and bit1 is DATA_READY2
signal DATA_READY_FIFO1: std_logic;  
signal DATA_READY_FIFO2: std_logic;  
signal READY: std_logic_vector(1 downto 0); -- bit0 selects FIFO1 and bit1 selects FIFO2
signal RDEN_CH2_DEL1: std_logic;  
signal TRIGGER_PATTERN_TIME1: std_logic_vector(15 downto 0);  
signal TRIGGER_PATTERN_TIME2: std_logic_vector(15 downto 0);  
signal CTD_TIME1: std_logic_vector(31 downto 0);  
signal CTD_TIME2: std_logic_vector(31 downto 0);  
signal GPS_TS_TIME1: std_logic_vector(55 downto 0);  
signal GPS_TS_TIME2: std_logic_vector(55 downto 0);  


begin


  -- DATA_READY_FIFO is true when there is data in both fifo's of the channels made on the same COINC
  DATA_READY_FIFO1 <= DATA_READY1_CH1 and DATA_READY1_CH2;
  DATA_READY_FIFO2 <= DATA_READY2_CH1 and DATA_READY2_CH2;

  -- BLOCK_COINC if FIFO's1 and FIFO's2 are full
  BLOCK_COINC <= ((DATA_READY1_CH1 or READOUT_BUSY1_CH1) and (DATA_READY2_CH1 or READOUT_BUSY2_CH1)) 
              or ((DATA_READY1_CH2 or READOUT_BUSY1_CH2) and (DATA_READY2_CH2 or READOUT_BUSY2_CH2));

  COINC_SWITCH(0) <= DATA_READY1_CH1 or DATA_READY1_CH2;
  COINC_SWITCH(1) <= DATA_READY2_CH1 or DATA_READY2_CH2;

  -- COINC Multiplexer
  process(COINC_SWITCH,COINC_TO_END_TIME)
  begin
    case(COINC_SWITCH) is
      when "00" => COINC_TO_END_TIME1_TMP <= COINC_TO_END_TIME;
                   COINC_TO_END_TIME2_TMP <= '0';
      when "01" => COINC_TO_END_TIME1_TMP <= '0';       
                   COINC_TO_END_TIME2_TMP <= COINC_TO_END_TIME;
      when "10" => COINC_TO_END_TIME1_TMP <= COINC_TO_END_TIME;        
                   COINC_TO_END_TIME2_TMP <= '0';
      when "11" => COINC_TO_END_TIME1_TMP <= '0';        
                   COINC_TO_END_TIME2_TMP <= '0';
      when others =>
    end case;
  end process; 


  -- This is done to please the fitter for timing requirements
  process(CLK200MHz)
  begin
    if (CLK200MHz'event and CLK200MHz = '1') then
      COINC_TO_END_TIME1_CH1 <= COINC_TO_END_TIME1_TMP;
      COINC_TO_END_TIME2_CH1 <= COINC_TO_END_TIME2_TMP;
      COINC_TO_END_TIME1_CH2 <= COINC_TO_END_TIME1_TMP;
      COINC_TO_END_TIME2_CH2 <= COINC_TO_END_TIME2_TMP;
      COINC_TO_END_TIME1_TMP_DEL <= COINC_TO_END_TIME1_TMP;
      COINC_TO_END_TIME2_TMP_DEL <= COINC_TO_END_TIME2_TMP;
    end if;
  end process;  

  -- delay's
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      RDEN_CH2_DEL1 <= '0';
    elsif (CLKRD'event and CLKRD = '1') then
      RDEN_CH2_DEL1 <= RDEN_CH2;
    end if;
  end process;  
 
  -- Determine which channel has to be readout
  -- A event in both FIFO's of the channels have been written to the next FIFO at the end of RDEN_CH2
  -- Thus at the end of RDEN_CH2 a new situation must be checked
  process(CLKRD,SYSRST)
  begin
    if SYSRST = '1' then
      READY <= "00"; -- default state
    elsif (CLKRD'event and CLKRD = '1') then
      if (READY = "11") or (RDEN_CH2 = '0' and RDEN_CH2_DEL1 = '1') then -- clear READY
        READY <= "00"; -- default state
      elsif READY(0) = '1' or READY(1) = '1' then -- Latch READY if there is data in one of the FIFO's
        READY <= READY;
      else -- if there is no data the FIFO's
        READY(0) <= DATA_READY_FIFO1;
        READY(1) <= DATA_READY_FIFO2;
      end if;
    end if;
  end process; 

  -- Multiplexer
  process(READY,DATA_OUT1_CH1,DATA_OUT2_CH1,DATA_OUT1_CH2,DATA_OUT2_CH2,
          DATA_READY1_CH1,DATA_READY2_CH1,DATA_READY1_CH2,DATA_READY2_CH2,
          RDEN_CH1,RDEN_CH2,
          READOUT_BUSY1_CH1,READOUT_BUSY2_CH1,READOUT_BUSY1_CH2,READOUT_BUSY2_CH2,
          TRIGGER_PATTERN_TIME1,GPS_TS_TIME1,CTD_TIME1,TRIGGER_PATTERN_TIME2,GPS_TS_TIME2,CTD_TIME2)
  begin
    case(READY) is
      when "00" => DATA_OUT_CH1 <= DATA_OUT1_CH1;        
                   DATA_READY_CH1 <= '0';
                   RDEN1_CH1 <= '0';
                   RDEN2_CH1 <= '0';
--                   COINC_TO_END_TIME1_TMP <= COINC_TO_END_TIME;
--                   COINC_TO_END_TIME2_TMP <= '0';
                   DATA_OUT_CH2 <= DATA_OUT1_CH2;        
                   DATA_READY_CH2 <= '0';
                   DATA_VALID_CH1 <= '0';
                   DATA_VALID_CH2 <= '0';
                   RDEN1_CH2 <= '0';
                   RDEN2_CH2 <= '0';
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME1;
                   GPS_TS_OUT <= GPS_TS_TIME1;
                   CTD_OUT <= CTD_TIME1;
      when "01" => DATA_OUT_CH1 <= DATA_OUT1_CH1;        
                   DATA_READY_CH1 <= DATA_READY1_CH1;
                   RDEN1_CH1 <= RDEN_CH1;
                   RDEN2_CH1 <= '0';
--                   COINC_TO_END_TIME1_TMP <= '0';
--                   COINC_TO_END_TIME2_TMP <= COINC_TO_END_TIME;
                   DATA_OUT_CH2 <= DATA_OUT1_CH2;        
                   DATA_READY_CH2 <= DATA_READY1_CH2;
                   DATA_VALID_CH1 <= READOUT_BUSY1_CH1;
                   DATA_VALID_CH2 <= READOUT_BUSY1_CH2;
                   RDEN1_CH2 <= RDEN_CH2;
                   RDEN2_CH2 <= '0';
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME1;
                   GPS_TS_OUT <= GPS_TS_TIME1;
                   CTD_OUT <= CTD_TIME1;
      when "10" => DATA_OUT_CH1 <= DATA_OUT2_CH1;        
                   DATA_READY_CH1 <= DATA_READY2_CH1;
                   RDEN1_CH1 <= '0';
                   RDEN2_CH1 <= RDEN_CH1;
--                   COINC_TO_END_TIME1_TMP <= COINC_TO_END_TIME;
--                   COINC_TO_END_TIME2_TMP <= '0';
                   DATA_OUT_CH2 <= DATA_OUT2_CH2;        
                   DATA_READY_CH2 <= DATA_READY2_CH2;
                   DATA_VALID_CH1 <= READOUT_BUSY2_CH1;
                   DATA_VALID_CH2 <= READOUT_BUSY2_CH2;
                   RDEN1_CH2 <= '0';
                   RDEN2_CH2 <= RDEN_CH2;
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME2;
                   GPS_TS_OUT <= GPS_TS_TIME2;
                   CTD_OUT <= CTD_TIME2;
      when "11" => DATA_OUT_CH1 <= DATA_OUT1_CH1; -- never assigned        
                   DATA_READY_CH1 <= '0';
                   RDEN1_CH1 <= '0';
                   RDEN2_CH1 <= '0';
--                   COINC_TO_END_TIME1_TMP <= COINC_TO_END_TIME;
--                   COINC_TO_END_TIME2_TMP <= '0';
                   DATA_OUT_CH2 <= DATA_OUT1_CH2;        
                   DATA_READY_CH2 <= '0';
                   DATA_VALID_CH1 <= '0';
                   DATA_VALID_CH2 <= '0';
                   RDEN1_CH2 <= '0';
                   RDEN2_CH2 <= '0';
                   TRIGGER_PATTERN <= TRIGGER_PATTERN_TIME1;
                   GPS_TS_OUT <= GPS_TS_TIME1;
                   CTD_OUT <= CTD_TIME1;
      when others =>
    end case;
  end process; 

  -- Latch TRIGGER_PATTERN on positive edge of COINC_TO_END_TIME1
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN_TIME1 <= "0000000000000000";
      GPS_TS_TIME1 <= "00000000000000000000000000000000000000000000000000000000";
      CTD_TIME1 <= "00000000000000000000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME1_TMP = '1' and COINC_TO_END_TIME1_TMP_DEL = '0' then
        TRIGGER_PATTERN_TIME1 <= TRIGGER_PATTERN_IN;
        GPS_TS_TIME1 <= GPS_TS_IN;
        CTD_TIME1 <= CTD_IN;
      end if;
    end if;
  end process;  

  -- Latch TRIGGER_PATTERN on positive edge of COINC_TO_END_TIME2
  process(CLK200MHz,SYSRST)
  begin
    if SYSRST = '1' then
      TRIGGER_PATTERN_TIME2 <= "0000000000000000";
      GPS_TS_TIME2 <= "00000000000000000000000000000000000000000000000000000000";
      CTD_TIME2 <= "00000000000000000000000000000000";
    elsif (CLK200MHz'event and CLK200MHz = '1') then
      if COINC_TO_END_TIME2_TMP = '1' and COINC_TO_END_TIME2_TMP_DEL = '0' then
        TRIGGER_PATTERN_TIME2 <= TRIGGER_PATTERN_IN;
        GPS_TS_TIME2 <= GPS_TS_IN;
        CTD_TIME2 <= CTD_IN;
      end if;
    end if;
  end process;  

--
--  -- Latch TRIGGER_PATTERN on positive edge of COINC_TO_END_TIME1
--  process(COINC_TO_END_TIME1_TMP,SYSRST)
--  begin
--    if SYSRST = '1' then
--      TRIGGER_PATTERN_TIME1 <= "0000000000000000";
--    elsif (COINC_TO_END_TIME1_TMP'event and COINC_TO_END_TIME1_TMP = '1') then
--      TRIGGER_PATTERN_TIME1 <= TRIGGER_PATTERN_IN;
--    end if;
--  end process;  
--
--  -- Latch TRIGGER_PATTERN on positive edge of COINC_TO_END_TIME2
--  process(COINC_TO_END_TIME2_TMP,SYSRST)
--  begin
--    if SYSRST = '1' then
--      TRIGGER_PATTERN_TIME2 <= "0000000000000000";
--    elsif (COINC_TO_END_TIME2_TMP'event and COINC_TO_END_TIME2_TMP = '1') then
--      TRIGGER_PATTERN_TIME2 <= TRIGGER_PATTERN_IN;
--    end if;
--  end process;  
--
--  -- Latch GPS_TS on positive edge of COINC_TO_END_TIME1
--  process(COINC_TO_END_TIME1_TMP,SYSRST)
--  begin
--    if SYSRST = '1' then
--      GPS_TS_TIME1 <= "00000000000000000000000000000000000000000000000000000000";
--    elsif (COINC_TO_END_TIME1_TMP'event and COINC_TO_END_TIME1_TMP = '1') then
--      GPS_TS_TIME1 <= GPS_TS_IN;
--    end if;
--  end process;  
--
--  -- Latch GPS_TS on positive edge of COINC_TO_END_TIME2
--  process(COINC_TO_END_TIME2_TMP,SYSRST)
--  begin
--    if SYSRST = '1' then
--      GPS_TS_TIME2 <= "00000000000000000000000000000000000000000000000000000000";
--    elsif (COINC_TO_END_TIME2_TMP'event and COINC_TO_END_TIME2_TMP = '1') then
--      GPS_TS_TIME2 <= GPS_TS_IN;
--    end if;
--  end process;  
--
--  -- Latch CTD on positive edge of COINC_TO_END_TIME1
--  process(COINC_TO_END_TIME1_TMP,SYSRST)
--  begin
--    if SYSRST = '1' then
--      CTD_TIME1 <= "00000000000000000000000000000000";
--    elsif (COINC_TO_END_TIME1_TMP'event and COINC_TO_END_TIME1_TMP = '1') then
--      CTD_TIME1 <= CTD_IN;
--    end if;
--  end process;  
--
--  -- Latch CTD on positive edge of COINC_TO_END_TIME2
--  process(COINC_TO_END_TIME2_TMP,SYSRST)
--  begin
--    if SYSRST = '1' then
--      CTD_TIME2 <= "00000000000000000000000000000000";
--    elsif (COINC_TO_END_TIME2_TMP'event and COINC_TO_END_TIME2_TMP = '1') then
--      CTD_TIME2 <= CTD_IN;
--    end if;
--  end process;  

end rtl ; -- of FIFO_SELECT

--------------------------------------------------------------------------------
-- Entity declaration of 'SOFT_RESET'.
-- Last modified : Tue Jul 17 14:45:44 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity SOFT_RESET is
  port(
    CLKRD   : in     std_logic;
    RESOUT  : out    std_logic;
    SRESET  : in     std_logic;
    nHRESET : in     std_logic);
end SOFT_RESET ;

--------------------------------------------------------------------------------
-- Architecture 'rtl' of 'SOFT_RESET'
-- Last modified : Tue Jul 17 14:45:44 2007.
--------------------------------------------------------------------------------

architecture rtl of SOFT_RESET is

signal SRESET_COUNT: std_logic_vector(3 downto 0);

begin

  RESOUT <= not SRESET_COUNT(3) or not nHRESET;
  
  process (CLKRD, nHRESET)
  begin
	if nHRESET = '0' then
	  SRESET_COUNT <= (others => '1');                 
	elsif CLKRD'event and CLKRD = '1' then
      if SRESET = '1' then
	    SRESET_COUNT <= (others => '0');                 
	  elsif SRESET_COUNT /= "1111" then 
		SRESET_COUNT <= SRESET_COUNT + "0001";
	  else
		SRESET_COUNT <= SRESET_COUNT;
	  end if;
	end if;
  end process;

end rtl ; -- of SOFT_RESET

--------------------------------------------------------------------------------
-- Entity declaration of 'STORAGE'.
-- Last modified : Mon Jan 16 22:07:14 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity STORAGE is
  port(
    CLK200MHz         : in     std_logic;
    CLKRD             : in     std_logic;
    COINC_TO_END_TIME : in     std_logic;
    DATA_ADC_NEG      : in     std_logic_vector(11 downto 0);
    DATA_ADC_POS      : in     std_logic_vector(11 downto 0);
    DATA_OUT          : out    std_logic_vector(11 downto 0);
    DATA_READY        : out    std_logic;
    RDEN              : in     std_logic;
    READOUT_BUSY      : out    std_logic;
    SYSRST            : in     std_logic;
    TOTAL_TIME        : in     integer range 2000 downto 0);
end STORAGE ;

--------------------------------------------------------------------------------
-- Architecture 'a0' of 'STORAGE'
-- Last modified : Mon Jan 16 22:07:14 2006.
--------------------------------------------------------------------------------

architecture a0 of STORAGE is

  component DUAL_PORT_RAM
    port(
      DATA_IN    : in     std_logic_vector(11 downto 0);
      DATA_OUT   : out    std_logic_vector(11 downto 0);
      RDCLOCK    : in     std_logic;
      RD_ADDRESS : in     integer range 2020 downto 0;
      WE         : in     std_logic;
      WRCLOCK    : in     std_logic;
      WR_ADDRESS : in     integer range 2020 downto 0);
  end component ;

  component ADDRESS_COUNTERS
    port(
      CLK200MHz         : in     std_logic;
      CLKRD             : in     std_logic;
      COINC_TO_END_TIME : in     std_logic;
      DATA_OUT          : out    std_logic_vector(11 downto 0);
      DATA_OUT_NEG      : in     std_logic_vector(11 downto 0);
      DATA_OUT_POS      : in     std_logic_vector(11 downto 0);
      DATA_READY        : out    std_logic;
      RDEN              : in     std_logic;
      RD_ADDRESS        : out    integer range 2020 downto 0;
      READOUT_BUSY      : out    std_logic;
      SYSRST            : in     std_logic;
      TOTAL_TIME        : in     integer range 2000 downto 0;
      WE                : out    std_logic;
      WR_ADDRESS        : out    integer range 2020 downto 0);
  end component ;

  signal WR_ADDRESS   :  integer range 2020 downto 0;
  signal Net_8        :  std_logic_vector(11 downto 0);
  signal Net_1        :  std_logic_vector(11 downto 0);
  signal Net_16       :  integer range 2020 downto 0;
  signal WE           :  std_logic;

begin


  u0: DUAL_PORT_RAM
    port map(
      DATA_IN => DATA_ADC_POS,
      DATA_OUT => Net_8,
      RDCLOCK => CLKRD,
      RD_ADDRESS => Net_16,
      WE => WE,
      WRCLOCK => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS);

  u1: ADDRESS_COUNTERS
    port map(
      CLK200MHz => CLK200MHz,
      CLKRD => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME,
      DATA_OUT => DATA_OUT,
      DATA_OUT_NEG => Net_1,
      DATA_OUT_POS => Net_8,
      DATA_READY => DATA_READY,
      RDEN => RDEN,
      RD_ADDRESS => Net_16,
      READOUT_BUSY => READOUT_BUSY,
      SYSRST => SYSRST,
      TOTAL_TIME => TOTAL_TIME,
      WE => WE,
      WR_ADDRESS => WR_ADDRESS);

  u2: DUAL_PORT_RAM
    port map(
      DATA_IN => DATA_ADC_NEG,
      DATA_OUT => Net_1,
      RDCLOCK => CLKRD,
      RD_ADDRESS => Net_16,
      WE => WE,
      WRCLOCK => CLK200MHz,
      WR_ADDRESS => WR_ADDRESS);
end a0 ; -- of STORAGE

--------------------------------------------------------------------------------
-- Entity declaration of 'TRIGGER_STUFF'.
-- Last modified : Mon Dec 18 11:03:43 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity TRIGGER_STUFF is
  port(
    BLOCK_COINC     : in     std_logic;
    CLK10MHz        : in     std_logic;
    CLK200MHz       : in     std_logic;
    COINC_TIME      : in     integer range 1000 downto 0;
    COMPH1          : in     std_logic;
    COMPH2          : in     std_logic;
    COMPL1          : in     std_logic;
    COMPL2          : in     std_logic;
    DATA_ADC1_NEG   : in     std_logic_vector(11 downto 0);
    DATA_ADC1_POS   : in     std_logic_vector(11 downto 0);
    DATA_ADC2_NEG   : in     std_logic_vector(11 downto 0);
    DATA_ADC2_POS   : in     std_logic_vector(11 downto 0);
    END_OF_COINC    : out    std_logic;
    EXT_TR_IN       : in     std_logic;
    HITLED1         : out    std_logic;
    HITLED2         : out    std_logic;
    MASTER          : in     std_logic;
    MH1             : out    std_logic;
    MH2             : out    std_logic;
    ML1             : out    std_logic;
    ML2             : out    std_logic;
    SH1             : in     std_logic;
    SH2             : in     std_logic;
    SL1             : in     std_logic;
    SL2             : in     std_logic;
    SLAVE_PRESENT   : out    std_logic;
    SYSRST          : in     std_logic;
    THH1            : in     std_logic_vector(11 downto 0);
    THH2            : in     std_logic_vector(11 downto 0);
    THL1            : in     std_logic_vector(11 downto 0);
    THL2            : in     std_logic_vector(11 downto 0);
    TRIGGER_PATTERN : out    std_logic_vector(15 downto 0);
    TR_CONDITION    : in     std_logic_vector(7 downto 0));
end TRIGGER_STUFF ;

--------------------------------------------------------------------------------
-- Architecture 'structure' of 'TRIGGER_STUFF'
-- Last modified : Mon Dec 18 11:03:43 2006.
--------------------------------------------------------------------------------

architecture structure of TRIGGER_STUFF is

  component SLAVE_DETECTOR
    port(
      CLK10MHz      : in     std_logic;
      CLK200MHz     : in     std_logic;
      SH1           : in     std_logic;
      SH1_SYNCHR    : out    std_logic;
      SH2           : in     std_logic;
      SH2_SYNCHR    : out    std_logic;
      SL1           : in     std_logic;
      SL1_SYNCHR    : out    std_logic;
      SL2           : in     std_logic;
      SL2_SYNCHR    : out    std_logic;
      SLAVE_PRESENT : out    std_logic;
      SYSRST        : in     std_logic);
  end component ;

  component DISCRIMINATORS
    port(
      CLK200MHz     : in     std_logic;
      COINC_TIME    : in     integer range 1000 downto 0;
      COMPH1        : out    std_logic;
      COMPH1_IN     : in     std_logic;
      COMPH2        : out    std_logic;
      COMPH2_IN     : in     std_logic;
      COMPL1        : out    std_logic;
      COMPL1_IN     : in     std_logic;
      COMPL2        : out    std_logic;
      COMPL2_IN     : in     std_logic;
      DATA_ADC1_NEG : in     std_logic_vector(11 downto 0);
      DATA_ADC1_POS : in     std_logic_vector(11 downto 0);
      DATA_ADC2_NEG : in     std_logic_vector(11 downto 0);
      DATA_ADC2_POS : in     std_logic_vector(11 downto 0);
      EXT_TR_IN     : in     std_logic;
      EXT_TR_OUT    : out    std_logic;
      MH1_OUT       : out    std_logic;
      MH2_OUT       : out    std_logic;
      ML1_OUT       : out    std_logic;
      ML2_OUT       : out    std_logic;
      SYSRST        : in     std_logic;
      THH1          : in     std_logic_vector(11 downto 0);
      THH2          : in     std_logic_vector(11 downto 0);
      THL1          : in     std_logic_vector(11 downto 0);
      THL2          : in     std_logic_vector(11 downto 0));
  end component ;

  component TRIGGER_MATRIX
    port(
      BLOCK_COINC     : in     std_logic;
      CLK10MHz        : in     std_logic;
      CLK200MHz       : in     std_logic;
      COMPH1          : in     std_logic;
      COMPH2          : in     std_logic;
      COMPL1          : in     std_logic;
      COMPL2          : in     std_logic;
      END_OF_COINC    : out    std_logic;
      EXT_TR          : in     std_logic;
      MASTER          : in     std_logic;
      MH1             : in     std_logic;
      MH2             : in     std_logic;
      ML1             : in     std_logic;
      ML2             : in     std_logic;
      SH1_IN          : in     std_logic;
      SH2_IN          : in     std_logic;
      SL1_IN          : in     std_logic;
      SL2_IN          : in     std_logic;
      SLAVE_PRESENT   : in     std_logic;
      SYSRST          : in     std_logic;
      TRIGGER_PATTERN : out    std_logic_vector(15 downto 0);
      TR_CONDITION    : in     std_logic_vector(7 downto 0));
  end component ;

  component LED_DRIVER
    port(
      CLK10MHz : in     std_logic;
      INP      : in     std_logic;
      SYSRST   : in     std_logic;
      nOUTP    : out    std_logic);
  end component ;

  signal SLAVE_PRESENT_net :  std_logic;
  signal MH2_net           :  std_logic;
  signal MH1_net           :  std_logic;
  signal COMPL1_net        :  std_logic;
  signal COMPH1_net        :  std_logic;
  signal COMPL2_net        :  std_logic;
  signal COMPH2_net        :  std_logic;
  signal SH2_SYNCHR        :  std_logic;
  signal SL2_SYNCHR        :  std_logic;
  signal SH1_SYNCHR        :  std_logic;
  signal SL1_SYNCHR1       :  std_logic;
  signal ML2_net           :  std_logic;
  signal ML1_net           :  std_logic;
  signal EXT_TR_OUT_net    :  std_logic;

begin

  SLAVE_PRESENT <= SLAVE_PRESENT_net;
  MH2 <= MH2_net;
  MH1 <= MH1_net;
  ML2 <= ML2_net;
  ML1 <= ML1_net;

  u0: SLAVE_DETECTOR
    port map(
      CLK10MHz => CLK10MHz,
      CLK200MHz => CLK200MHz,
      SH1 => SH1,
      SH1_SYNCHR => SH1_SYNCHR,
      SH2 => SH2,
      SH2_SYNCHR => SH2_SYNCHR,
      SL1 => SL1,
      SL1_SYNCHR => SL1_SYNCHR1,
      SL2 => SL2,
      SL2_SYNCHR => SL2_SYNCHR,
      SLAVE_PRESENT => SLAVE_PRESENT_net,
      SYSRST => SYSRST);

  u1: DISCRIMINATORS
    port map(
      CLK200MHz => CLK200MHz,
      COINC_TIME => COINC_TIME,
      COMPH1 => COMPH1_net,
      COMPH1_IN => COMPH1,
      COMPH2 => COMPH2_net,
      COMPH2_IN => COMPH2,
      COMPL1 => COMPL1_net,
      COMPL1_IN => COMPL1,
      COMPL2 => COMPL2_net,
      COMPL2_IN => COMPL2,
      DATA_ADC1_NEG => DATA_ADC1_NEG,
      DATA_ADC1_POS => DATA_ADC1_POS,
      DATA_ADC2_NEG => DATA_ADC2_NEG,
      DATA_ADC2_POS => DATA_ADC2_POS,
      EXT_TR_IN => EXT_TR_IN,
      EXT_TR_OUT => EXT_TR_OUT_net,
      MH1_OUT => MH1_net,
      MH2_OUT => MH2_net,
      ML1_OUT => ML1_net,
      ML2_OUT => ML2_net,
      SYSRST => SYSRST,
      THH1 => THH1,
      THH2 => THH2,
      THL1 => THL1,
      THL2 => THL2);

  u2: TRIGGER_MATRIX
    port map(
      BLOCK_COINC => BLOCK_COINC,
      CLK10MHz => CLK10MHz,
      CLK200MHz => CLK200MHz,
      COMPH1 => COMPH1_net,
      COMPH2 => COMPH2_net,
      COMPL1 => COMPL1_net,
      COMPL2 => COMPL2_net,
      END_OF_COINC => END_OF_COINC,
      EXT_TR => EXT_TR_OUT_net,
      MASTER => MASTER,
      MH1 => MH1_net,
      MH2 => MH2_net,
      ML1 => ML1_net,
      ML2 => ML2_net,
      SH1_IN => SH1_SYNCHR,
      SH2_IN => SH2_SYNCHR,
      SL1_IN => SL1_SYNCHR1,
      SL2_IN => SL2_SYNCHR,
      SLAVE_PRESENT => SLAVE_PRESENT_net,
      SYSRST => SYSRST,
      TRIGGER_PATTERN => TRIGGER_PATTERN,
      TR_CONDITION => TR_CONDITION);

  u4: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => ML1_net,
      SYSRST => SYSRST,
      nOUTP => HITLED1);

  u5: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => ML2_net,
      SYSRST => SYSRST,
      nOUTP => HITLED2);
end structure ; -- of TRIGGER_STUFF

--------------------------------------------------------------------------------
-- Entity declaration of 'DATA_CONTROLLER'.
-- Last modified : Wed Jul 18 11:17:04 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity DATA_CONTROLLER is
  port(
    ADC_A0                  : out    std_logic;
    ADC_A1                  : out    std_logic;
    ADC_DATA                : in     std_logic_vector(7 downto 0);
    ADC_MODE                : out    std_logic;
    ADC_nCS                 : out    std_logic;
    ADC_nINT                : in     std_logic;
    ADC_nRD                 : out    std_logic;
    ADC_nWR_RDY             : in     std_logic;
    ALTITUDE                : in     std_logic_vector(63 downto 0);
    CLK10MHz                : in     std_logic;
    CLKRD                   : in     std_logic;
    COINC_TIME              : out    integer range 1000 downto 0;
    COMPDATA                : in     std_logic_vector(127 downto 0);
    COMPDATA_READOUT_DONE   : out    std_logic;
    COMPDATA_VALID          : in     std_logic;
    CTD_IN                  : in     std_logic_vector(31 downto 0);
    CTD_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
    CTP_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
    DAC_A0                  : out    std_logic;
    DAC_A1                  : out    std_logic;
    DAC_A2                  : out    std_logic;
    DAC_DATA_0              : out    std_logic;
    DAC_DATA_1              : out    std_logic;
    DAC_DATA_2              : out    std_logic;
    DAC_DATA_3              : out    std_logic;
    DAC_DATA_4              : out    std_logic;
    DAC_DATA_5              : out    std_logic;
    DAC_DATA_6              : out    std_logic;
    DAC_DATA_7              : out    std_logic;
    DAC_nCLR                : out    std_logic;
    DAC_nCS1                : out    std_logic;
    DAC_nCS2                : out    std_logic;
    DAC_nLDAC               : out    std_logic;
    DAC_nRD                 : out    std_logic;
    DAC_nWR                 : out    std_logic;
    DATA_IN                 : in     std_logic_vector(7 downto 0);
    DATA_READY_FIFO         : in     std_logic;
    DIN_VALID               : in     std_logic;
    ERROR_READ_OUT          : out    std_logic;
    GPS_PROG_ENABLE         : out    std_logic;
    GPS_TS_IN               : in     std_logic_vector(55 downto 0);
    GPS_TS_ONE_PPS          : in     std_logic_vector(55 downto 0);
    LATITUDE                : in     std_logic_vector(63 downto 0);
    LONGITUDE               : in     std_logic_vector(63 downto 0);
    MASTER                  : in     std_logic;
    NEW_DATA_WHILE_READOUT  : out    std_logic;
    ONE_PPS                 : in     std_logic;
    POST_TIME               : out    integer range 1600 downto 0;
    RDEN                    : out    std_logic;
    READ_BUSY_OUT           : out    std_logic;
    SAT_INFO                : in     std_logic_vector(487 downto 0);
    SERIAL_NUMBER           : in     std_logic_vector(9 downto 0);
    SLAVE_PRESENT           : in     std_logic;
    SOFT_RESET              : out    std_logic;
    STOP_READ_OUT           : out    std_logic;
    SYSRST                  : in     std_logic;
    TEMP                    : in     std_logic_vector(31 downto 0);
    THH1                    : out    std_logic_vector(11 downto 0);
    THH2                    : out    std_logic_vector(11 downto 0);
    THL1                    : out    std_logic_vector(11 downto 0);
    THL2                    : out    std_logic_vector(11 downto 0);
    TH_COUNTERS_IN          : in     std_logic_vector(63 downto 0);
    TOTAL_TIME              : out    integer range 2000 downto 0;
    TOTAL_TIME_3X           : out    integer range 6000 downto 0;
    TRIGGER_PATTERN         : in     std_logic_vector(15 downto 0);
    TR_CONDITION            : out    std_logic_vector(7 downto 0);
    TS_ONE_PPS_READOUT_DONE : out    std_logic;
    TS_ONE_PPS_VALID_IN     : in     std_logic;
    USB_DATA                : inout  std_logic_vector(7 downto 0);
    USB_RD                  : out    std_logic;
    USB_RXF                 : in     std_logic;
    USB_TXE                 : in     std_logic;
    USB_WR                  : out    std_logic;
    USB_WRITE_ENABLE        : out    std_logic);
end DATA_CONTROLLER ;

--------------------------------------------------------------------------------
-- Architecture 'structure' of 'DATA_CONTROLLER'
-- Last modified : Wed Jul 18 11:17:04 2007.
--------------------------------------------------------------------------------

architecture structure of DATA_CONTROLLER is

  component EVENT_DATA_HANDLER
    port(
      CLKRD           : in     std_logic;
      DATA_IN         : in     std_logic_vector(7 downto 0);
      DATA_READY      : in     std_logic;
      DATA_READY_FIFO : in     std_logic;
      DIN_VALID       : in     std_logic;
      RDEN            : out    std_logic;
      READOUT_BUSY    : out    std_logic;
      SYSRST          : in     std_logic;
      USB_DATA        : out    std_logic_vector(7 downto 0);
      WR              : in     std_logic;
      WR_EN           : out    std_logic);
  end component ;

  component USB_WRITE_HANDLER
    port(
      ALTITUDE                    : in     std_logic_vector(63 downto 0);
      CLK10MHz                    : in     std_logic;
      CLKRD                       : in     std_logic;
      COINC_TIME                  : in     std_logic_vector(15 downto 0);
      COMPDATA                    : in     std_logic_vector(127 downto 0);
      COMPDATA_READOUT_DONE       : out    std_logic;
      COMPDATA_VALID              : in     std_logic;
      CTD_IN                      : in     std_logic_vector(31 downto 0);
      CTD_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
      CTP_TS_ONE_PPS              : in     std_logic_vector(31 downto 0);
      EVENT_DATA_IN               : in     std_logic_vector(7 downto 0);
      EVENT_READOUT_BUSY          : in     std_logic;
      EVENT_WR                    : out    std_logic;
      EVENT_WR_EN                 : in     std_logic;
      GPS_TS_IN                   : in     std_logic_vector(55 downto 0);
      GPS_TS_ONE_PPS              : in     std_logic_vector(55 downto 0);
      LATITUDE                    : in     std_logic_vector(63 downto 0);
      LONGITUDE                   : in     std_logic_vector(63 downto 0);
      NEW_DATA_WHILE_READOUT      : out    std_logic;
      PARAMETER_LIST              : in     std_logic_vector(271 downto 0);
      PARAMETER_LIST_READOUT_DONE : out    std_logic;
      PARAMETER_LIST_VALID        : in     std_logic;
      POST_TIME                   : in     std_logic_vector(15 downto 0);
      PRE_TIME                    : in     std_logic_vector(15 downto 0);
      READ_ERROR_DATA             : in     std_logic_vector(7 downto 0);
      READ_ERROR_READOUT_DONE     : out    std_logic;
      READ_ERROR_VALID            : in     std_logic;
      SAT_INFO                    : in     std_logic_vector(487 downto 0);
      SECOND_MESSAGE_ALLOWED      : in     std_logic;
      SEND_EVENT_DATA             : out    std_logic;
      START_WRITE_EVENT           : in     std_logic;
      SYSRST                      : in     std_logic;
      TEMP                        : in     std_logic_vector(31 downto 0);
      TH_COUNTERS_IN              : in     std_logic_vector(63 downto 0);
      TRIGGER_PATTERN             : in     std_logic_vector(15 downto 0);
      TR_CONDITION                : in     std_logic_vector(7 downto 0);
      TS_ONE_PPS_READOUT_DONE     : out    std_logic;
      TS_ONE_PPS_VALID_INPUT      : in     std_logic;
      USB_DATA_OUT                : out    std_logic_vector(7 downto 0);
      USB_TXE                     : in     std_logic;
      USB_WR                      : out    std_logic;
      USB_WRITE_BUSY              : out    std_logic;
      USB_WRITE_ENABLE            : in     std_logic;
      USB_WRITE_REQUEST           : out    std_logic);
  end component ;

  component USB_READ_HANDLER
    port(
      ADC_A0                      : out    std_logic;
      ADC_A1                      : out    std_logic;
      ADC_DATA_IN                 : in     std_logic_vector(7 downto 0);
      ADC_MODE                    : out    std_logic;
      ADC_nCS                     : out    std_logic;
      ADC_nINT                    : in     std_logic;
      ADC_nRD                     : out    std_logic;
      ADC_nWR_RDY                 : in     std_logic;
      CLK10MHz                    : in     std_logic;
      CLKRD                       : in     std_logic;
      COINC_TIME                  : out    integer range 1000 downto 0;
      COINC_TIME_OUT              : out    std_logic_vector(15 downto 0);
      DAC_A0                      : out    std_logic;
      DAC_A1                      : out    std_logic;
      DAC_A2                      : out    std_logic;
      DAC_DATA_0                  : out    std_logic;
      DAC_DATA_1                  : out    std_logic;
      DAC_DATA_2                  : out    std_logic;
      DAC_DATA_3                  : out    std_logic;
      DAC_DATA_4                  : out    std_logic;
      DAC_DATA_5                  : out    std_logic;
      DAC_DATA_6                  : out    std_logic;
      DAC_DATA_7                  : out    std_logic;
      DAC_nCLR                    : out    std_logic;
      DAC_nCS1                    : out    std_logic;
      DAC_nCS2                    : out    std_logic;
      DAC_nLDAC                   : out    std_logic;
      DAC_nRD                     : out    std_logic;
      DAC_nWR                     : out    std_logic;
      ERROR_READ_OUT              : out    std_logic;
      GPS_PROG_ENABLE             : out    std_logic;
      MASTER                      : in     std_logic;
      ONE_PPS                     : in     std_logic;
      PARAMETER_LIST              : out    std_logic_vector(271 downto 0);
      PARAMETER_LIST_READOUT_DONE : in     std_logic;
      PARAMETER_LIST_VALID        : out    std_logic;
      POST_TIME                   : out    integer range 1600 downto 0;
      POST_TIME_OUT               : out    std_logic_vector(15 downto 0);
      PRE_TIME_OUT                : out    std_logic_vector(15 downto 0);
      READ_BUSY_OUT               : out    std_logic;
      READ_ERROR_DATA             : out    std_logic_vector(7 downto 0);
      READ_ERROR_READOUT_DONE     : in     std_logic;
      READ_ERROR_VALID            : out    std_logic;
      SECOND_MESSAGE_ALLOWED      : out    std_logic;
      SERIAL_NUMBER               : in     std_logic_vector(9 downto 0);
      SLAVE_PRESENT               : in     std_logic;
      SOFT_RESET                  : out    std_logic;
      STOP_READ_OUT               : out    std_logic;
      SYSRST                      : in     std_logic;
      THH1                        : out    std_logic_vector(11 downto 0);
      THH2                        : out    std_logic_vector(11 downto 0);
      THL1                        : out    std_logic_vector(11 downto 0);
      THL2                        : out    std_logic_vector(11 downto 0);
      TOTAL_TIME                  : out    integer range 2000 downto 0;
      TOTAL_TIME_3X               : out    integer range 6000 downto 0;
      TR_CONDITION                : out    std_logic_vector(7 downto 0);
      USB_DATA_IN                 : in     std_logic_vector(7 downto 0);
      USB_RD                      : out    std_logic;
      USB_RXF                     : in     std_logic;
      USB_WRITE_BUSY              : in     std_logic;
      USB_WRITE_ENABLE            : out    std_logic;
      USB_WRITE_REQUEST           : in     std_logic);
  end component ;

  signal USB_DATA_net                :  std_logic_vector(7 downto 0);
  signal WR_EN                       :  std_logic;
  signal READOUT_BUSY                :  std_logic;
  signal SEND_EVENT_DATA             :  std_logic;
  signal EVENT_WR                    :  std_logic;
  signal POST_TIME_OUT               :  std_logic_vector(15 downto 0);
  signal COINC_TIME_OUT              :  std_logic_vector(15 downto 0);
  signal PRE_TIME_OUT                :  std_logic_vector(15 downto 0);
  signal PARAMETER_LIST_VALID        :  std_logic;
  signal PARAMETER_LIST_READOUT_DONE :  std_logic;
  signal READ_ERROR_VALID            :  std_logic;
  signal READ_ERROR_READOUT_DONE     :  std_logic;
  signal READ_ERROR_DATA             :  std_logic_vector(7 downto 0);
  signal USB_WRITE_ENABLE_net        :  std_logic;
  signal USB_WRITE_BUSY              :  std_logic;
  signal USB_WRITE_REQUEST           :  std_logic;
  signal TR_CONDITION_net            :  std_logic_vector(7 downto 0);
  signal PARAMETER_LIST              :  std_logic_vector(271 downto 0);
  signal SECOND_MESSAGE_ALLOWED      :  std_logic;

begin

  USB_WRITE_ENABLE <= USB_WRITE_ENABLE_net;
  TR_CONDITION <= TR_CONDITION_net;

  u1: EVENT_DATA_HANDLER
    port map(
      CLKRD => CLKRD,
      DATA_IN => DATA_IN,
      DATA_READY => SEND_EVENT_DATA,
      DATA_READY_FIFO => DATA_READY_FIFO,
      DIN_VALID => DIN_VALID,
      RDEN => RDEN,
      READOUT_BUSY => READOUT_BUSY,
      SYSRST => SYSRST,
      USB_DATA => USB_DATA_net,
      WR => EVENT_WR,
      WR_EN => WR_EN);

  u2: USB_WRITE_HANDLER
    port map(
      ALTITUDE => ALTITUDE,
      CLK10MHz => CLK10MHz,
      CLKRD => CLKRD,
      COINC_TIME => COINC_TIME_OUT,
      COMPDATA => COMPDATA,
      COMPDATA_READOUT_DONE => COMPDATA_READOUT_DONE,
      COMPDATA_VALID => COMPDATA_VALID,
      CTD_IN => CTD_IN,
      CTD_TS_ONE_PPS => CTD_TS_ONE_PPS,
      CTP_TS_ONE_PPS => CTP_TS_ONE_PPS,
      EVENT_DATA_IN => USB_DATA_net,
      EVENT_READOUT_BUSY => READOUT_BUSY,
      EVENT_WR => EVENT_WR,
      EVENT_WR_EN => WR_EN,
      GPS_TS_IN => GPS_TS_IN,
      GPS_TS_ONE_PPS => GPS_TS_ONE_PPS,
      LATITUDE => LATITUDE,
      LONGITUDE => LONGITUDE,
      NEW_DATA_WHILE_READOUT => NEW_DATA_WHILE_READOUT,
      PARAMETER_LIST => PARAMETER_LIST,
      PARAMETER_LIST_READOUT_DONE => PARAMETER_LIST_READOUT_DONE,
      PARAMETER_LIST_VALID => PARAMETER_LIST_VALID,
      POST_TIME => POST_TIME_OUT,
      PRE_TIME => PRE_TIME_OUT,
      READ_ERROR_DATA => READ_ERROR_DATA,
      READ_ERROR_READOUT_DONE => READ_ERROR_READOUT_DONE,
      READ_ERROR_VALID => READ_ERROR_VALID,
      SAT_INFO => SAT_INFO,
      SECOND_MESSAGE_ALLOWED => SECOND_MESSAGE_ALLOWED,
      SEND_EVENT_DATA => SEND_EVENT_DATA,
      START_WRITE_EVENT => DATA_READY_FIFO,
      SYSRST => SYSRST,
      TEMP => TEMP,
      TH_COUNTERS_IN => TH_COUNTERS_IN,
      TRIGGER_PATTERN => TRIGGER_PATTERN,
      TR_CONDITION => TR_CONDITION_net,
      TS_ONE_PPS_READOUT_DONE => TS_ONE_PPS_READOUT_DONE,
      TS_ONE_PPS_VALID_INPUT => TS_ONE_PPS_VALID_IN,
      USB_DATA_OUT => USB_DATA,
      USB_TXE => USB_TXE,
      USB_WR => USB_WR,
      USB_WRITE_BUSY => USB_WRITE_BUSY,
      USB_WRITE_ENABLE => USB_WRITE_ENABLE_net,
      USB_WRITE_REQUEST => USB_WRITE_REQUEST);

  u4: USB_READ_HANDLER
    port map(
      ADC_A0 => ADC_A0,
      ADC_A1 => ADC_A1,
      ADC_DATA_IN => ADC_DATA,
      ADC_MODE => ADC_MODE,
      ADC_nCS => ADC_nCS,
      ADC_nINT => ADC_nINT,
      ADC_nRD => ADC_nRD,
      ADC_nWR_RDY => ADC_nWR_RDY,
      CLK10MHz => CLK10MHz,
      CLKRD => CLKRD,
      COINC_TIME => COINC_TIME,
      COINC_TIME_OUT => COINC_TIME_OUT,
      DAC_A0 => DAC_A0,
      DAC_A1 => DAC_A1,
      DAC_A2 => DAC_A2,
      DAC_DATA_0 => DAC_DATA_0,
      DAC_DATA_1 => DAC_DATA_1,
      DAC_DATA_2 => DAC_DATA_2,
      DAC_DATA_3 => DAC_DATA_3,
      DAC_DATA_4 => DAC_DATA_4,
      DAC_DATA_5 => DAC_DATA_5,
      DAC_DATA_6 => DAC_DATA_6,
      DAC_DATA_7 => DAC_DATA_7,
      DAC_nCLR => DAC_nCLR,
      DAC_nCS1 => DAC_nCS1,
      DAC_nCS2 => DAC_nCS2,
      DAC_nLDAC => DAC_nLDAC,
      DAC_nRD => DAC_nRD,
      DAC_nWR => DAC_nWR,
      ERROR_READ_OUT => ERROR_READ_OUT,
      GPS_PROG_ENABLE => GPS_PROG_ENABLE,
      MASTER => MASTER,
      ONE_PPS => ONE_PPS,
      PARAMETER_LIST => PARAMETER_LIST,
      PARAMETER_LIST_READOUT_DONE => PARAMETER_LIST_READOUT_DONE,
      PARAMETER_LIST_VALID => PARAMETER_LIST_VALID,
      POST_TIME => POST_TIME,
      POST_TIME_OUT => POST_TIME_OUT,
      PRE_TIME_OUT => PRE_TIME_OUT,
      READ_BUSY_OUT => READ_BUSY_OUT,
      READ_ERROR_DATA => READ_ERROR_DATA,
      READ_ERROR_READOUT_DONE => READ_ERROR_READOUT_DONE,
      READ_ERROR_VALID => READ_ERROR_VALID,
      SECOND_MESSAGE_ALLOWED => SECOND_MESSAGE_ALLOWED,
      SERIAL_NUMBER => SERIAL_NUMBER,
      SLAVE_PRESENT => SLAVE_PRESENT,
      SOFT_RESET => SOFT_RESET,
      STOP_READ_OUT => STOP_READ_OUT,
      SYSRST => SYSRST,
      THH1 => THH1,
      THH2 => THH2,
      THL1 => THL1,
      THL2 => THL2,
      TOTAL_TIME => TOTAL_TIME,
      TOTAL_TIME_3X => TOTAL_TIME_3X,
      TR_CONDITION => TR_CONDITION_net,
      USB_DATA_IN => USB_DATA,
      USB_RD => USB_RD,
      USB_RXF => USB_RXF,
      USB_WRITE_BUSY => USB_WRITE_BUSY,
      USB_WRITE_ENABLE => USB_WRITE_ENABLE_net,
      USB_WRITE_REQUEST => USB_WRITE_REQUEST);
end structure ; -- of DATA_CONTROLLER

--------------------------------------------------------------------------------
-- Entity declaration of 'STORAGE_ONE_CHANNEL'.
-- Last modified : Mon Jan 16 21:49:15 2006.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity STORAGE_ONE_CHANNEL is
  port(
    CLK200MHz          : in     std_logic;
    CLKRD              : in     std_logic;
    COINC_TO_END_TIME1 : in     std_logic;
    COINC_TO_END_TIME2 : in     std_logic;
    DATA_ADC_NEG       : in     std_logic_vector(11 downto 0);
    DATA_ADC_POS       : in     std_logic_vector(11 downto 0);
    DATA_OUT1          : out    std_logic_vector(11 downto 0);
    DATA_OUT2          : out    std_logic_vector(11 downto 0);
    DATA_READY1        : out    std_logic;
    DATA_READY2        : out    std_logic;
    RDEN1              : in     std_logic;
    RDEN2              : in     std_logic;
    READOUT_BUSY1      : out    std_logic;
    READOUT_BUSY2      : out    std_logic;
    SYSRST             : in     std_logic;
    TOTAL_TIME         : in     integer range 2000 downto 0);
end STORAGE_ONE_CHANNEL ;

--------------------------------------------------------------------------------
-- Architecture 'structure' of 'STORAGE_ONE_CHANNEL'
-- Last modified : Mon Jan 16 21:49:15 2006.
--------------------------------------------------------------------------------

architecture structure of STORAGE_ONE_CHANNEL is

  component STORAGE
    port(
      CLK200MHz         : in     std_logic;
      CLKRD             : in     std_logic;
      COINC_TO_END_TIME : in     std_logic;
      DATA_ADC_NEG      : in     std_logic_vector(11 downto 0);
      DATA_ADC_POS      : in     std_logic_vector(11 downto 0);
      DATA_OUT          : out    std_logic_vector(11 downto 0);
      DATA_READY        : out    std_logic;
      RDEN              : in     std_logic;
      READOUT_BUSY      : out    std_logic;
      SYSRST            : in     std_logic;
      TOTAL_TIME        : in     integer range 2000 downto 0);
  end component ;

begin


  u0: STORAGE
    port map(
      CLK200MHz => CLK200MHz,
      CLKRD => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME1,
      DATA_ADC_NEG => DATA_ADC_POS,
      DATA_ADC_POS => DATA_ADC_NEG,
      DATA_OUT => DATA_OUT1,
      DATA_READY => DATA_READY1,
      RDEN => RDEN1,
      READOUT_BUSY => READOUT_BUSY1,
      SYSRST => SYSRST,
      TOTAL_TIME => TOTAL_TIME);

  u1: STORAGE
    port map(
      CLK200MHz => CLK200MHz,
      CLKRD => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME2,
      DATA_ADC_NEG => DATA_ADC_POS,
      DATA_ADC_POS => DATA_ADC_NEG,
      DATA_OUT => DATA_OUT2,
      DATA_READY => DATA_READY2,
      RDEN => RDEN2,
      READOUT_BUSY => READOUT_BUSY2,
      SYSRST => SYSRST,
      TOTAL_TIME => TOTAL_TIME);
end structure ; -- of STORAGE_ONE_CHANNEL

--------------------------------------------------------------------------------
-- Entity declaration of 'hisparc'.
-- Last modified : Tue Jul 17 14:45:41 2007.
--------------------------------------------------------------------------------


library ieee ;
use ieee.numeric_std.all ;
use ieee.std_logic_unsigned.all ;
use ieee.std_logic_1164.all ;

entity hisparc is
  port(
    ADC_1_NEG_OR     : in     std_logic;
    ADC_1_POS_OR     : in     std_logic;
    ADC_2_NEG_OR     : in     std_logic;
    ADC_2_POS_OR     : in     std_logic;
    ADC_A0           : out    std_logic;
    ADC_A1           : out    std_logic;
    ADC_DATA         : in     std_logic_vector(7 downto 0);
    ADC_MODE         : out    std_logic;
    ADC_nCS          : out    std_logic;
    ADC_nINT         : in     std_logic;
    ADC_nRD          : out    std_logic;
    ADC_nWR_RDY      : in     std_logic;
    CLK10MHz         : in     std_logic;
    CLK200MHz_LVDS   : in     std_logic;
    COMPH1           : in     std_logic;
    COMPH2           : in     std_logic;
    COMPL1           : in     std_logic;
    COMPL2           : in     std_logic;
    DAC_A0           : out    std_logic;
    DAC_A1           : out    std_logic;
    DAC_A2           : out    std_logic;
    DAC_DATA_0       : out    std_logic;
    DAC_DATA_1       : out    std_logic;
    DAC_DATA_2       : out    std_logic;
    DAC_DATA_3       : out    std_logic;
    DAC_DATA_4       : out    std_logic;
    DAC_DATA_5       : out    std_logic;
    DAC_DATA_6       : out    std_logic;
    DAC_DATA_7       : out    std_logic;
    DAC_nCLR         : out    std_logic;
    DAC_nCS1         : out    std_logic;
    DAC_nCS2         : out    std_logic;
    DAC_nLDAC        : out    std_logic;
    DAC_nRD          : out    std_logic;
    DAC_nWR          : out    std_logic;
    DATA_NEG_ADC_CH1 : in     std_logic_vector(11 downto 0);
    DATA_NEG_ADC_CH2 : in     std_logic_vector(11 downto 0);
    DATA_POS_ADC_CH1 : in     std_logic_vector(11 downto 0);
    DATA_POS_ADC_CH2 : in     std_logic_vector(11 downto 0);
    DCO_NEG_ADC_CH1  : in     std_logic;
    DCO_NEG_ADC_CH2  : in     std_logic;
    DCO_POS_ADC_CH1  : in     std_logic;
    DCO_POS_ADC_CH2  : in     std_logic;
    EXT_TR_IN        : in     std_logic;
    GPS_SDI          : out    std_logic;
    GPS_SDO          : in     std_logic;
    HITLED1          : out    std_logic;
    HITLED2          : out    std_logic;
    LED3             : out    std_logic;
    LED4             : out    std_logic;
    LED5             : out    std_logic;
    LED6             : out    std_logic;
    LED7             : out    std_logic;
    LED8             : out    std_logic;
    LED9             : out    std_logic;
    LVDS_IN1         : in     std_logic;
    LVDS_IN2         : in     std_logic;
    LVDS_IN3         : in     std_logic;
    LVDS_IN4         : in     std_logic;
    LVDS_OUT1        : out    std_logic;
    LVDS_OUT2        : out    std_logic;
    LVDS_OUT3        : out    std_logic;
    LVDS_OUT4        : out    std_logic;
    ONE_PPS          : in     std_logic;
    SERIAL_NUMBER    : in     std_logic_vector(9 downto 0);
    SPY_CON          : in     std_logic;
    SPY_SDI          : out    std_logic;
    SPY_SDO          : in     std_logic;
    USB_DATA         : inout  std_logic_vector(7 downto 0);
    USB_RD           : out    std_logic;
    USB_RXF          : in     std_logic;
    USB_TXE          : in     std_logic;
    USB_WR           : out    std_logic;
    nMASTER          : out    std_logic;
    nSLAVE_PRESENT   : out    std_logic;
    nSYSRST          : in     std_logic);
end hisparc ;

--------------------------------------------------------------------------------
-- Architecture 'a0' of 'hisparc'
-- Last modified : Tue Jul 17 14:45:41 2007.
--------------------------------------------------------------------------------

architecture a0 of hisparc is

  component WINDOW_MAKER
    port(
      CLK200MHz         : in     std_logic;
      COINC_TO_END_TIME : out    std_logic;
      END_OF_COINC      : in     std_logic;
      POST_TIME         : in     integer range 1600 downto 0;
      SYSRST            : in     std_logic);
  end component ;

  component STORAGE_ONE_CHANNEL
    port(
      CLK200MHz          : in     std_logic;
      CLKRD              : in     std_logic;
      COINC_TO_END_TIME1 : in     std_logic;
      COINC_TO_END_TIME2 : in     std_logic;
      DATA_ADC_NEG       : in     std_logic_vector(11 downto 0);
      DATA_ADC_POS       : in     std_logic_vector(11 downto 0);
      DATA_OUT1          : out    std_logic_vector(11 downto 0);
      DATA_OUT2          : out    std_logic_vector(11 downto 0);
      DATA_READY1        : out    std_logic;
      DATA_READY2        : out    std_logic;
      RDEN1              : in     std_logic;
      RDEN2              : in     std_logic;
      READOUT_BUSY1      : out    std_logic;
      READOUT_BUSY2      : out    std_logic;
      SYSRST             : in     std_logic;
      TOTAL_TIME         : in     integer range 2000 downto 0);
  end component ;

  component PLL
    port(
      CLK200MHz : out    std_logic;
      inclk0    : in     std_logic;
      locked    : out    std_logic);
  end component ;

  component SYNCHRONISATION
    port(
      CLK200MHz    : in     std_logic;
      DATA_NEG_ADC : in     std_logic_vector(11 downto 0);
      DATA_POS_ADC : in     std_logic_vector(11 downto 0);
      DCO_NEG_ADC  : in     std_logic;
      DCO_POS_ADC  : in     std_logic;
      DOUT_NEG     : out    std_logic_vector(11 downto 0);
      DOUT_POS     : out    std_logic_vector(11 downto 0);
      LOCKED       : in     std_logic;
      SYSRST       : in     std_logic);
  end component ;

  component CONVERSION_12_TO_8_BIT
    port(
      CLKRD              : in     std_logic;
      CONVERSION_CLK     : in     std_logic;
      CONV_DATA_READY    : out    std_logic;
      CTD_IN             : in     std_logic_vector(31 downto 0);
      CTD_OUT            : out    std_logic_vector(31 downto 0);
      DATA_OUT           : out    std_logic_vector(7 downto 0);
      DATA_OUT_CH1       : in     std_logic_vector(11 downto 0);
      DATA_OUT_CH2       : in     std_logic_vector(11 downto 0);
      DATA_READY_CH1     : in     std_logic;
      DATA_READY_CH2     : in     std_logic;
      DATA_VALID_CH1     : in     std_logic;
      DATA_VALID_CH2     : in     std_logic;
      FIFO_EMPTY         : in     std_logic;
      GPS_TS_IN          : in     std_logic_vector(55 downto 0);
      GPS_TS_OUT         : out    std_logic_vector(55 downto 0);
      RDEN_CH1           : out    std_logic;
      RDEN_CH2           : out    std_logic;
      SYSRST             : in     std_logic;
      TOTAL_TIME_3X      : in     integer range 6000 downto 0;
      TOTAL_TIME_6X      : out    integer range 12000 downto 0;
      TRIGGER_PATTERN    : out    std_logic_vector(15 downto 0);
      TRIGGER_PATTERN_IN : in     std_logic_vector(15 downto 0);
      WE                 : out    std_logic;
      WR_ADDRESS         : out    integer range 12020 downto 0);
  end component ;

  component EVENT_FIFO
    port(
      DATA_IN    : in     std_logic_vector(7 downto 0);
      DATA_OUT   : out    std_logic_vector(7 downto 0);
      RDCLOCK    : in     std_logic;
      RD_ADDRESS : in     integer range 12020 downto 0;
      WE         : in     std_logic;
      WRCLOCK    : in     std_logic;
      WR_ADDRESS : in     integer range 12020 downto 0);
  end component ;

  component EVENT_FIFO_CONTROL
    port(
      CLKRD            : in     std_logic;
      DATA_READY_CONV  : in     std_logic;
      DOUT_VALID       : out    std_logic;
      EVENT_DATA_READY : out    std_logic;
      FIFO_EMPTY       : out    std_logic;
      RDCLOCK          : out    std_logic;
      RDEN             : in     std_logic;
      RD_ADDRESS       : out    integer range 12020 downto 0;
      SYSRST           : in     std_logic;
      TOTAL_TIME_6X    : in     integer range 12000 downto 0);
  end component ;

  component TRIGGER_STUFF
    port(
      BLOCK_COINC     : in     std_logic;
      CLK10MHz        : in     std_logic;
      CLK200MHz       : in     std_logic;
      COINC_TIME      : in     integer range 1000 downto 0;
      COMPH1          : in     std_logic;
      COMPH2          : in     std_logic;
      COMPL1          : in     std_logic;
      COMPL2          : in     std_logic;
      DATA_ADC1_NEG   : in     std_logic_vector(11 downto 0);
      DATA_ADC1_POS   : in     std_logic_vector(11 downto 0);
      DATA_ADC2_NEG   : in     std_logic_vector(11 downto 0);
      DATA_ADC2_POS   : in     std_logic_vector(11 downto 0);
      END_OF_COINC    : out    std_logic;
      EXT_TR_IN       : in     std_logic;
      HITLED1         : out    std_logic;
      HITLED2         : out    std_logic;
      MASTER          : in     std_logic;
      MH1             : out    std_logic;
      MH2             : out    std_logic;
      ML1             : out    std_logic;
      ML2             : out    std_logic;
      SH1             : in     std_logic;
      SH2             : in     std_logic;
      SL1             : in     std_logic;
      SL2             : in     std_logic;
      SLAVE_PRESENT   : out    std_logic;
      SYSRST          : in     std_logic;
      THH1            : in     std_logic_vector(11 downto 0);
      THH2            : in     std_logic_vector(11 downto 0);
      THL1            : in     std_logic_vector(11 downto 0);
      THL2            : in     std_logic_vector(11 downto 0);
      TRIGGER_PATTERN : out    std_logic_vector(15 downto 0);
      TR_CONDITION    : in     std_logic_vector(7 downto 0));
  end component ;

  component CLK_DIV
    port(
      CLK10MHz : in     std_logic;
      CLKRD    : out    std_logic;
      RST      : in     std_logic);
  end component ;

  component DATA_CONTROLLER
    port(
      ADC_A0                  : out    std_logic;
      ADC_A1                  : out    std_logic;
      ADC_DATA                : in     std_logic_vector(7 downto 0);
      ADC_MODE                : out    std_logic;
      ADC_nCS                 : out    std_logic;
      ADC_nINT                : in     std_logic;
      ADC_nRD                 : out    std_logic;
      ADC_nWR_RDY             : in     std_logic;
      ALTITUDE                : in     std_logic_vector(63 downto 0);
      CLK10MHz                : in     std_logic;
      CLKRD                   : in     std_logic;
      COINC_TIME              : out    integer range 1000 downto 0;
      COMPDATA                : in     std_logic_vector(127 downto 0);
      COMPDATA_READOUT_DONE   : out    std_logic;
      COMPDATA_VALID          : in     std_logic;
      CTD_IN                  : in     std_logic_vector(31 downto 0);
      CTD_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
      CTP_TS_ONE_PPS          : in     std_logic_vector(31 downto 0);
      DAC_A0                  : out    std_logic;
      DAC_A1                  : out    std_logic;
      DAC_A2                  : out    std_logic;
      DAC_DATA_0              : out    std_logic;
      DAC_DATA_1              : out    std_logic;
      DAC_DATA_2              : out    std_logic;
      DAC_DATA_3              : out    std_logic;
      DAC_DATA_4              : out    std_logic;
      DAC_DATA_5              : out    std_logic;
      DAC_DATA_6              : out    std_logic;
      DAC_DATA_7              : out    std_logic;
      DAC_nCLR                : out    std_logic;
      DAC_nCS1                : out    std_logic;
      DAC_nCS2                : out    std_logic;
      DAC_nLDAC               : out    std_logic;
      DAC_nRD                 : out    std_logic;
      DAC_nWR                 : out    std_logic;
      DATA_IN                 : in     std_logic_vector(7 downto 0);
      DATA_READY_FIFO         : in     std_logic;
      DIN_VALID               : in     std_logic;
      ERROR_READ_OUT          : out    std_logic;
      GPS_PROG_ENABLE         : out    std_logic;
      GPS_TS_IN               : in     std_logic_vector(55 downto 0);
      GPS_TS_ONE_PPS          : in     std_logic_vector(55 downto 0);
      LATITUDE                : in     std_logic_vector(63 downto 0);
      LONGITUDE               : in     std_logic_vector(63 downto 0);
      MASTER                  : in     std_logic;
      NEW_DATA_WHILE_READOUT  : out    std_logic;
      ONE_PPS                 : in     std_logic;
      POST_TIME               : out    integer range 1600 downto 0;
      RDEN                    : out    std_logic;
      READ_BUSY_OUT           : out    std_logic;
      SAT_INFO                : in     std_logic_vector(487 downto 0);
      SERIAL_NUMBER           : in     std_logic_vector(9 downto 0);
      SLAVE_PRESENT           : in     std_logic;
      SOFT_RESET              : out    std_logic;
      STOP_READ_OUT           : out    std_logic;
      SYSRST                  : in     std_logic;
      TEMP                    : in     std_logic_vector(31 downto 0);
      THH1                    : out    std_logic_vector(11 downto 0);
      THH2                    : out    std_logic_vector(11 downto 0);
      THL1                    : out    std_logic_vector(11 downto 0);
      THL2                    : out    std_logic_vector(11 downto 0);
      TH_COUNTERS_IN          : in     std_logic_vector(63 downto 0);
      TOTAL_TIME              : out    integer range 2000 downto 0;
      TOTAL_TIME_3X           : out    integer range 6000 downto 0;
      TRIGGER_PATTERN         : in     std_logic_vector(15 downto 0);
      TR_CONDITION            : out    std_logic_vector(7 downto 0);
      TS_ONE_PPS_READOUT_DONE : out    std_logic;
      TS_ONE_PPS_VALID_IN     : in     std_logic;
      USB_DATA                : inout  std_logic_vector(7 downto 0);
      USB_RD                  : out    std_logic;
      USB_RXF                 : in     std_logic;
      USB_TXE                 : in     std_logic;
      USB_WR                  : out    std_logic;
      USB_WRITE_ENABLE        : out    std_logic);
  end component ;

  component GPS_STUFF
    port(
      ALTITUDE_OUT            : out    std_logic_vector(63 downto 0);
      CLK10MHz                : in     std_logic;
      CLK200MHz               : in     std_logic;
      COINC                   : in     std_logic;
      COMPDATA_OUT            : out    std_logic_vector(127 downto 0);
      COMPDATA_READOUT_DONE   : in     std_logic;
      COMPDATA_VALID_OUT      : out    std_logic;
      COMPH1_IN               : in     std_logic;
      COMPH2_IN               : in     std_logic;
      COMPL1_IN               : in     std_logic;
      COMPL2_IN               : in     std_logic;
      CTD_OUT                 : out    std_logic_vector(31 downto 0);
      CTD_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
      CTP_TS_ONE_PPS_OUT      : out    std_logic_vector(31 downto 0);
      GPS_PROG_ENABLE         : in     std_logic;
      GPS_SDI                 : out    std_logic;
      GPS_SDO                 : in     std_logic;
      GPS_TS_ONE_PPS_OUT      : out    std_logic_vector(55 downto 0);
      GPS_TS_OUT              : out    std_logic_vector(55 downto 0);
      LATITUDE_OUT            : out    std_logic_vector(63 downto 0);
      LONGITUDE_OUT           : out    std_logic_vector(63 downto 0);
      MASTER                  : out    std_logic;
      ONE_PPS                 : in     std_logic;
      RXD                     : in     std_logic;
      SAT_INFO_OUT            : out    std_logic_vector(487 downto 0);
      SPY_CON                 : in     std_logic;
      SPY_SDI                 : out    std_logic;
      SPY_SDO                 : in     std_logic;
      SYSRST                  : in     std_logic;
      TEMP_OUT                : out    std_logic_vector(31 downto 0);
      TS_ONE_PPS_READOUT_DONE : in     std_logic;
      TS_ONE_PPS_VALID_OUT    : out    std_logic);
  end component ;

  component THRESHOLD_COUNTERS
    port(
      CLK200MHz       : in     std_logic;
      MH1             : in     std_logic;
      MH2             : in     std_logic;
      ML1             : in     std_logic;
      ML2             : in     std_logic;
      ONE_PPS         : in     std_logic;
      SYSRST          : in     std_logic;
      TH_COUNTERS_OUT : out    std_logic_vector(63 downto 0));
  end component ;

  component LVDS_MUX
    port(
      COINC           : out    std_logic;
      COINC_MASTER    : in     std_logic;
      GPS_DATA_MASTER : in     std_logic;
      GPS_DATA_OUT    : out    std_logic;
      LVDS_IN1        : in     std_logic;
      LVDS_IN2        : in     std_logic;
      LVDS_IN3        : in     std_logic;
      LVDS_IN4        : in     std_logic;
      LVDS_OUT1       : out    std_logic;
      LVDS_OUT2       : out    std_logic;
      LVDS_OUT3       : out    std_logic;
      LVDS_OUT4       : out    std_logic;
      MASTER          : in     std_logic;
      MH1             : in     std_logic;
      MH2             : in     std_logic;
      ML1             : in     std_logic;
      ML2             : in     std_logic;
      ONE_PPS_MASTER  : in     std_logic;
      ONE_PPS_OUT     : out    std_logic;
      SH1             : out    std_logic;
      SH2             : out    std_logic;
      SL1             : out    std_logic;
      SL2             : out    std_logic);
  end component ;

  component INVERTER
    port(
      INP  : in     std_logic;
      OUTP : out    std_logic);
  end component ;

  component DUMMIES
    port(
      ADC_1_NEG_OR : in     std_logic;
      ADC_1_POS_OR : in     std_logic;
      ADC_2_NEG_OR : in     std_logic;
      ADC_2_POS_OR : in     std_logic;
      LED4         : out    std_logic;
      LED5         : out    std_logic;
      LED6         : out    std_logic;
      LED7         : out    std_logic;
      LED8         : out    std_logic;
      LED9         : out    std_logic);
  end component ;

  component LED_DRIVER
    port(
      CLK10MHz : in     std_logic;
      INP      : in     std_logic;
      SYSRST   : in     std_logic;
      nOUTP    : out    std_logic);
  end component ;

  component FIFO_SELECT
    port(
      BLOCK_COINC            : out    std_logic;
      CLK200MHz              : in     std_logic;
      CLKRD                  : in     std_logic;
      COINC_TO_END_TIME      : in     std_logic;
      COINC_TO_END_TIME1_CH1 : out    std_logic;
      COINC_TO_END_TIME1_CH2 : out    std_logic;
      COINC_TO_END_TIME2_CH1 : out    std_logic;
      COINC_TO_END_TIME2_CH2 : out    std_logic;
      CTD_IN                 : in     std_logic_vector(31 downto 0);
      CTD_OUT                : out    std_logic_vector(31 downto 0);
      DATA_OUT1_CH1          : in     std_logic_vector(11 downto 0);
      DATA_OUT1_CH2          : in     std_logic_vector(11 downto 0);
      DATA_OUT2_CH1          : in     std_logic_vector(11 downto 0);
      DATA_OUT2_CH2          : in     std_logic_vector(11 downto 0);
      DATA_OUT_CH1           : out    std_logic_vector(11 downto 0);
      DATA_OUT_CH2           : out    std_logic_vector(11 downto 0);
      DATA_READY1_CH1        : in     std_logic;
      DATA_READY1_CH2        : in     std_logic;
      DATA_READY2_CH1        : in     std_logic;
      DATA_READY2_CH2        : in     std_logic;
      DATA_READY_CH1         : out    std_logic;
      DATA_READY_CH2         : out    std_logic;
      DATA_VALID_CH1         : out    std_logic;
      DATA_VALID_CH2         : out    std_logic;
      GPS_TS_IN              : in     std_logic_vector(55 downto 0);
      GPS_TS_OUT             : out    std_logic_vector(55 downto 0);
      RDEN1_CH1              : out    std_logic;
      RDEN1_CH2              : out    std_logic;
      RDEN2_CH1              : out    std_logic;
      RDEN2_CH2              : out    std_logic;
      RDEN_CH1               : in     std_logic;
      RDEN_CH2               : in     std_logic;
      READOUT_BUSY1_CH1      : in     std_logic;
      READOUT_BUSY1_CH2      : in     std_logic;
      READOUT_BUSY2_CH1      : in     std_logic;
      READOUT_BUSY2_CH2      : in     std_logic;
      SYSRST                 : in     std_logic;
      TRIGGER_PATTERN        : out    std_logic_vector(15 downto 0);
      TRIGGER_PATTERN_IN     : in     std_logic_vector(15 downto 0));
  end component ;

  component SOFT_RESET
    port(
      CLKRD   : in     std_logic;
      RESOUT  : out    std_logic;
      SRESET  : in     std_logic;
      nHRESET : in     std_logic);
  end component ;

  signal SYSRST                  :  std_logic;
  signal CLK200MHz               :  std_logic;
  signal CLKRD                   :  std_logic;
  signal DOUT_POS1               :  std_logic_vector(11 downto 0);
  signal DOUT_NEG1               :  std_logic_vector(11 downto 0);
  signal WR_ADDRESS              :  integer range 12020 downto 0;
  signal WE                      :  std_logic;
  signal DATA_OUT_net0           :  std_logic_vector(7 downto 0);
  signal RD_ADDRESS              :  integer range 12020 downto 0;
  signal RDCLOCK                 :  std_logic;
  signal CONV_DATA_READY_net     :  std_logic;
  signal DOUT_POS0               :  std_logic_vector(11 downto 0);
  signal DOUT_NEG0               :  std_logic_vector(11 downto 0);
  signal locked                  :  std_logic;
  signal TOTAL_TIME_6X           :  integer range 12000 downto 0;
  signal DOUT_VALID              :  std_logic;
  signal RDEN                    :  std_logic;
  signal DATA_OUT                :  std_logic_vector(7 downto 0);
  signal ADDITIONAL_DATA         :  std_logic_vector(15 downto 0);
  signal GPS_TS_OUT              :  std_logic_vector(55 downto 0);
  signal CTD_OUT                 :  std_logic_vector(31 downto 0);
  signal THL1                    :  std_logic_vector(11 downto 0);
  signal THH1                    :  std_logic_vector(11 downto 0);
  signal TOTAL_TIME              :  integer range 2000 downto 0;
  signal TOTAL_TIME_3X           :  integer range 6000 downto 0;
  signal POST_TIME               :  integer range 1600 downto 0;
  signal COINC_TIME              :  integer range 1000 downto 0;
  signal THH2                    :  std_logic_vector(11 downto 0);
  signal THL2                    :  std_logic_vector(11 downto 0);
  signal TH_COUNTERS_OUT         :  std_logic_vector(63 downto 0);
  signal GPS_TS_ONE_PPS_OUT      :  std_logic_vector(55 downto 0);
  signal CTP_TS_ONE_PPS_OUT      :  std_logic_vector(31 downto 0);
  signal CTD_TS_ONE_PPS_OUT      :  std_logic_vector(31 downto 0);
  signal TS_ONE_PPS_READOUT_DONE :  std_logic;
  signal SOFT_RESET0             :  std_logic;
  signal COINC0                  :  std_logic;
  signal ML1_net                 :  std_logic;
  signal ML2_net                 :  std_logic;
  signal MH1_net                 :  std_logic;
  signal MH2_net                 :  std_logic;
  signal SL1                     :  std_logic;
  signal SH1                     :  std_logic;
  signal SL2                     :  std_logic;
  signal SH2                     :  std_logic;
  signal TS_ONE_PPS_VALID_OUT    :  std_logic;
  signal GPS_DATA_OUT            :  std_logic;
  signal TR_CONDITION            :  std_logic_vector(7 downto 0);
  signal FIFO_EMPTY              :  std_logic;
  signal EVENT_DATA_READY_net0   :  std_logic;
  signal DATA_OUT1               :  std_logic_vector(11 downto 0);
  signal DATA_OUT2               :  std_logic_vector(11 downto 0);
  signal READOUT_BUSY2           :  std_logic;
  signal COINC_TO_END_TIME2_CH1  :  std_logic;
  signal DATA_OUT_CH1            :  std_logic_vector(11 downto 0);
  signal RDEN_CH1                :  std_logic;
  signal DATA_OUT3               :  std_logic_vector(11 downto 0);
  signal DATA_OUT4               :  std_logic_vector(11 downto 0);
  signal READOUT_BUSY3           :  std_logic;
  signal READOUT_BUSY4           :  std_logic;
  signal RDEN1_CH4               :  std_logic;
  signal COINC_TO_END_TIME1_CH2  :  std_logic;
  signal COINC_TO_END_TIME2_CH2  :  std_logic;
  signal TRIGGER_PATTERN         :  std_logic_vector(15 downto 0);
  signal DATA_OUT_CH2            :  std_logic_vector(11 downto 0);
  signal RDEN_CH2                :  std_logic;
  signal TRIGGER_PATTERN0        :  std_logic_vector(15 downto 0);
  signal GPS_TS_OUT0             :  std_logic_vector(55 downto 0);
  signal CTD_OUT0                :  std_logic_vector(31 downto 0);
  signal GPS_TS_OUT1             :  std_logic_vector(55 downto 0);
  signal DATA_READY5             :  std_logic;
  signal DATA_READY3             :  std_logic;
  signal COINC_TO_END_TIME1_CH1  :  std_logic;
  signal COINC_TO_END_TIME       :  std_logic;
  signal RDEN2_CH1               :  std_logic;
  signal RDEN2_CH2               :  std_logic;
  signal DATA_READY_CH1          :  std_logic;
  signal DATA_READY_CH2          :  std_logic;
  signal READOUT_BUSY5           :  std_logic;
  signal DATA_VALID_CH2          :  std_logic;
  signal COINC_net               :  std_logic;
  signal DATA_VALID_CH1          :  std_logic;
  signal RDEN1_CH1               :  std_logic;
  signal DATA_READY4             :  std_logic;
  signal DATA_READY6             :  std_logic;
  signal SLAVE_PRESENT           :  std_logic;
  signal TEMP_OUT                :  std_logic_vector(31 downto 0);
  signal CTD_OUT1                :  std_logic_vector(31 downto 0);
  signal SAT_INFO_OUT            :  std_logic_vector(487 downto 0);
  signal LATITUDE_OUT            :  std_logic_vector(63 downto 0);
  signal LONGITUDE_OUT           :  std_logic_vector(63 downto 0);
  signal ALTITUDE_OUT            :  std_logic_vector(63 downto 0);
  signal MASTER                  :  std_logic;
  signal COMPDATA_OUT            :  std_logic_vector(127 downto 0);
  signal COMPDATA_VALID_OUT      :  std_logic;
  signal COMPDATA_READOUT_DONE   :  std_logic;
  signal READ_BUSY_OUT           :  std_logic;
  signal USB_WRITE_ENABLE        :  std_logic;
  signal GPS_PROG_ENABLE0        :  std_logic;
  signal STOP_READ_OUT           :  std_logic;
  signal ERROR_READ_OUT          :  std_logic;
  signal BLOCK_COINC             :  std_logic;
  signal ONE_PPS_OUT0            :  std_logic;

begin
  --Comparator signals twisted due to
  --analog channel swap on the board
  --ADC signals twisted due to
  --analog channel swap on the board


  u0: WINDOW_MAKER
    port map(
      CLK200MHz => CLK200MHz,
      COINC_TO_END_TIME => COINC_TO_END_TIME,
      END_OF_COINC => COINC_net,
      POST_TIME => POST_TIME,
      SYSRST => SYSRST);

  u3: STORAGE_ONE_CHANNEL
    port map(
      CLK200MHz => CLK200MHz,
      CLKRD => CLKRD,
      COINC_TO_END_TIME1 => COINC_TO_END_TIME1_CH1,
      COINC_TO_END_TIME2 => COINC_TO_END_TIME2_CH1,
      DATA_ADC_NEG => DOUT_POS1,
      DATA_ADC_POS => DOUT_NEG1,
      DATA_OUT1 => DATA_OUT1,
      DATA_OUT2 => DATA_OUT2,
      DATA_READY1 => DATA_READY6,
      DATA_READY2 => DATA_READY4,
      RDEN1 => RDEN1_CH1,
      RDEN2 => RDEN2_CH1,
      READOUT_BUSY1 => READOUT_BUSY5,
      READOUT_BUSY2 => READOUT_BUSY2,
      SYSRST => SYSRST,
      TOTAL_TIME => TOTAL_TIME);

  u4: PLL
    port map(
      CLK200MHz => CLK200MHz,
      inclk0 => CLK200MHz_LVDS,
      locked => locked);

  u5: SYNCHRONISATION
    port map(
      CLK200MHz => CLK200MHz,
      DATA_NEG_ADC => DATA_NEG_ADC_CH2,
      DATA_POS_ADC => DATA_POS_ADC_CH2,
      DCO_NEG_ADC => DCO_NEG_ADC_CH2,
      DCO_POS_ADC => DCO_POS_ADC_CH2,
      DOUT_NEG => DOUT_NEG1,
      DOUT_POS => DOUT_POS1,
      LOCKED => locked,
      SYSRST => SYSRST);

  u6: CONVERSION_12_TO_8_BIT
    port map(
      CLKRD => CLKRD,
      CONVERSION_CLK => CLK10MHz,
      CONV_DATA_READY => CONV_DATA_READY_net,
      CTD_IN => CTD_OUT0,
      CTD_OUT => CTD_OUT,
      DATA_OUT => DATA_OUT_net0,
      DATA_OUT_CH1 => DATA_OUT_CH1,
      DATA_OUT_CH2 => DATA_OUT_CH2,
      DATA_READY_CH1 => DATA_READY_CH1,
      DATA_READY_CH2 => DATA_READY_CH2,
      DATA_VALID_CH1 => DATA_VALID_CH1,
      DATA_VALID_CH2 => DATA_VALID_CH2,
      FIFO_EMPTY => FIFO_EMPTY,
      GPS_TS_IN => GPS_TS_OUT0,
      GPS_TS_OUT => GPS_TS_OUT,
      RDEN_CH1 => RDEN_CH1,
      RDEN_CH2 => RDEN_CH2,
      SYSRST => SYSRST,
      TOTAL_TIME_3X => TOTAL_TIME_3X,
      TOTAL_TIME_6X => TOTAL_TIME_6X,
      TRIGGER_PATTERN => ADDITIONAL_DATA,
      TRIGGER_PATTERN_IN => TRIGGER_PATTERN0,
      WE => WE,
      WR_ADDRESS => WR_ADDRESS);

  u7: EVENT_FIFO
    port map(
      DATA_IN => DATA_OUT_net0,
      DATA_OUT => DATA_OUT,
      RDCLOCK => RDCLOCK,
      RD_ADDRESS => RD_ADDRESS,
      WE => WE,
      WRCLOCK => CLK10MHz,
      WR_ADDRESS => WR_ADDRESS);

  u8: EVENT_FIFO_CONTROL
    port map(
      CLKRD => CLKRD,
      DATA_READY_CONV => CONV_DATA_READY_net,
      DOUT_VALID => DOUT_VALID,
      EVENT_DATA_READY => EVENT_DATA_READY_net0,
      FIFO_EMPTY => FIFO_EMPTY,
      RDCLOCK => RDCLOCK,
      RDEN => RDEN,
      RD_ADDRESS => RD_ADDRESS,
      SYSRST => SYSRST,
      TOTAL_TIME_6X => TOTAL_TIME_6X);

  u9: SYNCHRONISATION
    port map(
      CLK200MHz => CLK200MHz,
      DATA_NEG_ADC => DATA_NEG_ADC_CH1,
      DATA_POS_ADC => DATA_POS_ADC_CH1,
      DCO_NEG_ADC => DCO_NEG_ADC_CH1,
      DCO_POS_ADC => DCO_POS_ADC_CH1,
      DOUT_NEG => DOUT_NEG0,
      DOUT_POS => DOUT_POS0,
      LOCKED => locked,
      SYSRST => SYSRST);

  u10: STORAGE_ONE_CHANNEL
    port map(
      CLK200MHz => CLK200MHz,
      CLKRD => CLKRD,
      COINC_TO_END_TIME1 => COINC_TO_END_TIME1_CH2,
      COINC_TO_END_TIME2 => COINC_TO_END_TIME2_CH2,
      DATA_ADC_NEG => DOUT_POS0,
      DATA_ADC_POS => DOUT_NEG0,
      DATA_OUT1 => DATA_OUT3,
      DATA_OUT2 => DATA_OUT4,
      DATA_READY1 => DATA_READY5,
      DATA_READY2 => DATA_READY3,
      RDEN1 => RDEN1_CH4,
      RDEN2 => RDEN2_CH2,
      READOUT_BUSY1 => READOUT_BUSY3,
      READOUT_BUSY2 => READOUT_BUSY4,
      SYSRST => SYSRST,
      TOTAL_TIME => TOTAL_TIME);

  u12: TRIGGER_STUFF
    port map(
      BLOCK_COINC => BLOCK_COINC,
      CLK10MHz => CLK10MHz,
      CLK200MHz => CLK200MHz,
      COINC_TIME => COINC_TIME,
      COMPH1 => COMPH2,
      COMPH2 => COMPH1,
      COMPL1 => COMPL2,
      COMPL2 => COMPL1,
      DATA_ADC1_NEG => DOUT_NEG1,
      DATA_ADC1_POS => DOUT_POS1,
      DATA_ADC2_NEG => DOUT_NEG0,
      DATA_ADC2_POS => DOUT_POS0,
      END_OF_COINC => COINC0,
      EXT_TR_IN => EXT_TR_IN,
      HITLED1 => HITLED1,
      HITLED2 => HITLED2,
      MASTER => MASTER,
      MH1 => MH1_net,
      MH2 => MH2_net,
      ML1 => ML1_net,
      ML2 => ML2_net,
      SH1 => SH1,
      SH2 => SH2,
      SL1 => SL1,
      SL2 => SL2,
      SLAVE_PRESENT => SLAVE_PRESENT,
      SYSRST => SYSRST,
      THH1 => THH1,
      THH2 => THH2,
      THL1 => THL1,
      THL2 => THL2,
      TRIGGER_PATTERN => TRIGGER_PATTERN,
      TR_CONDITION => TR_CONDITION);

  u15: CLK_DIV
    port map(
      CLK10MHz => CLK10MHz,
      CLKRD => CLKRD,
      RST => nSYSRST);

  u11: DATA_CONTROLLER
    port map(
      ADC_A0 => ADC_A0,
      ADC_A1 => ADC_A1,
      ADC_DATA => ADC_DATA,
      ADC_MODE => ADC_MODE,
      ADC_nCS => ADC_nCS,
      ADC_nINT => ADC_nINT,
      ADC_nRD => ADC_nRD,
      ADC_nWR_RDY => ADC_nWR_RDY,
      ALTITUDE => ALTITUDE_OUT,
      CLK10MHz => CLK10MHz,
      CLKRD => CLKRD,
      COINC_TIME => COINC_TIME,
      COMPDATA => COMPDATA_OUT,
      COMPDATA_READOUT_DONE => COMPDATA_READOUT_DONE,
      COMPDATA_VALID => COMPDATA_VALID_OUT,
      CTD_IN => CTD_OUT,
      CTD_TS_ONE_PPS => CTD_TS_ONE_PPS_OUT,
      CTP_TS_ONE_PPS => CTP_TS_ONE_PPS_OUT,
      DAC_A0 => DAC_A0,
      DAC_A1 => DAC_A1,
      DAC_A2 => DAC_A2,
      DAC_DATA_0 => DAC_DATA_0,
      DAC_DATA_1 => DAC_DATA_1,
      DAC_DATA_2 => DAC_DATA_2,
      DAC_DATA_3 => DAC_DATA_3,
      DAC_DATA_4 => DAC_DATA_4,
      DAC_DATA_5 => DAC_DATA_5,
      DAC_DATA_6 => DAC_DATA_6,
      DAC_DATA_7 => DAC_DATA_7,
      DAC_nCLR => DAC_nCLR,
      DAC_nCS1 => DAC_nCS1,
      DAC_nCS2 => DAC_nCS2,
      DAC_nLDAC => DAC_nLDAC,
      DAC_nRD => DAC_nRD,
      DAC_nWR => DAC_nWR,
      DATA_IN => DATA_OUT,
      DATA_READY_FIFO => EVENT_DATA_READY_net0,
      DIN_VALID => DOUT_VALID,
      ERROR_READ_OUT => ERROR_READ_OUT,
      GPS_PROG_ENABLE => GPS_PROG_ENABLE0,
      GPS_TS_IN => GPS_TS_OUT,
      GPS_TS_ONE_PPS => GPS_TS_ONE_PPS_OUT,
      LATITUDE => LATITUDE_OUT,
      LONGITUDE => LONGITUDE_OUT,
      MASTER => MASTER,
      NEW_DATA_WHILE_READOUT => open,
      ONE_PPS => ONE_PPS_OUT0,
      POST_TIME => POST_TIME,
      RDEN => RDEN,
      READ_BUSY_OUT => READ_BUSY_OUT,
      SAT_INFO => SAT_INFO_OUT,
      SERIAL_NUMBER => SERIAL_NUMBER,
      SLAVE_PRESENT => SLAVE_PRESENT,
      SOFT_RESET => SOFT_RESET0,
      STOP_READ_OUT => STOP_READ_OUT,
      SYSRST => SYSRST,
      TEMP => TEMP_OUT,
      THH1 => THH1,
      THH2 => THH2,
      THL1 => THL1,
      THL2 => THL2,
      TH_COUNTERS_IN => TH_COUNTERS_OUT,
      TOTAL_TIME => TOTAL_TIME,
      TOTAL_TIME_3X => TOTAL_TIME_3X,
      TRIGGER_PATTERN => ADDITIONAL_DATA,
      TR_CONDITION => TR_CONDITION,
      TS_ONE_PPS_READOUT_DONE => TS_ONE_PPS_READOUT_DONE,
      TS_ONE_PPS_VALID_IN => TS_ONE_PPS_VALID_OUT,
      USB_DATA => USB_DATA,
      USB_RD => USB_RD,
      USB_RXF => USB_RXF,
      USB_TXE => USB_TXE,
      USB_WR => USB_WR,
      USB_WRITE_ENABLE => USB_WRITE_ENABLE);

  u14: GPS_STUFF
    port map(
      ALTITUDE_OUT => ALTITUDE_OUT,
      CLK10MHz => CLK10MHz,
      CLK200MHz => CLK200MHz,
      COINC => COINC_net,
      COMPDATA_OUT => COMPDATA_OUT,
      COMPDATA_READOUT_DONE => COMPDATA_READOUT_DONE,
      COMPDATA_VALID_OUT => COMPDATA_VALID_OUT,
      COMPH1_IN => COMPH2,
      COMPH2_IN => COMPH1,
      COMPL1_IN => COMPL2,
      COMPL2_IN => COMPL1,
      CTD_OUT => CTD_OUT1,
      CTD_TS_ONE_PPS_OUT => CTD_TS_ONE_PPS_OUT,
      CTP_TS_ONE_PPS_OUT => CTP_TS_ONE_PPS_OUT,
      GPS_PROG_ENABLE => GPS_PROG_ENABLE0,
      GPS_SDI => GPS_SDI,
      GPS_SDO => GPS_SDO,
      GPS_TS_ONE_PPS_OUT => GPS_TS_ONE_PPS_OUT,
      GPS_TS_OUT => GPS_TS_OUT1,
      LATITUDE_OUT => LATITUDE_OUT,
      LONGITUDE_OUT => LONGITUDE_OUT,
      MASTER => MASTER,
      ONE_PPS => ONE_PPS_OUT0,
      RXD => GPS_DATA_OUT,
      SAT_INFO_OUT => SAT_INFO_OUT,
      SPY_CON => SPY_CON,
      SPY_SDI => SPY_SDI,
      SPY_SDO => SPY_SDO,
      SYSRST => SYSRST,
      TEMP_OUT => TEMP_OUT,
      TS_ONE_PPS_READOUT_DONE => TS_ONE_PPS_READOUT_DONE,
      TS_ONE_PPS_VALID_OUT => TS_ONE_PPS_VALID_OUT);

  u1: THRESHOLD_COUNTERS
    port map(
      CLK200MHz => CLK200MHz,
      MH1 => MH1_net,
      MH2 => MH2_net,
      ML1 => ML1_net,
      ML2 => ML2_net,
      ONE_PPS => ONE_PPS_OUT0,
      SYSRST => SYSRST,
      TH_COUNTERS_OUT => TH_COUNTERS_OUT);

  u13: LVDS_MUX
    port map(
      COINC => COINC_net,
      COINC_MASTER => COINC0,
      GPS_DATA_MASTER => GPS_SDO,
      GPS_DATA_OUT => GPS_DATA_OUT,
      LVDS_IN1 => LVDS_IN1,
      LVDS_IN2 => LVDS_IN2,
      LVDS_IN3 => LVDS_IN3,
      LVDS_IN4 => LVDS_IN4,
      LVDS_OUT1 => LVDS_OUT1,
      LVDS_OUT2 => LVDS_OUT2,
      LVDS_OUT3 => LVDS_OUT3,
      LVDS_OUT4 => LVDS_OUT4,
      MASTER => MASTER,
      MH1 => MH1_net,
      MH2 => MH2_net,
      ML1 => ML1_net,
      ML2 => ML2_net,
      ONE_PPS_MASTER => ONE_PPS,
      ONE_PPS_OUT => ONE_PPS_OUT0,
      SH1 => SH1,
      SH2 => SH2,
      SL1 => SL1,
      SL2 => SL2);

  u19: INVERTER
    port map(
      INP => MASTER,
      OUTP => nMASTER);

  u20: DUMMIES
    port map(
      ADC_1_NEG_OR => ADC_1_NEG_OR,
      ADC_1_POS_OR => ADC_1_POS_OR,
      ADC_2_NEG_OR => ADC_2_NEG_OR,
      ADC_2_POS_OR => ADC_2_POS_OR,
      LED4 => open,
      LED5 => open,
      LED6 => open,
      LED7 => open,
      LED8 => open,
      LED9 => open);

  u23: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => ONE_PPS_OUT0,
      SYSRST => SYSRST,
      nOUTP => LED3);

  u25: FIFO_SELECT
    port map(
      BLOCK_COINC => BLOCK_COINC,
      CLK200MHz => CLK200MHz,
      CLKRD => CLKRD,
      COINC_TO_END_TIME => COINC_TO_END_TIME,
      COINC_TO_END_TIME1_CH1 => COINC_TO_END_TIME1_CH1,
      COINC_TO_END_TIME1_CH2 => COINC_TO_END_TIME1_CH2,
      COINC_TO_END_TIME2_CH1 => COINC_TO_END_TIME2_CH1,
      COINC_TO_END_TIME2_CH2 => COINC_TO_END_TIME2_CH2,
      CTD_IN => CTD_OUT1,
      CTD_OUT => CTD_OUT0,
      DATA_OUT1_CH1 => DATA_OUT1,
      DATA_OUT1_CH2 => DATA_OUT3,
      DATA_OUT2_CH1 => DATA_OUT2,
      DATA_OUT2_CH2 => DATA_OUT4,
      DATA_OUT_CH1 => DATA_OUT_CH1,
      DATA_OUT_CH2 => DATA_OUT_CH2,
      DATA_READY1_CH1 => DATA_READY6,
      DATA_READY1_CH2 => DATA_READY5,
      DATA_READY2_CH1 => DATA_READY4,
      DATA_READY2_CH2 => DATA_READY3,
      DATA_READY_CH1 => DATA_READY_CH1,
      DATA_READY_CH2 => DATA_READY_CH2,
      DATA_VALID_CH1 => DATA_VALID_CH1,
      DATA_VALID_CH2 => DATA_VALID_CH2,
      GPS_TS_IN => GPS_TS_OUT1,
      GPS_TS_OUT => GPS_TS_OUT0,
      RDEN1_CH1 => RDEN1_CH1,
      RDEN1_CH2 => RDEN1_CH4,
      RDEN2_CH1 => RDEN2_CH1,
      RDEN2_CH2 => RDEN2_CH2,
      RDEN_CH1 => RDEN_CH1,
      RDEN_CH2 => RDEN_CH2,
      READOUT_BUSY1_CH1 => READOUT_BUSY5,
      READOUT_BUSY1_CH2 => READOUT_BUSY3,
      READOUT_BUSY2_CH1 => READOUT_BUSY2,
      READOUT_BUSY2_CH2 => READOUT_BUSY4,
      SYSRST => SYSRST,
      TRIGGER_PATTERN => TRIGGER_PATTERN0,
      TRIGGER_PATTERN_IN => TRIGGER_PATTERN);

  u2: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => COINC_net,
      SYSRST => SYSRST,
      nOUTP => LED5);

  u26: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => BLOCK_COINC,
      SYSRST => SYSRST,
      nOUTP => LED7);

  u21: INVERTER
    port map(
      INP => SLAVE_PRESENT,
      OUTP => nSLAVE_PRESENT);

  u24: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => ERROR_READ_OUT,
      SYSRST => SYSRST,
      nOUTP => LED4);

  u27: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => STOP_READ_OUT,
      SYSRST => SYSRST,
      nOUTP => LED6);

  u28: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => READ_BUSY_OUT,
      SYSRST => SYSRST,
      nOUTP => LED9);

  u29: LED_DRIVER
    port map(
      CLK10MHz => CLK10MHz,
      INP => USB_WRITE_ENABLE,
      SYSRST => SYSRST,
      nOUTP => LED8);

  u16: SOFT_RESET
    port map(
      CLKRD => CLKRD,
      RESOUT => SYSRST,
      SRESET => SOFT_RESET0,
      nHRESET => nSYSRST);
end a0 ; -- of hisparc

